1                                           The SAS System             15:43 Monday, February 20, 2023

NOTE: Copyright (c) 2002-2012 by SAS Institute Inc., Cary, NC, USA. 
NOTE: SAS (r) Proprietary Software 9.4 (TS1M4) 
      Licensed to JAZZ PHARMACEUTICALS INC - D-WISE, Site 70203642.
NOTE: This session is executing on the X64_SR12R2  platform.



NOTE: Updated analytical products:
      
      SAS/STAT 14.2
      SAS/IML 14.2

NOTE: Additional host information:

 X64_SR12R2 WIN 6.3.9600  Server

NOTE: SAS initialization used:
      real time           6.91 seconds
      cpu time            0.07 seconds
      

NOTE: AUTOEXEC processing beginning; file is 
      C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\autoexec.sas.

MLOGIC(AUTOEXEC):  Beginning execution.
MPRINT(AUTOEXEC):   libname here " ";
NOTE: Libref HERE was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\
MLOGIC(AUTOEXEC):  %GLOBAL  GTOPLEVEL
MPRINT(AUTOEXEC):   data _null_;
MPRINT(AUTOEXEC):   path=pathname("here");
MPRINT(AUTOEXEC):   pos=index(path,"\stat\")+5;
MPRINT(AUTOEXEC):   gtoplevel=substr(path,1,pos);
MPRINT(AUTOEXEC):   call symputx("gtoplevel",gtoplevel);
MPRINT(AUTOEXEC):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(AUTOEXEC):  %PUT &gtoplevel.
SYMBOLGEN:  Macro variable GTOPLEVEL resolves to C:\SASData\JZP-150\150-201\stat\
C:\SASData\JZP-150\150-201\stat\
MPRINT(AUTOEXEC):   libname here clear;
NOTE: Libref HERE has been deassigned.
MPRINT(AUTOEXEC):   *** Identify the utilities folder ***;
MPRINT(AUTOEXEC):   filename util1 "..\..\..\..\utilities";
MPRINT(AUTOEXEC):   filename util2 "..\..\..\utilities";
MPRINT(AUTOEXEC):   filename util3 "..\..\utilities";
MPRINT(AUTOEXEC):   filename util4 "..\utilities";
MPRINT(AUTOEXEC):   filename util5 ".\utilities";
MPRINT(AUTOEXEC):   *** Identify setup.sas programs ***;
2                                           The SAS System             15:43 Monday, February 20, 2023

MPRINT(AUTOEXEC):   filename setup1 "..\..\..\..\utilities\setup.sas";
MPRINT(AUTOEXEC):   filename setup2 "..\..\..\utilities\setup.sas";
MPRINT(AUTOEXEC):   filename setup3 "..\..\utilities\setup.sas";
MPRINT(AUTOEXEC):   filename setup4 "..\utilities\setup.sas";
MPRINT(AUTOEXEC):   filename setup5 ".\utilities\setup.sas";
MPRINT(AUTOEXEC):   data _null_;
MPRINT(AUTOEXEC):   *** Identify the closest utility path ***;
MPRINT(AUTOEXEC):   path1 = pathname('util1');
MPRINT(AUTOEXEC):   path2 = pathname('util2');
MPRINT(AUTOEXEC):   path3 = pathname('util3');
MPRINT(AUTOEXEC):   path4 = pathname('util4');
MPRINT(AUTOEXEC):   path5 = pathname('util5');
MPRINT(AUTOEXEC):   if fileexist(path1) then call symput('utilpath',strip(path1));
MPRINT(AUTOEXEC):   if fileexist(path2) then call symput('utilpath',strip(path2));
MPRINT(AUTOEXEC):   if fileexist(path3) then call symput('utilpath',strip(path3));
MPRINT(AUTOEXEC):   if fileexist(path4) then call symput('utilpath',strip(path4));
MPRINT(AUTOEXEC):   if fileexist(path5) then call symput('utilpath',strip(path5));
MPRINT(AUTOEXEC):   *** Idetify the closest setup.sas program ***;
MPRINT(AUTOEXEC):   setup1 = pathname('setup1');
MPRINT(AUTOEXEC):   setup2 = pathname('setup2');
MPRINT(AUTOEXEC):   setup3 = pathname('setup3');
MPRINT(AUTOEXEC):   setup4 = pathname('setup4');
MPRINT(AUTOEXEC):   setup5 = pathname('setup5');
MPRINT(AUTOEXEC):   if fileexist(setup1) then call symput('setupprog',strip(setup1));
MPRINT(AUTOEXEC):   if fileexist(setup2) then call symput('setupprog',strip(setup2));
MPRINT(AUTOEXEC):   if fileexist(setup3) then call symput('setupprog',strip(setup3));
MPRINT(AUTOEXEC):   if fileexist(setup4) then call symput('setupprog',strip(setup4));
MPRINT(AUTOEXEC):   if fileexist(setup5) then call symput('setupprog',strip(setup5));
MPRINT(AUTOEXEC):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(AUTOEXEC):   *** Clear temporary filenames ***;
MPRINT(AUTOEXEC):   filename util1;
NOTE: Fileref UTIL1 has been deassigned.
MPRINT(AUTOEXEC):   filename util2;
NOTE: Fileref UTIL2 has been deassigned.
MPRINT(AUTOEXEC):   filename util3;
NOTE: Fileref UTIL3 has been deassigned.
MPRINT(AUTOEXEC):   filename util4;
NOTE: Fileref UTIL4 has been deassigned.
MPRINT(AUTOEXEC):   filename util5;
NOTE: Fileref UTIL5 has been deassigned.
SYMBOLGEN:  Macro variable UTILPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\utilities
MPRINT(AUTOEXEC):   options Mautosource sasautos=(sasautos 
"C:\SASData\JZP-150\150-201\stat\csr_dryrun1\utilities");
SYMBOLGEN:  Macro variable SETUPPROG resolves to 
            C:\SASData\JZP-150\150-201\stat\csr_dryrun1\utilities\setup.sas
MPRINT(AUTOEXEC):   dm "continue";
MPRINT(AUTOEXEC):   dm "out;clear;log;clear;";
MPRINT(AUTOEXEC):   data _x_;
3                                           The SAS System             15:43 Monday, February 20, 2023

MPRINT(AUTOEXEC):   set sashelp.vmacro;
MPRINT(AUTOEXEC):   where scope = "GLOBAL" and name not in : ( "SYS" "DUPS" "DUPLS");
MPRINT(AUTOEXEC):   run;

NOTE: There were 3 observations read from the data set SASHELP.VMACRO.
      WHERE (scope='GLOBAL') and name not in: ('DUPLS', 'DUPS', 'SYS');
NOTE: The data set WORK._X_ has 3 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(AUTOEXEC):   data _null_;
MPRINT(AUTOEXEC):   set _x_;
MPRINT(AUTOEXEC):   call execute('%symdel ' || name || ';');
MPRINT(AUTOEXEC):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: There were 3 observations read from the data set WORK._X_.

NOTE: CALL EXECUTE routine executed successfully, but no SAS statements were generated.
MPRINT(AUTOEXEC):   proc datasets library=work memtype = data nolist kill;
NOTE: Deleting WORK._X_ (memtype=DATA).
MPRINT(AUTOEXEC):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(AUTOEXEC):   proc datasets library=work memtype = cat nolist;
MPRINT(AUTOEXEC):   delete formats;
MPRINT(AUTOEXEC):   quit;

NOTE: The file WORK.FORMATS (memtype=CATALOG) was not found, but appears on a DELETE statement.
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(AUTOEXEC):   libname _all_;
MPRINT(AUTOEXEC):   filename _all_;
NOTE: Fileref SETUP1 has been deassigned.
NOTE: Fileref SETUP2 has been deassigned.
NOTE: Fileref SETUP3 has been deassigned.
NOTE: Fileref SETUP4 has been deassigned.
NOTE: Fileref SETUP5 has been deassigned.
MPRINT(AUTOEXEC):   title;
MPRINT(AUTOEXEC):   footnote;
MPRINT(AUTOEXEC):   ods output close;
MPRINT(AUTOEXEC):   ods listing;
4                                           The SAS System             15:43 Monday, February 20, 2023

MPRINT(AUTOEXEC):   ************************************;
MPRINT(AUTOEXEC):   *** STANDARD MACRO VARIABLES ***;
MPRINT(AUTOEXEC):   ************************************;
MPRINT(AUTOEXEC):   data _null_;
MPRINT(AUTOEXEC):   call symput("RUNDTM",trim(left(put(datetime(),datetime.))));
MPRINT(AUTOEXEC):   call symput('date', put(today(), date9.));
MPRINT(AUTOEXEC):   call symput('time', put(time(), hhmm.));
MPRINT(AUTOEXEC):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable RUNUSR resolves to NPATIL1
SYMBOLGEN:  Macro variable RUNDTM resolves to 20FEB23:15:43:39
Run by: NPATIL1 20FEB23:15:43:39
SYMBOLGEN:  Macro variable VOLUME resolves to C:\SASData\JZP-150
SYMBOLGEN:  Macro variable PROTOCOL resolves to 150-201
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable PATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1
SYMBOLGEN:  Macro variable DOCPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc
MPRINT(AUTOEXEC):   *%let hocpath = &path.\adhoc;
SYMBOLGEN:  Macro variable SYSHOSTNAME resolves to JazzProd
SYMBOLGEN:  Macro variable COMPANY resolves to Jazz Pharmaceutical
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted 
            for printing.
SYMBOLGEN:  Macro variable PROTOCOL resolves to 150-201
MPRINT(AUTOEXEC):   ************************************;
MPRINT(AUTOEXEC):   *** Include Utility Macro ***;
MPRINT(AUTOEXEC):   ************************************;
SYMBOLGEN:  Macro variable MACPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\utilities
SYMBOLGEN:  Macro variable MACPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\utilities
MPRINT(AUTOEXEC):   ************************************************************************* * STUDY 
DRUG : * PROTOCOL NO : * PROGRAMMER : Indraneel * DATE CREATED : 03FEB2022 * PROGRAM NAME : get_attr 
* DESCRIPTION : To get the attributes on the validation side programs * DATA SETS USED: 
*************************************************************************** PROGRAM MODIFICATION LOG 
*************************************************************************** Programmer: Date: 
Description: ***************************************************************************;
SYMBOLGEN:  Macro variable MACPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\utilities
MPRINT(AUTOEXEC):   ***********************************;
MPRINT(AUTOEXEC):   *** LIBRARY REFERENCES ***;
MPRINT(AUTOEXEC):   ***********************************;
MPRINT(AUTOEXEC):   *libname raw1 "&rawpath.\" access=readonly;
SYMBOLGEN:  Macro variable RAWPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\rawdata
MPRINT(AUTOEXEC):   libname raw "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\rawdata\";
NOTE: Libref RAW was successfully assigned as follows: 
      Engine:        V9 
5                                           The SAS System             15:43 Monday, February 20, 2023

      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\rawdata
MPRINT(AUTOEXEC):   *parent studies records for group A subject are from raw data*;
SYMBOLGEN:  Macro variable RAWPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\rawdata
MPRINT(AUTOEXEC):   libname rawvend "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\rawdata\vendor" 
access=readonly;
NOTE: Library RAWVEND does not exist.
MPRINT(AUTOEXEC):   *libname sdtm1 "&anapath\SDTM" access=readonly;
SYMBOLGEN:  Macro variable ANAPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata
MPRINT(AUTOEXEC):   libname sdtm "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata\SDTM";
NOTE: Libref SDTM was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata\SDTM
SYMBOLGEN:  Macro variable VALPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate
MPRINT(AUTOEXEC):   libname sdtmout 
"C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate\SDTM\QCdata";
NOTE: Libref SDTMOUT was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate\SDTM\QCdata
SYMBOLGEN:  Macro variable ANAPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata
MPRINT(AUTOEXEC):   libname cdf "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata\cdf";
NOTE: Libref CDF was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata\cdf
MPRINT(AUTOEXEC):   *libname adam1 "&anapath\\ADaM\" access=readonly;
SYMBOLGEN:  Macro variable ANAPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata
MPRINT(AUTOEXEC):   libname adam "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata\ADaM\";
NOTE: Libref ADAM was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\anadata\ADaM
SYMBOLGEN:  Macro variable VALPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate
MPRINT(AUTOEXEC):   libname adamout 
"C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate\ADaM\QCdata";
NOTE: Libref ADAMOUT was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate\ADaM\QCdata
MPRINT(AUTOEXEC):   *libname adhoc "&hocpath";
MPRINT(AUTOEXEC):   *TLF output folder;
SYMBOLGEN:  Macro variable VALPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate
SYMBOLGEN:  Macro variable TLFOUT resolves to 
            C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate\tfls\results
MPRINT(AUTOEXEC):   libname tlfout 
"C:\SASData\JZP-150\150-201\stat\csr_dryrun1\validate\tfls\results";
NOTE: Library TLFOUT does not exist.
SYMBOLGEN:  Macro variable RSLTPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results
MPRINT(AUTOEXEC):   libname tlfdata "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\tlfdata";
NOTE: Libref TLFDATA was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\tlfdata
MPRINT(AUTOEXEC):   libname tlfdata2 'C:\SASData\JZP-150\201\stat\csr_dryrun1\anadata';
NOTE: Library TLFDATA2 does not exist.
MPRINT(AUTOEXEC):   *Patient Profiles;
MPRINT(AUTOEXEC):   libname ppdata 'C:\SASData\JZP-150\201\stat\csr_dryrun1\Patient Profiles\data';
NOTE: Library PPDATA does not exist.
MPRINT(AUTOEXEC):   *Patient Profiles_;
6                                           The SAS System             15:43 Monday, February 20, 2023

MPRINT(AUTOEXEC):   libname pfdata 'C:\SASData\JZP-150\201\stat\csr_dryrun1\Patient 
Profiles\data\profile';
NOTE: Library PFDATA does not exist.
SYMBOLGEN:  Macro variable PGMPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm
MPRINT(AUTOEXEC):   ******************************;
MPRINT(AUTOEXEC):   *** DEFINE GLOBAL SETTINGS ***;
MPRINT(AUTOEXEC):   ******************************;
MPRINT(AUTOEXEC):   options nodate center pageno=1 ls=152 ps=47 nofmterr mrecall msglevel=I ;
MLOGIC(AUTOEXEC):  Ending execution.

NOTE: AUTOEXEC processing completed.

1          /*************************************************************************
2           * STUDY DRUG:
3           * PROTOCOL NO:
4           * PROGRAMMER:        Arun Kumar
5           * DATE CREATED:
6           * PROGRAM NAME:      t_caps5_totscr_mfasfl.sas
7           * DESCRIPTION:       Primary Efficacy Endpoint, Change in CAPS5
8           * DATA SETS USED:
9           ***************************************************************************
10         PROGRAM MODIFICATION LOG
11         ***************************************************************************
12         Programmer: Vijay Koduru
13         Date: 03Jun2020
14         Details: Change CMD label, decimals for LSM/CI, LMD to 2. Insert blank rows between sections.
15         *************************************************************************/;
16         OPTIONS MPRINT NONUMBER;
17         
18         *-----------------------------------------------------------------;
19         *INCLUDE THE TLF DEFAULTS FOR THE POPULATION AND DATASETS.;
20         *UPDATE ANY DEFAULTS AS REQUIRED FOR THE TABLE;
21         *-----------------------------------------------------------------;
22         /*
23         %include "_treatment_defaults-mITT.sas" ;
24         %include "_treatment_defaults-ess-mITT.sas" ;
25         */
26         
27         
28         PROC DATASETS LIB=WORK MEMTYPE=DATA KILL;
                                                                       Directory

                                          Libref             WORK                                             
                                          Engine             V9                                               
                                          Physical Name      E:\SAS Temporary Files\npatil1\_TD75112_JAZZPROD_
                                                                     The SAS System

                                                                       Directory

                                          Filename           E:\SAS Temporary Files\npatil1\_TD75112_JAZZPROD_
                                          Owner Name         JAZZPROD\npatil1                                 
                                          File Size          0KB                                              
                                          File Size (bytes)  0                                                
WARNING: No matching members in directory.
28       !                                          QUIT;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

29         options orientation=landscape missing=' ' nodate nonumber;
30         
31            *TITLE AND FOOTNOTES;
32            %JM_TF (jm_infile=&tocpath., JM_PROG_NAME= %jm_get_pgmname,JM_PRODUCE_STATEMENTS=Y);
MLOGIC:  Beginning compilation of JM_TF using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_tf.sas.
MLOGIC:  Ending compilation of JM_TF.
MLOGIC(JM_TF):  Beginning execution.
MLOGIC(JM_TF):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_tf.sas
SYMBOLGEN:  Macro variable TOCPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
MLOGIC(JM_TF):  Beginning compilation of JM_GET_PGMNAME using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_get_pgmname.sas.
MLOGIC(JM_TF):  Ending compilation of JM_GET_PGMNAME.
MLOGIC(JM_GET_PGMNAME):  Beginning execution.
MLOGIC(JM_GET_PGMNAME):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_get_pgmname.sas
MLOGIC(JM_GET_PGMNAME):  %LOCAL  JM_PGMNAME
SYMBOLGEN:  Macro variable SYSPROCESSNAME resolves to Program "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas"
MLOGIC(JM_GET_PGMNAME):  %IF condition %index(&sysprocessname,DMS) is FALSE
SYMBOLGEN:  Macro variable SYSPROCESSNAME resolves to Program "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas"
MLOGIC(JM_GET_PGMNAME):  %IF condition %index(&sysprocessname,Program) is TRUE
MLOGIC(JM_GET_PGMNAME):  %LET (variable name is JM_PGMNAME)
SYMBOLGEN:  Macro variable JM_PGMNAME resolves to t_ecg_saffl
MLOGIC(JM_GET_PGMNAME):  Ending execution.
MLOGIC(JM_TF):  Parameter JM_INFILE has value C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
MLOGIC(JM_TF):  Parameter JM_PROG_NAME has value t_ecg_saffl
MLOGIC(JM_TF):  Parameter JM_PRODUCE_STATEMENTS has value Y
MLOGIC(JM_TF):  Parameter JM_OUT_NUMBER has value 
                                                           The SAS System

MLOGIC(JM_TF):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_TF):  Parameter JM_DEBUG has value 
MLOGIC(JM_TF):  Parameter JM_TITLE_OPT has value 
MLOGIC(JM_TF):  Parameter JM_TITLE_FONT has value 
MLOGIC(JM_TF):  Parameter JM_FOOT_OPT has value 
MLOGIC(JM_TF):  Parameter JM_FOOT_FONT has value 
MLOGIC(JM_TF):  Parameter JM_HEADER has value &DEFAULT_HEADER
MPRINT(JM_TF):   *** Initialize DEFAULT_HEADER if not defined ***;
MLOGIC(JM_TF):  %IF condition %symexist(DEFAULT_HEADER)=0 is TRUE
MLOGIC(JM_TF):  %LET (variable name is DEFAULT_HEADER)
MPRINT(JM_TF):   *** Document in log what parameter value specified ***;
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INFILE resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
MPRINT(JM_TF):   PUT "ALERT:I: JM_INFILE PROCESSED - C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap";
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   PUT "ALERT:I: JM_PROG_NAME PROCESSED - t_ecg_saffl";
SYMBOLGEN:  Macro variable JM_OUT_NUMBER resolves to 
MPRINT(JM_TF):   PUT "ALERT:I: JM_OUT_NUMBER PROCESSED - ";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_TF):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to 
MPRINT(JM_TF):   PUT "ALERT:I: JM_DEBUG PROCESSED - ";
SYMBOLGEN:  Macro variable JM_PRODUCE_STATEMENTS resolves to Y
MPRINT(JM_TF):   PUT "ALERT:I: JM_PRODUCE_STATEMENTS PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_TITLE_OPT resolves to 
MPRINT(JM_TF):   PUT "ALERT:I: JM_TITLE_OPT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to 
MPRINT(JM_TF):   PUT "ALERT:I: JM_TITLE_FONT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_FOOT_OPT resolves to 
MPRINT(JM_TF):   PUT "ALERT:I: JM_FOOT_OPT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_FOOT_FONT resolves to 
MPRINT(JM_TF):   PUT "ALERT:I: JM_FOOT_FONT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_HEADER resolves to &DEFAULT_HEADER
SYMBOLGEN:  Macro variable DEFAULT_HEADER resolves to 
MPRINT(JM_TF):   PUT "ALERT:I: JM_HEADER PROCESSED - ";
MPRINT(JM_TF):   put "********************************************************";
MPRINT(JM_TF):   put " ";
MPRINT(JM_TF):   put 'NOTE: [JM_TF] is currently running macro %jm_tf version 1.0.';
MPRINT(JM_TF):   put " ";
                                                           The SAS System

MPRINT(JM_TF):   run;


******************* Parameter Values *******************
ALERT:I: JM_INFILE PROCESSED - C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
ALERT:I: JM_PROG_NAME PROCESSED - t_ecg_saffl
ALERT:I: JM_OUT_NUMBER PROCESSED - 
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_DEBUG PROCESSED - 
ALERT:I: JM_PRODUCE_STATEMENTS PROCESSED - Y
ALERT:I: JM_TITLE_OPT PROCESSED - 
ALERT:I: JM_TITLE_FONT PROCESSED - 
ALERT:I: JM_FOOT_OPT PROCESSED - 
ALERT:I: JM_FOOT_FONT PROCESSED - 
ALERT:I: JM_HEADER PROCESSED - 
********************************************************

NOTE: [JM_TF] is currently running macro %jm_tf version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Verify if the SYMBOLGEN options is set ***;
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   set sashelp.voption;
MPRINT(JM_TF):   where optname = 'SYMBOLGEN';
MPRINT(JM_TF):   call symputx('c_symbolgen',setting);
MPRINT(JM_TF):   run;

NOTE: There were 1 observations read from the data set SASHELP.VOPTION.
      WHERE optname='SYMBOLGEN';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_TF):  %GLOBAL  JM_G_PROGNAME
MLOGIC(JM_TF):  %LET (variable name is JM_G_PROGNAME)
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MLOGIC(JM_TF):  %LET (variable name is _ERR)
                                                           The SAS System

MPRINT(JM_TF):   *** Default JM_INFILE to DOCPATH if it is specified ***;
MLOGIC(JM_TF):  %IF condition %symexist(docpath) is TRUE
MPRINT(JM_TF):   data _null_;
SYMBOLGEN:  Macro variable JM_INFILE resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
MPRINT(JM_TF):   jm_infile = strip("C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap");
SYMBOLGEN:  Macro variable DOCPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc
MPRINT(JM_TF):   docpath = strip("C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc");
MPRINT(JM_TF):   if jm_infile = '' and docpath ne '' then do;
MPRINT(JM_TF):   call symputx('jm_infile',docpath);
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** 1) Macro will check whether &JM_INFILE exists. If not, macro will issue er ror message ***;
MPRINT(JM_TF):   data _null_;
SYMBOLGEN:  Macro variable JM_INFILE resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
MPRINT(JM_TF):   if fileexist("C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap\candid_TOC.xlsx") = 0 then do;
MPRINT(JM_TF):   put ' ';
SYMBOLGEN:  Macro variable JM_INFILE resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
MPRINT(JM_TF):   put "ER" "ROR:[jm_tf] The external file candid_TOC.xlsx is required and does not exist. " "This Excel file should 
be at: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap.";
MPRINT(JM_TF):   call symput('_err','yes');
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_TF):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TF):   *** Copy the Excel to temporary location incase it is locked ***;
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   length jm_file copycmd curpath $300;
MPRINT(JM_TF):   curpath = pathname('work');
SYMBOLGEN:  Macro variable JM_INFILE resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
                                                           The SAS System

MPRINT(JM_TF):   jm_file = strip("C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap");
MPRINT(JM_TF):   *** Enhanced to use SYSTASK to prevent current window to display in background ***;
MPRINT(JM_TF):   *** copycmd = "x '" || 'copy "' || strip(jm_file) || '\candid_TOC.xlsx" "' || strip(curpath) || 
'\candid_TOC.xlsx"' || "'";
MPRINT(JM_TF):   copycmd = "systask command '" || 'copy "' || strip(jm_file) || '\candid_TOC.xlsx" "' || strip(curpath) || 
'\candid_TOC.xlsx"' || "' WAIT";
MPRINT(JM_TF):   call symputx('copycmd',copycmd);
MPRINT(JM_TF):   jm_file2 = strip(curpath) || '\candid_TOC.xlsx';
MPRINT(JM_TF):   call symputx('jm_file2',jm_file2);
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   option noxwait xsync;
SYMBOLGEN:  Macro variable COPYCMD resolves to systask command 'copy 
            "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap\candid_TOC.xlsx" "E:\SAS Temporary 
            Files\npatil1\_TD75112_JAZZPROD_\candid_TOC.xlsx"' WAIT
MPRINT(JM_TF):   systask command 'copy "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap\candid_TOC.xlsx" "E:\SAS Temporary 
Files\npatil1\_TD75112_JAZZPROD_\candid_TOC.xlsx"' WAIT;
NOTE: Task "task0" produced no LOG/Output.
MPRINT(JM_TF):   *** Set Symbolgen to no for PROC IMPORT ***;
SYMBOLGEN:  Macro variable C_SYMBOLGEN resolves to SYMBOLGEN
MLOGIC(JM_TF):  %IF condition "&c_symbolgen" = "SYMBOLGEN" is TRUE
MPRINT(JM_TF):   options nosymbolgen;
MPRINT(JM_TF):   proc import dbms=xlsx datafile="E:\SAS Temporary Files\npatil1\_TD75112_JAZZPROD_\candid_TOC.xlsx" replace 
out=jm_tf_titft;
MPRINT(JM_TF):   RXLX;
MPRINT(JM_TF):   getnames=yes;
MPRINT(JM_TF):   datarow=2;
MPRINT(JM_TF):   sheet="TFLs";
MPRINT(JM_TF):   run;

NOTE:    Variable Name Change.  Default Test Program -> Default_Test_Program            
NOTE:    Variable Name Change.  Default Test Method -> Default_Test_Method             
NOTE:    Variable Name Change.  Initial Instructions -> Initial_Instructions            
WARNING: Some character data was lost during transcoding in column: Title2 at obs 64.
WARNING: Some character data was lost during transcoding in column: Title2 at obs 66.
WARNING: Some character data was lost during transcoding in column: Title2 at obs 86.
                                                           The SAS System

WARNING: Some character data was lost during transcoding in column: Title2 at obs 171.
WARNING: Some character data was lost during transcoding in column: Title2 at obs 172.
NOTE: The import data set has 187 observations and 64 variables.
NOTE: WORK.JM_TF_TITFT data set was successfully created.
NOTE: PROCEDURE IMPORT used (Total process time):
      real time           0.06 seconds
      cpu time            0.07 seconds
      

MPRINT(JM_TF):   *** Set Symbolgen back for PROC IMPORT ***;
MLOGIC(JM_TF):  %IF condition "&c_symbolgen" = "SYMBOLGEN" is TRUE
MPRINT(JM_TF):   options symbolgen;
MPRINT(JM_TF):   *** Verify if optional JM_OUT_NUMBER is specified and exist ***;
SYMBOLGEN:  Macro variable JM_OUT_NUMBER resolves to 
MLOGIC(JM_TF):  %IF condition "&jm_out_number" ne "" is FALSE
MPRINT(JM_TF):   *** 2) check for duplicates in column E (name), G (Program name) and F (number), for *all* rows, not just for 
specific output ***;
MPRINT(JM_TF):   data jm_tf_titft;
MPRINT(JM_TF):   set jm_tf_titft;
MPRINT(JM_TF):   *** Remove emptry rows ***;
MPRINT(JM_TF):   if program = '' then delete;
MPRINT(JM_TF):   run;

NOTE: There were 187 observations read from the data set WORK.JM_TF_TITFT.
NOTE: The data set WORK.JM_TF_TITFT has 162 observations and 64 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   proc sort data = jm_tf_titft;
MPRINT(JM_TF):   by name program number title1;
MPRINT(JM_TF):   run;

NOTE: There were 162 observations read from the data set WORK.JM_TF_TITFT.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_TF_TITFT has 162 observations and 64 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MLOGIC(JM_TF):  %LET (variable name is ISDUP)
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   set jm_tf_titft;
MPRINT(JM_TF):   by name program number title1;
MPRINT(JM_TF):   lagname = lag(name);
MPRINT(JM_TF):   lagprog = lag(program);
MPRINT(JM_TF):   lagnum = lag(number);
MPRINT(JM_TF):   if _n_ > 1 then do;
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   if (lagname = name) and (lowcase(program)=lowcase("t_ecg_saffl")) then do;
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   put "WAR" "NING:[jm_tf] There are duplicate values for the name: '" name +(-1) "'. " "This value is specified in 
column 'E' within the Candid_TOC Excel file.";
MPRINT(JM_TF):   end;
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   if (lagprog = program) and (lowcase(program)=lowcase("t_ecg_saffl")) then do;
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   put "WAR" "NING:[jm_tf] There are duplicate values for the program: '" program +(-1) "'. " "This value is 
specified in column 'G' within the Candid_TOC Excel file.";
MPRINT(JM_TF):   end;
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   if (lagnum = number) and (lowcase(program)=lowcase("t_ecg_saffl")) then do;
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   put "WAR" "NING:[jm_tf] There are duplicate values for the number: '" number +(-1) "'. " "This value is specified 
in column 'F' within the Candid_TOC Excel file.";
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   *** Identify if both the 'name' and 'number' are duplicate ***;
MPRINT(JM_TF):   if (lagname = name) and (lagnum = number) then call symputx('isdup','yes');
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: There were 162 observations read from the data set WORK.JM_TF_TITFT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TF):   *** In the event of duplicate, get the first instance ***;
SYMBOLGEN:  Macro variable ISDUP resolves to no
MLOGIC(JM_TF):  %IF condition "&isdup" = "yes" is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_TF):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TF):   *** Verify invalid parameters ***;
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   *** Set default value ***;
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to 
MPRINT(JM_TF):   if compress("") = "" then call symputx('JM_TITLE_FONT','fontstyle=ROMAN fontsize=10pt font_weight=bold');
SYMBOLGEN:  Macro variable JM_DEBUG resolves to 
MPRINT(JM_TF):   debug=upcase(strip(""));
MPRINT(JM_TF):   if compress(debug) = '' then do;
MPRINT(JM_TF):   debug='N';
MPRINT(JM_TF):   call symputx('jm_debug','N');
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if debug not in("N","Y") then do;
MPRINT(JM_TF):   put ' ';
SYMBOLGEN:  Macro variable JM_DEBUG resolves to 
MPRINT(JM_TF):   put "ER" "ROR:[jm_tf] An invalid character has specified to the parameter JM_DEBUG=. " 'Only "Y" or "N" are 
permitted. Please specify proper JM_DEBUG.';
MPRINT(JM_TF):   call symput('_err','yes');
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_TF):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TF):   *** Apply debugging er ror checking if specified ***;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MLOGIC(JM_TF):  %IF condition %upcase("&jm_debug") = "Y" or %upcase("&jm_debug") = "YES" is FALSE
MPRINT(JM_TF):   *** Identify the current program name if not specified ***;
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   set sashelp.vextfl;
MPRINT(JM_TF):   if (substr(fileref,1,3)='_LN' or substr (fileref,1,3)='#LN' or substr(fileref,1,3)='SYS') and 
index(upcase(xpath),'.SAS')>0 then do;
MPRINT(JM_TF):   slashpos = 1;
MPRINT(JM_TF):   do i = 1 to length(xpath);
MPRINT(JM_TF):   if substr(xpath,i,1) = '\' then slashpos = i;
                                                           The SAS System

MPRINT(JM_TF):   end;
MPRINT(JM_TF):   curprog = substr(xpath,slashpos+1);
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   if compress("t_ecg_saffl") = "" then do;
MPRINT(JM_TF):   if index(lowcase(curprog),'.sas') = 0 then do;
MPRINT(JM_TF):   curprog = trim(curprog) || ".sas";
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   call symput("jm_prog_name",trim(curprog));
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   else do;
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   curprog = strip("t_ecg_saffl");
MPRINT(JM_TF):   if index(lowcase(curprog),'.sas') = 0 then do;
MPRINT(JM_TF):   curprog = trim(curprog) || ".sas";
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   call symput("jm_prog_name",trim(curprog));
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   stop;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: There were 3 observations read from the data set SASHELP.VEXTFL.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** 3) Verify match current SAS program name or user specified program name “JM_G_PROGNAME=& JM_G_PROGNAME=” with 
column G in Candid excel doc ***;
MLOGIC(JM_TF):  %LET (variable name is JM_PROG_NAME)
MLOGIC(JM_GET_PGMNAME):  Beginning execution.
MLOGIC(JM_GET_PGMNAME):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_get_pgmname.sas
MLOGIC(JM_GET_PGMNAME):  %LOCAL  JM_PGMNAME
SYMBOLGEN:  Macro variable SYSPROCESSNAME resolves to Program "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas"
MLOGIC(JM_GET_PGMNAME):  %IF condition %index(&sysprocessname,DMS) is FALSE
SYMBOLGEN:  Macro variable SYSPROCESSNAME resolves to Program "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas"
MLOGIC(JM_GET_PGMNAME):  %IF condition %index(&sysprocessname,Program) is TRUE
MLOGIC(JM_GET_PGMNAME):  %LET (variable name is JM_PGMNAME)
SYMBOLGEN:  Macro variable JM_PGMNAME resolves to t_ecg_saffl
MLOGIC(JM_GET_PGMNAME):  Ending execution.
                                                           The SAS System

MLOGIC(JM_TF):  %LET (variable name is PROGEXIST)
MPRINT(JM_TF):   data test;
MPRINT(JM_TF):   length program $80;
MPRINT(JM_TF):   set jm_tf_titft;
MPRINT(JM_TF):   *** Add extension if missing ***;
MPRINT(JM_TF):   if index(lowcase(program),'.sas') = 0 then do;
MPRINT(JM_TF):   program = trim(program) || ".sas";
MPRINT(JM_TF):   format program;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   *** Handle extenstions for SAS EG ***;
MPRINT(JM_TF):   jm_prog_name=lowcase(symget('jm_prog_name'));
MPRINT(JM_TF):   if index(jm_prog_name,'.sas') = 0 then jm_prog_name = trim(jm_prog_name) || ".sas";
MPRINT(JM_TF):   if upcase(program) = upcase(jm_prog_name) then call symput('progexist','yes');
MPRINT(JM_TF):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      32:36    jm_prog_name
NOTE: There were 162 observations read from the data set WORK.JM_TF_TITFT.
NOTE: The data set WORK.TEST has 162 observations and 65 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   data _null_;
SYMBOLGEN:  Macro variable PROGEXIST resolves to yes
MPRINT(JM_TF):   if "yes" = "no" then do;
MPRINT(JM_TF):   put ' ';
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   put "ER" "ROR:[jm_tf] Program name 't_ecg_saffl' does not match " "with the Column G (program) in candid, Please 
provide a correct program name.";
MPRINT(JM_TF):   call symput('_err','yes');
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_TF):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TF):   *** 4) Verify If &JM_PRODUCE_STATEMENTS is not Y/Yes or N/No ***;
MPRINT(JM_TF):   data _null_;
SYMBOLGEN:  Macro variable JM_PRODUCE_STATEMENTS resolves to Y
MPRINT(JM_TF):   jm_produce = upcase(strip("Y"));
MPRINT(JM_TF):   if jm_produce = '' then do;
MPRINT(JM_TF):   jm_produce='Y';
MPRINT(JM_TF):   call symputx('JM_PRODUCE_STATEMENTS','Y');
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if jm_produce not in("Y","YES","N","NO") then do;
MPRINT(JM_TF):   put ' ';
SYMBOLGEN:  Macro variable JM_PRODUCE_STATEMENTS resolves to Y
MPRINT(JM_TF):   put "ER" "ROR:[jm_tf] invalid character has specified to the parameter " "JM_PRODUCE_STATEMENTS='Y'. Only 'Y' or 
'N' is permitted. " "Please specify proper JM_PRODUCE_STATEMENTS.";
MPRINT(JM_TF):   call symput('_err','yes');
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_TF):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TF):   *** 5) Verify instances where ampersand (&) is directly followed by other chars ***;
MPRINT(JM_TF):   data v_amper;
MPRINT(JM_TF):   length Footnote1Ref Footnote2Ref Footnote3Ref Footnote4Ref Footnote5Ref Footnote6Ref Footnote7Ref Footnote8Ref 
SourceDataRef Title1Ref Title2Ref Title3Ref Title4Ref Title5Ref Title6Ref Title7Ref Title8Ref templateoutputitemid $200;
MPRINT(JM_TF):   *** Initialize variables ***;
MPRINT(JM_TF):   Footnote1Ref=" ";
MPRINT(JM_TF):   Footnote2Ref=" ";
MPRINT(JM_TF):   Footnote3Ref=" ";
MPRINT(JM_TF):   Footnote4Ref=" ";
MPRINT(JM_TF):   Footnote5Ref=" ";
MPRINT(JM_TF):   Footnote6Ref=" ";
MPRINT(JM_TF):   Footnote7Ref=" ";
MPRINT(JM_TF):   Footnote8Ref=" ";
MPRINT(JM_TF):   SourceDataRef=" ";
MPRINT(JM_TF):   Title1Ref=" ";
MPRINT(JM_TF):   Title2Ref=" ";
                                                           The SAS System

MPRINT(JM_TF):   Title3Ref=" ";
MPRINT(JM_TF):   Title4Ref=" ";
MPRINT(JM_TF):   Title5Ref=" ";
MPRINT(JM_TF):   Title6Ref=" ";
MPRINT(JM_TF):   Title7Ref=" ";
MPRINT(JM_TF):   Title8Ref=" ";
MPRINT(JM_TF):   templateoutputitemid=" ";
MPRINT(JM_TF):   set jm_tf_titft;
MPRINT(JM_TF):   length badvalue $100;
MPRINT(JM_TF):   if index(Class,'&') > 0 and index(Class,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Class);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote1,'&') > 0 and index(Footnote1,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote1);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote1Created,'&') > 0 and index(Footnote1Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote1Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote1Ref,'&') > 0 and index(Footnote1Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote1Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote2,'&') > 0 and index(Footnote2,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote2);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote2Created,'&') > 0 and index(Footnote2Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote2Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote2Ref,'&') > 0 and index(Footnote2Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote2Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote3,'&') > 0 and index(Footnote3,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote3);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
                                                           The SAS System

MPRINT(JM_TF):   if index(Footnote3Created,'&') > 0 and index(Footnote3Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote3Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote3Ref,'&') > 0 and index(Footnote3Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote3Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote4,'&') > 0 and index(Footnote4,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote4);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote4Created,'&') > 0 and index(Footnote4Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote4Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote4Ref,'&') > 0 and index(Footnote4Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote4Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote5,'&') > 0 and index(Footnote5,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote5);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote5Created,'&') > 0 and index(Footnote5Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote5Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote5Ref,'&') > 0 and index(Footnote5Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote5Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote6,'&') > 0 and index(Footnote6,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote6);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote6Created,'&') > 0 and index(Footnote6Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote6Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote6Ref,'&') > 0 and index(Footnote6Ref,'& ') = 0 then do;
                                                           The SAS System

MPRINT(JM_TF):   badvalue=strip(Footnote6Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote7,'&') > 0 and index(Footnote7,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote7);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote7Created,'&') > 0 and index(Footnote7Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote7Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote7Ref,'&') > 0 and index(Footnote7Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote7Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote8,'&') > 0 and index(Footnote8,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote8);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote8Created,'&') > 0 and index(Footnote8Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote8Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Footnote8Ref,'&') > 0 and index(Footnote8Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Footnote8Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Hash,'&') > 0 and index(Hash,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Hash);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Initial_Instructions,'&') > 0 and index(Initial_Instructions,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Initial_Instructions);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Name,'&') > 0 and index(Name,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Name);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Number,'&') > 0 and index(Number,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Number);
                                                           The SAS System

MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Program,'&') > 0 and index(Program,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Program);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(SourceData,'&') > 0 and index(SourceData,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(SourceData);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(SourceDataCreated,'&') > 0 and index(SourceDataCreated,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(SourceDataCreated);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(SourceDataRef,'&') > 0 and index(SourceDataRef,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(SourceDataRef);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Status,'&') > 0 and index(Status,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Status);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(TemplateOutputItemId,'&') > 0 and index(TemplateOutputItemId,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(TemplateOutputItemId);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title1,'&') > 0 and index(Title1,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title1);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title1Ref,'&') > 0 and index(Title1Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title1Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title2,'&') > 0 and index(Title2,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title2);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title2Ref,'&') > 0 and index(Title2Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title2Ref);
MPRINT(JM_TF):   output;
                                                           The SAS System

MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title3,'&') > 0 and index(Title3,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title3);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title3Created,'&') > 0 and index(Title3Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title3Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title3Ref,'&') > 0 and index(Title3Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title3Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title4,'&') > 0 and index(Title4,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title4);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title4Created,'&') > 0 and index(Title4Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title4Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title4Ref,'&') > 0 and index(Title4Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title4Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title5,'&') > 0 and index(Title5,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title5);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title5Created,'&') > 0 and index(Title5Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title5Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title5Ref,'&') > 0 and index(Title5Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title5Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title6,'&') > 0 and index(Title6,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title6);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
                                                           The SAS System

MPRINT(JM_TF):   if index(Title6Created,'&') > 0 and index(Title6Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title6Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title6Ref,'&') > 0 and index(Title6Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title6Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title7,'&') > 0 and index(Title7,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title7);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title7Created,'&') > 0 and index(Title7Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title7Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title7Ref,'&') > 0 and index(Title7Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title7Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title8,'&') > 0 and index(Title8,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title8);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title8Created,'&') > 0 and index(Title8Created,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title8Created);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Title8Ref,'&') > 0 and index(Title8Ref,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Title8Ref);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   if index(Type,'&') > 0 and index(Type,'& ') = 0 then do;
MPRINT(JM_TF):   badvalue=strip(Type);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      32:105   32:141   32:192   32:219   32:2     32:53    32:86    32:122   32:173   32:86    32:122   32:173   32:205   32:2
      32:53    32:205   32:2     32:53    32:190   32:223   32:17    
                                                           The SAS System

NOTE: There were 162 observations read from the data set WORK.JM_TF_TITFT.
NOTE: The data set WORK.V_AMPER has 0 observations and 83 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   set v_amper;
MPRINT(JM_TF):   put ' ';
SYMBOLGEN:  Macro variable JM_INFILE resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap
MPRINT(JM_TF):   put "WAR" "NING:[jm_tf] In the excel file: " 
"(C:\SASData\JZP-150\150-201\stat\csr_dryrun1\statdoc\sap\candid_TOC.xlsx), an ampersand " "is placed in front of the following 
character string(s): " badvalue +(-1) ". " "SAS will assume that these character strings are **global** macro variables (since 
there " "is an ampersand before them). However, they do not exist in global macro library. " "Please either declare these character 
strings as global macro var-s before calling " "this macro, or replace ampersand with its unicode equivalent ^{unicode 0026} in 
excel doc.";
MPRINT(JM_TF):   run;

NOTE: There were 0 observations read from the data set WORK.V_AMPER.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_TF):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TF):   *** Create macro variables for TITLE1, NUMBER and TYPE based on TOC ***;
MPRINT(JM_TF):   data tf;
MPRINT(JM_TF):   set jm_tf_titft;
MPRINT(JM_TF):   *** Remove file extension if specified ***;
MPRINT(JM_TF):   if index(lowcase(program),'.sas') > 0 then do;
MPRINT(JM_TF):   program = substr(program,1,index(lowcase(program),'.sas')-1);
MPRINT(JM_TF):   format program;
MPRINT(JM_TF):   end;
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
SYMBOLGEN:  Macro variable JM_OUT_NUMBER resolves to 
MLOGIC(JM_TF):  %IF condition "&jm_out_number" ne "" is FALSE
MPRINT(JM_TF):   if lowcase(program)=lowcase("t_ecg_saffl") or lowcase(program)=lowcase("t_ecg_saffl.sas") or 
                                                           The SAS System

(trim(lowcase(program)) || ".sas"=lowcase("t_ecg_saffl")) then do;
MPRINT(JM_TF):   call symputx("title1",title1);
MPRINT(JM_TF):   call symputx("title2",title2);
MPRINT(JM_TF):   call symputx("title3",title3);
MPRINT(JM_TF):   call symputx("title4",title4);
MPRINT(JM_TF):   call symputx("title5",title5);
MPRINT(JM_TF):   call symputx("title6",title6);
MPRINT(JM_TF):   call symputx("title7",title7);
MPRINT(JM_TF):   call symputx("title8",title8);
MPRINT(JM_TF):   call symputx("number",number);
MPRINT(JM_TF):   call symputx("type",type);
MPRINT(JM_TF):   output;
MPRINT(JM_TF):   *** Verify if all titles are defined ***;
MPRINT(JM_TF):   if compress(title1) ne '' and compress(title2) ne '' and compress(title3) ne '' and compress(title4) ne '' and 
compress(title5) ne '' and compress(title6) ne '' and compress(title7) ne '' and compress(title8) ne '' then do;
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   put 'WAR' 'NING: [jf_tf] has defined all title1-title8 in TOC Excel.  The title8 will be excluded due to maximum 
title counts.';
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: There were 162 observations read from the data set WORK.JM_TF_TITFT.
NOTE: The data set WORK.TF has 1 observations and 64 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Transpose all the footnotes into one variable for data step processing ***;
MPRINT(JM_TF):   proc transpose data=tf out=tf_foot;
MPRINT(JM_TF):   var footnote1-footnote8;
MPRINT(JM_TF):   run;

NOTE: There were 1 observations read from the data set WORK.TF.
NOTE: The data set WORK.TF_FOOT has 8 observations and 3 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_TF):   *** Only process those with footnote text defined ***;
MPRINT(JM_TF):   data tf_foot;
MPRINT(JM_TF):   set tf_foot;
MPRINT(JM_TF):   if ^missing(col1);
MPRINT(JM_TF):   run;

NOTE: There were 8 observations read from the data set WORK.TF_FOOT.
NOTE: The data set WORK.TF_FOOT has 3 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Define separate macro variable FOOTNOTEn for each one defined in TOC ***;
MLOGIC(JM_TF):  %LET (variable name is TFOOT)
MLOGIC(JM_TF):  %LET (variable name is LFOOT)
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   set tf_foot end=eof;
MPRINT(JM_TF):   call symputx(catt("footnote",_n_),col1);
MPRINT(JM_TF):   if eof then do;
MPRINT(JM_TF):   call symputx("tfoot",_n_);
MPRINT(JM_TF):   lastfoot = _n_ + 1;
MPRINT(JM_TF):   call symputx("lfoot",lastfoot);
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   run;

NOTE: There were 3 observations read from the data set WORK.TF_FOOT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_TF):  %GLOBAL  OUTPUTNM
MPRINT(JM_TF):   *** Define the TLF number based upon 'Number' column and 'Type' in TOC ***;
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   length number1 $50;
SYMBOLGEN:  Macro variable NUMBER resolves to 9.3.3.1.1
MPRINT(JM_TF):   number="9.3.3.1.1";
SYMBOLGEN:  Macro variable TYPE resolves to Table
MPRINT(JM_TF):   type1="Table";
                                                           The SAS System

MPRINT(JM_TF):   if type1="Table" then number1=catt("t-",tranwrd(number,".","-0"));
MPRINT(JM_TF):   if type1="Figure" then number1=catt("f-",tranwrd(number,".","-0"));
MPRINT(JM_TF):   if type1="Listing" then number1=catt("l-",tranwrd(number,".","-0"));
MPRINT(JM_TF):   call symputx("outputnm",number1);
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Only define Output Number if the TLF number contains a value ***;
SYMBOLGEN:  Macro variable NUMBER resolves to 9.3.3.1.1
MLOGIC(JM_TF):  %IF condition &number eq is FALSE
MLOGIC(JM_TF):  %GLOBAL  VALOUTNM
MPRINT(JM_TF):   *** Define standard validation program name based upon 'Number' column and 'Type' in TOC ***;
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   length number2 $50;
SYMBOLGEN:  Macro variable NUMBER resolves to 9.3.3.1.1
MPRINT(JM_TF):   number="9.3.3.1.1";
SYMBOLGEN:  Macro variable TYPE resolves to Table
MPRINT(JM_TF):   type1="Table";
MPRINT(JM_TF):   if type1="Table" then number2=catt("t_",tranwrd(number,".","_0"));
MPRINT(JM_TF):   if type1="Figure" then number2=catt("f_",tranwrd(number,".","_0"));
MPRINT(JM_TF):   if type1="Listing" then number2=catt("l_",tranwrd(number,".","_0"));
MPRINT(JM_TF):   call symputx("valoutnm",number2);
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable NUMBER resolves to 9.3.3.1.1
MLOGIC(JM_TF):  %IF condition &number eq is FALSE
MPRINT(JM_TF):   libname curlib '.';
NOTE: Libref CURLIB was successfully assigned as follows: 
      Engine:        V9 
      Physical Name: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf
MPRINT(JM_TF):   *** Identify the deliverable ***;
MPRINT(JM_TF):   data _null_;
                                                           The SAS System

MPRINT(JM_TF):   curpath = pathname('curlib');
MPRINT(JM_TF):   *** Document the current path as the program path ***;
MPRINT(JM_TF):   call symputx('pgmpath',curpath);
MPRINT(JM_TF):   slashpos = length(curpath);
MPRINT(JM_TF):   slashcnt = 0;
MPRINT(JM_TF):   do i = length(curpath) to 1 by -1;
MPRINT(JM_TF):   curchar = substr(curpath,i,1);
MPRINT(JM_TF):   if curchar in('\','/') then do;
MPRINT(JM_TF):   slashcnt = slashcnt + 1;
MPRINT(JM_TF):   slashpos = i;
MPRINT(JM_TF):   if slashcnt = 2 then i = 1;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   end;
MPRINT(JM_TF):   *** Identify the deliverable as the folder above the program folder ***;
MPRINT(JM_TF):   task = substr(curpath,slashpos+1);
MPRINT(JM_TF):   task2 = substr(task,1,index(task,'\')-1);
MPRINT(JM_TF):   call symputx('deliverable',task2);
MPRINT(JM_TF):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      32:90    curpath
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Identify the data base cut off date ***;
MPRINT(JM_TF):   data rawdata;
MPRINT(JM_TF):   set sashelp.vtable;
MPRINT(JM_TF):   where libname = "RAW";
MPRINT(JM_TF):   run;

NOTE: The map data sets in library MAPSGFK are based on the digital maps from GfK GeoMarketing and are covered by their Copyright. 
      For additional information, see http://support.sas.com/mapsonline/gfklicense.
NOTE: There were 71 observations read from the data set SASHELP.VTABLE.
      WHERE libname='RAW';
NOTE: The data set WORK.RAWDATA has 71 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.35 seconds
      cpu time            0.36 seconds
      
                                                           The SAS System


MPRINT(JM_TF):   proc sort data = rawdata;
MPRINT(JM_TF):   by modate;
MPRINT(JM_TF):   run;

NOTE: There were 71 observations read from the data set WORK.RAWDATA.
NOTE: SAS sort was used.
NOTE: The data set WORK.RAWDATA has 71 observations and 41 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   set rawdata;
MPRINT(JM_TF):   by modate;
MPRINT(JM_TF):   datadate = datepart(modate);
MPRINT(JM_TF):   format datadate date9.;
MPRINT(JM_TF):   call symputx('datadate',put(datadate,date9.));
MPRINT(JM_TF):   run;

NOTE: There were 71 observations read from the data set WORK.RAWDATA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Hold onto headers for in-text table uses ***;
MPRINT(JM_TF):   data inheaders;
MPRINT(JM_TF):   length header1 header2 $200;
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable JM_HEADER resolves to &DEFAULT_HEADER
SYMBOLGEN:  Macro variable DEFAULT_HEADER resolves to 
MLOGIC(JM_TF):  %IF condition "&JM_HEADER" ne "" is FALSE
MPRINT(JM_TF):   header1 = 'j=l "^S={' || "fontstyle=ROMAN fontsize=10pt font_weight=bold" || '}Jazz Pharmaceuticals"' || 'j=r 
"Page ^{pageof}"' ;
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable PROTOCOL resolves to 150-201
MPRINT(JM_TF):   header2="^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}Protocol 150-201";
MPRINT(JM_TF):   run;

                                                           The SAS System

NOTE: The data set WORK.INHEADERS has 1 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TF):   *** Hold onto titles for in-text table uses ***;
MPRINT(JM_TF):   data intitles;
MPRINT(JM_TF):   length title $200;
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable TYPE resolves to Table
SYMBOLGEN:  Macro variable NUMBER resolves to 9.3.3.1.1
SYMBOLGEN:  Macro variable TITLE1 resolves to 
MPRINT(JM_TF):   title = "^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}Table 9.3.3.1.1  ";
MPRINT(JM_TF):   output;
SYMBOLGEN:  Macro variable TITLE2 resolves to ECG Parameters
MLOGIC(JM_TF):  %IF condition "&title2" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable TITLE2 resolves to ECG Parameters
MPRINT(JM_TF):   title ="^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}ECG Parameters";
MPRINT(JM_TF):   output;
SYMBOLGEN:  Macro variable TITLE3 resolves to (Safety Analysis Set)
MLOGIC(JM_TF):  %IF condition "&title3" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable TITLE3 resolves to (Safety Analysis Set)
MPRINT(JM_TF):   title ="^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}(Safety Analysis Set)";
MPRINT(JM_TF):   output;
SYMBOLGEN:  Macro variable TITLE4 resolves to 
MLOGIC(JM_TF):  %IF condition "&title4" ne "" is FALSE
SYMBOLGEN:  Macro variable TITLE5 resolves to 
MLOGIC(JM_TF):  %IF condition "&title5" ne "" is FALSE
SYMBOLGEN:  Macro variable TITLE6 resolves to 
MLOGIC(JM_TF):  %IF condition "&title6" ne "" is FALSE
SYMBOLGEN:  Macro variable TITLE7 resolves to 
MLOGIC(JM_TF):  %IF condition "&title7" ne "" is FALSE
SYMBOLGEN:  Macro variable TITLE8 resolves to 
MLOGIC(JM_TF):  %IF condition "&title8" ne "" is FALSE
MPRINT(JM_TF):   run;

NOTE: The data set WORK.INTITLES has 3 observations and 1 variables.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Only produce the titles and footnote if option is specified as yes ***;
SYMBOLGEN:  Macro variable JM_PRODUCE_STATEMENTS resolves to Y
SYMBOLGEN:  Macro variable JM_PRODUCE_STATEMENTS resolves to Y
MLOGIC(JM_TF):  %IF condition %upcase("&jm_produce_statements") = "Y" or %upcase("&jm_produce_statements") = "YES" is TRUE
MPRINT(JM_TF):   *** Allow for long quoted titles and footnotes ***;
MPRINT(JM_TF):   option noquotelenmax;
MPRINT(JM_TF):   *** Define actual SAS titles based on derived TOC information ***;
SYMBOLGEN:  Macro variable JM_TITLE_OPT resolves to 
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable JM_HEADER resolves to &DEFAULT_HEADER
SYMBOLGEN:  Macro variable DEFAULT_HEADER resolves to 
MLOGIC(JM_TF):  %IF condition "&JM_HEADER" ne "" is FALSE
MPRINT(JM_TF):   title1 j=l "^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}Jazz Pharmaceuticals" j=r "Page ^{pageof}";
SYMBOLGEN:  Macro variable JM_TITLE_OPT resolves to 
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable PROTOCOL resolves to 150-201
MPRINT(JM_TF):   title2 j=l "^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}Protocol 150-201";
SYMBOLGEN:  Macro variable JM_TITLE_OPT resolves to 
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable TYPE resolves to Table
SYMBOLGEN:  Macro variable NUMBER resolves to 9.3.3.1.1
SYMBOLGEN:  Macro variable TITLE1 resolves to 
MPRINT(JM_TF):   title3 "^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}Table 9.3.3.1.1  ";
SYMBOLGEN:  Macro variable TITLE2 resolves to ECG Parameters
MLOGIC(JM_TF):  %IF condition "&title2" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_TITLE_OPT resolves to 
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable TITLE2 resolves to ECG Parameters
MPRINT(JM_TF):   title4 j=c "^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}ECG Parameters";
SYMBOLGEN:  Macro variable TITLE3 resolves to (Safety Analysis Set)
MLOGIC(JM_TF):  %IF condition "&title3" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_TITLE_OPT resolves to 
SYMBOLGEN:  Macro variable JM_TITLE_FONT resolves to fontstyle=ROMAN fontsize=10pt font_weight=bold
SYMBOLGEN:  Macro variable TITLE3 resolves to (Safety Analysis Set)
MPRINT(JM_TF):   title5 j=c "^S={fontstyle=ROMAN fontsize=10pt font_weight=bold}(Safety Analysis Set)";
SYMBOLGEN:  Macro variable TITLE4 resolves to 
MLOGIC(JM_TF):  %IF condition "&title4" ne "" is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable TITLE5 resolves to 
MLOGIC(JM_TF):  %IF condition "&title5" ne "" is FALSE
SYMBOLGEN:  Macro variable TITLE6 resolves to 
MLOGIC(JM_TF):  %IF condition "&title6" ne "" is FALSE
SYMBOLGEN:  Macro variable TITLE7 resolves to 
MLOGIC(JM_TF):  %IF condition "&title7" ne "" is FALSE
SYMBOLGEN:  Macro variable TITLE8 resolves to 
MLOGIC(JM_TF):  %IF condition "&title8" ne "" is FALSE
MPRINT(JM_TF):   *** Define actual SAS footnotes based upon macro variable derived from TOC ***;
SYMBOLGEN:  Macro variable TFOOT resolves to 3
MLOGIC(JM_TF):  %DO loop beginning; index variable I; start value is 1; stop value is 3; by value is 1.  
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable JM_FOOT_OPT resolves to 
SYMBOLGEN:  Macro variable JM_FOOT_FONT resolves to 
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable FOOTNOTE1 resolves to Note: The Safety Analysis Set includes all participants who took at least 1 dose 
            of study intervention.
MPRINT(JM_TF):   footnote1 j=l "^S={}Note: The Safety Analysis Set includes all participants who took at least 1 dose of study 
intervention.";
MLOGIC(JM_TF):  %DO loop index variable I is now 2; loop will iterate again.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable JM_FOOT_OPT resolves to 
SYMBOLGEN:  Macro variable JM_FOOT_FONT resolves to 
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable FOOTNOTE2 resolves to Note: The baseline (Day -1) value is generally defined as the last non-missing 
            value obtained (scheduled or unscheduled, including repeats and retests) prior to the initiation of study intervention.
MPRINT(JM_TF):   footnote2 j=l "^S={}Note: The baseline (Day -1) value is generally defined as the last non-missing value obtained 
(scheduled or unscheduled, including repeats and retests) prior to the initiation of study intervention.";
MLOGIC(JM_TF):  %DO loop index variable I is now 3; loop will iterate again.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable JM_FOOT_OPT resolves to 
SYMBOLGEN:  Macro variable JM_FOOT_FONT resolves to 
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable FOOTNOTE3 resolves to Note: Results collected during an Early Termination visit have been mapped to the 
            next available visit.
MPRINT(JM_TF):   footnote3 j=l "^S={}Note: Results collected during an Early Termination visit have been mapped to the next 
available visit.";
MLOGIC(JM_TF):  %DO loop index variable I is now 4; loop will not iterate again.
                                                           The SAS System

MLOGIC(JM_TF):  %LET (variable name is SYSIN)
MPRINT(JM_TF):   *** Add extension if it does not exist ***;
MPRINT(JM_TF):   data _null_;
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   curprog = strip("t_ecg_saffl");
MPRINT(JM_TF):   if index(lowcase(curprog),'.sas') = 0 then call symputx('prog_name',strip(curprog) || ".sas");
MPRINT(JM_TF):   else call symputx('prog_name',curprog);
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Create data extract if specified ***;
MLOGIC(JM_TF):  %IF condition %symexist(datextr) and %symexist(datatyp) is FALSE
MLOGIC(JM_TF):  %IF condition %symexist(datextr) is FALSE
MLOGIC(JM_TF):  %LET (variable name is DATA_EXTRACT)
MPRINT(JM_TF):   *** Define the final footnote according to Step 7 in specification ***;
SYMBOLGEN:  Macro variable LFOOT resolves to 4
SYMBOLGEN:  Macro variable JM_FOOT_OPT resolves to 
SYMBOLGEN:  Macro variable JM_FOOT_FONT resolves to 
SYMBOLGEN:  Macro variable PGMPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf
SYMBOLGEN:  Macro variable PROG_NAME resolves to t_ecg_saffl.sas
SYMBOLGEN:  Macro variable DATA_EXTRACT resolves to 
SYMBOLGEN:  Macro variable SYSDATE9 resolves to 20FEB2023
SYMBOLGEN:  Macro variable SYSTIME resolves to 15:43
MPRINT(JM_TF):   footnote4 j=l "^S={}PROGRAM NAME: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas   " "  DATE: 
20FEB2023:15:43";
MPRINT(JM_TF):   *** footnote10 j=l &JM_FOOT_OPT "^S={&JM_FOOT_FONT} &sysin " ;
MPRINT(JM_TF):   *** Hold onto footers for in-text table uses ***;
MPRINT(JM_TF):   data infoots;
MPRINT(JM_TF):   length foot progfoot $800;
SYMBOLGEN:  Macro variable JM_FOOT_FONT resolves to 
SYMBOLGEN:  Macro variable PGMPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf
SYMBOLGEN:  Macro variable PROG_NAME resolves to t_ecg_saffl.sas
SYMBOLGEN:  Macro variable DATA_EXTRACT resolves to 
SYMBOLGEN:  Macro variable SYSDATE9 resolves to 20FEB2023
SYMBOLGEN:  Macro variable SYSTIME resolves to 15:43
MPRINT(JM_TF):   progfoot = "^S={}PROGRAM NAME: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas   " || "  DATE: 
20FEB2023:15:43";
                                                           The SAS System

MPRINT(JM_TF):   foot = " ";
SYMBOLGEN:  Macro variable TFOOT resolves to 3
MLOGIC(JM_TF):  %DO loop beginning; index variable I; start value is 1; stop value is 3; by value is 1.  
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable FOOTNOTE1 resolves to Note: The Safety Analysis Set includes all participants who took at least 1 dose 
            of study intervention.
MPRINT(JM_TF):   foot= "Note: The Safety Analysis Set includes all participants who took at least 1 dose of study intervention.";
MPRINT(JM_TF):   output;
MLOGIC(JM_TF):  %DO loop index variable I is now 2; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable FOOTNOTE2 resolves to Note: The baseline (Day -1) value is generally defined as the last non-missing 
            value obtained (scheduled or unscheduled, including repeats and retests) prior to the initiation of study intervention.
MPRINT(JM_TF):   foot= "Note: The baseline (Day -1) value is generally defined as the last non-missing value obtained (scheduled or 
unscheduled, including repeats and retests) prior to the initiation of study intervention.";
MPRINT(JM_TF):   output;
MLOGIC(JM_TF):  %DO loop index variable I is now 3; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable FOOTNOTE3 resolves to Note: Results collected during an Early Termination visit have been mapped to the 
            next available visit.
MPRINT(JM_TF):   foot= "Note: Results collected during an Early Termination visit have been mapped to the next available visit.";
MPRINT(JM_TF):   output;
MLOGIC(JM_TF):  %DO loop index variable I is now 4; loop will not iterate again.
MPRINT(JM_TF):   run;

NOTE: The data set WORK.INFOOTS has 3 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Verify if the standard macro variable is defined ***;
MPRINT(JM_TF):   data _null_;
MLOGIC(JM_TF):  %IF condition %symexist(datextr)=0 is TRUE
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   put "WAR" "NING:[jm_tf] was not able to resolve the macro variable DATEXTR. " "This is a standard variable that 
defines the date of data extract for the input data. ";
MPRINT(JM_TF):   put ' ';
MPRINT(JM_TF):   run;
                                                           The SAS System



WARNING:[jm_tf] was not able to resolve the macro variable DATEXTR. 
This is a standard variable that defines the date of data extract for the input data. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Purpose Step 3: Macro finds row containing SAS program name – from Step 1 - and produces global macro variable 
& JM_G_OUTPUT. ***;
MLOGIC(JM_TF):  %GLOBAL  JM_G_OUTPUT 
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   length jm_g_output $300;
SYMBOLGEN:  Macro variable JM_PROG_NAME resolves to t_ecg_saffl
MPRINT(JM_TF):   JM_G_OUTPUT=tranwrd(strip(lowcase("t_ecg_saffl")),".sas",'.rtf');
MPRINT(JM_TF):   if index(jm_g_output,'.') = 0 then jm_g_output=trim(jm_g_output) || ".rtf";
MPRINT(JM_TF):   call symputx('jm_g_output',jm_g_output);
MPRINT(JM_TF):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TF):   *** Define the last title number for users to create additional optional titles ***;
MLOGIC(JM_TF):  %GLOBAL  LASTTITLENUM
MPRINT(JM_TF):   data _null_;
MPRINT(JM_TF):   set tf(keep=title2-title8);
MPRINT(JM_TF):   call symput("lasttitlenum",strip(put(8-cmiss(of title2-title8)+2,best.)));
MPRINT(JM_TF):   run;

NOTE: There were 1 observations read from the data set WORK.TF.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_TF):  %PUT NOTE: LastTitleNum=&lasttitlenum.
SYMBOLGEN:  Macro variable LASTTITLENUM resolves to 5
NOTE: LastTitleNum=5
                                                           The SAS System

MPRINT(JM_TF):   *** Mark the end of parameter checking ***;
MLOGIC(JM_TF):  Ending execution.
33         
34            *DELETE TABLE FROM TLFDATA OF PREVIOUS ITERATION;
35            %JM_DATAPREP;
MLOGIC:  Beginning compilation of JM_DATAPREP using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_dataprep.sas.
MLOGIC:  Ending compilation of JM_DATAPREP.
MLOGIC(JM_DATAPREP):  Beginning execution.
MLOGIC(JM_DATAPREP):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_dataprep.sas
MLOGIC(JM_DATAPREP):  Parameter JM_TLFLIB has value TLFDATA
MLOGIC(JM_DATAPREP):  Parameter JM_OUTNAME has value 
MLOGIC(JM_DATAPREP):  Parameter JM_DEBUG has value N
MLOGIC(JM_DATAPREP):  Parameter JM_VERSION has value 1
MPRINT(JM_DATAPREP):   *** Document in log what parameter value specified ***;
MPRINT(JM_DATAPREP):   data _null_;
MPRINT(JM_DATAPREP):   put ' ';
MPRINT(JM_DATAPREP):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_TLFLIB resolves to TLFDATA
MPRINT(JM_DATAPREP):   PUT "ALERT:I: JM_TLFLIB PROCESSED - TLFDATA";
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to 
MPRINT(JM_DATAPREP):   PUT "ALERT:I: JM_OUTNAME PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_DATAPREP):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1
MPRINT(JM_DATAPREP):   PUT "ALERT:I: JM_VERSION PROCESSED - 1";
MPRINT(JM_DATAPREP):   put "********************************************************";
MPRINT(JM_DATAPREP):   put " ";
MPRINT(JM_DATAPREP):   put 'NOTE: [JM_DATAPREP] is currently running macro %jm_dataprep version 1.0.';
MPRINT(JM_DATAPREP):   put " ";
MPRINT(JM_DATAPREP):   run;


******************* Parameter Values *******************
ALERT:I: JM_TLFLIB PROCESSED - TLFDATA
ALERT:I: JM_OUTNAME PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1
********************************************************

NOTE: [JM_DATAPREP] is currently running macro %jm_dataprep version 1.0.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_DATAPREP):   *** Keep Count of er ror messages ***;
MLOGIC(JM_DATAPREP):  %LET (variable name is _ERR)
MLOGIC(JM_DATAPREP):  %LET (variable name is _ERRCNT)
MPRINT(JM_DATAPREP):   *** Verify invalid values for paramters ***;
MPRINT(JM_DATAPREP):   data _null_;
SYMBOLGEN:  Macro variable JM_TLFLIB resolves to TLFDATA
MLOGIC(JM_DATAPREP):  %IF condition (%sysfunc(libref(&JM_TLFLIB))) is FALSE
MPRINT(JM_DATAPREP):   run ;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_DATAPREP):   *** Set default if not specified ***;
MPRINT(JM_DATAPREP):   data _null_;
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to 
MPRINT(JM_DATAPREP):   if compress("") = "" then do;
MLOGIC(JM_DATAPREP):  %IF condition %symexist(valoutnm) is TRUE
SYMBOLGEN:  Macro variable VALOUTNM resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   call symputx('jm_outname',"t_9_03_03_01_01");
MPRINT(JM_DATAPREP):   put ' ';
MLOGIC(JM_DATAPREP):  %IF condition %symexist(valoutnm) is TRUE
SYMBOLGEN:  Macro variable VALOUTNM resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   put "NOTE:[JM_DATAPREP] is missing required parameter JM_OUTNAME. " "The default value for VALOUTNM 
(t_9_03_03_01_01) was assign to this." ;
MPRINT(JM_DATAPREP):   put " ";
MPRINT(JM_DATAPREP):   end;
MPRINT(JM_DATAPREP):   run;


NOTE:[JM_DATAPREP] is missing required parameter JM_OUTNAME. The default value for VALOUTNM (t_9_03_03_01_01) was assign to this.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_DATAPREP):   *** Verify missing parameters ***;
MPRINT(JM_DATAPREP):   data _null_;
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   if compress("t_9_03_03_01_01") = "" then do;
MPRINT(JM_DATAPREP):   put ' ';
MPRINT(JM_DATAPREP):   put "ER" "ROR:[JM_DATAPREP] is missing required parameter JM_OUTNAME. " "This specifies the SAS dataset for 
output TLF to be deleted.";
MPRINT(JM_DATAPREP):   put " ";
MPRINT(JM_DATAPREP):   call symput('_err','yes');
MPRINT(JM_DATAPREP):   end;
MPRINT(JM_DATAPREP):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_DATAPREP):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_DATAPREP):   *** Verify JM_DEBUG paramters ***;
MPRINT(JM_DATAPREP):   data _null_;
MPRINT(JM_DATAPREP):   length jm_debug $20;
MPRINT(JM_DATAPREP):   *** 3)If JM_Debug is neither 'Y' or 'N' then issue information log message ***;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_DATAPREP):   jm_debug=compress(upcase(strip("N")));
MPRINT(JM_DATAPREP):   if jm_debug not in("Y","N") then do;
MPRINT(JM_DATAPREP):   put ' ';
MPRINT(JM_DATAPREP):   put "WARN" "ING:[JM_DATAPREP] Parameter JM_DEBUG value can be either 'N' or 'Y'. " "Since entered value is 
neither 'Y' or 'N' default value has been assigned to the " "parameter JM_DEBUG=N.";
MPRINT(JM_DATAPREP):   put " ";
MPRINT(JM_DATAPREP):   call symputx('jm_debug','N');
MPRINT(JM_DATAPREP):   end;
MPRINT(JM_DATAPREP):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_DATAPREP):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_DATAPREP):   *** Identiy all datasets for libname JM_TLFLIB ***;
MPRINT(JM_DATAPREP):   proc sql;
SYMBOLGEN:  Macro variable JM_TLFLIB resolves to TLFDATA
MPRINT(JM_DATAPREP):   create table columns as select distinct memname as table_name from dictionary.columns where upcase(libname) 
= upcase("TLFDATA") ;
NOTE: Table WORK.COLUMNS created, with 145 rows and 1 columns.

MPRINT(JM_DATAPREP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_DATAPREP):   *** Hold onto only datasets specified by JM_OUTNAME ***;
MPRINT(JM_DATAPREP):   data columns;
MPRINT(JM_DATAPREP):   set columns;
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   if upcase(table_name)= UPCASE("t_9_03_03_01_01");
MPRINT(JM_DATAPREP):   run;

NOTE: There were 145 observations read from the data set WORK.COLUMNS.
NOTE: The data set WORK.COLUMNS has 1 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_DATAPREP):  %LET (variable name is DSID)
MLOGIC(JM_DATAPREP):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 1
MLOGIC(JM_DATAPREP):  %IF condition &nobs > 0 is TRUE
MLOGIC(JM_DATAPREP):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_DATAPREP):   * * * *** Delete specified dataset in libname ***;
SYMBOLGEN:  Macro variable JM_TLFLIB resolves to TLFDATA
MPRINT(JM_DATAPREP):   proc datasets lib=TLFDATA memtype= data nolist noprint;
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   delete t_9_03_03_01_01;
MPRINT(JM_DATAPREP):   quit;

                                                           The SAS System

NOTE: Deleting TLFDATA.T_9_03_03_01_01 (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_DATAPREP):   *** Verify if the dataset that is cleanned up still exists ***;
MPRINT(JM_DATAPREP):   data _null_;
SYMBOLGEN:  Macro variable JM_TLFLIB resolves to TLFDATA
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   if exist("TLFDATA.t_9_03_03_01_01") then do;
MPRINT(JM_DATAPREP):   put ' ';
SYMBOLGEN:  Macro variable JM_TLFLIB resolves to TLFDATA
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   put "ER" "ROR:[JM_DATAPREP] had difficulties deleting the dataset: TLFDATA.t_9_03_03_01_01. ";
MPRINT(JM_DATAPREP):   put " ";
MPRINT(JM_DATAPREP):   end;
MPRINT(JM_DATAPREP):   else do;
MPRINT(JM_DATAPREP):   put ' ';
SYMBOLGEN:  Macro variable JM_TLFLIB resolves to TLFDATA
SYMBOLGEN:  Macro variable JM_OUTNAME resolves to t_9_03_03_01_01
MPRINT(JM_DATAPREP):   put "NOTE:[JM_DATAPREP] successfully deleted the dataset: TLFDATA.t_9_03_03_01_01.";
MPRINT(JM_DATAPREP):   put " ";
MPRINT(JM_DATAPREP):   end;
MPRINT(JM_DATAPREP):   run;


NOTE:[JM_DATAPREP] successfully deleted the dataset: TLFDATA.t_9_03_03_01_01.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_DATAPREP):   *** Mark the end of parameter checking ***;
MLOGIC(JM_DATAPREP):  Ending execution.
36         
37            **Call Pre-processing Macro **;
38            %jm_tlf_pre(dtnames=adsl);
MLOGIC(JM_TLF_PRE):  Beginning execution.
MLOGIC(JM_TLF_PRE):  Parameter DTNAMES has value adsl
MPRINT(JM_TLF_PRE):   ***USER DEFNIED FORMATS;
                                                           The SAS System

MLOGIC(JM_TLF_PRE):  Beginning compilation of JM_FMT using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_fmt.sas.
MLOGIC(JM_TLF_PRE):  Ending compilation of JM_FMT.
MLOGIC(JM_FMT):  Beginning execution.
MLOGIC(JM_FMT):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_fmt.sas
MLOGIC(JM_FMT):  Parameter JM_DIR has value 
MLOGIC(JM_FMT):  Parameter JM_INFILE has value 
MLOGIC(JM_FMT):  Parameter JM_LIB has value 
MLOGIC(JM_FMT):  Parameter JM_DEBUG has value 
MLOGIC(JM_FMT):  Parameter JM_VERSION has value 
MPRINT(JM_FMT):   *** Document in log what parameter value specified ***;
MPRINT(JM_FMT):   data _null_;
MPRINT(JM_FMT):   put " ";
MPRINT(JM_FMT):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_DIR resolves to 
MPRINT(JM_FMT):   PUT "ALERT:I: JM_DIR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_INFILE resolves to 
MPRINT(JM_FMT):   PUT "ALERT:I: JM_INFILE PROCESSED - ";
SYMBOLGEN:  Macro variable JM_LIB resolves to 
MPRINT(JM_FMT):   PUT "ALERT:I: JM_LIB PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to 
MPRINT(JM_FMT):   PUT "ALERT:I: JM_DEBUG PROCESSED - ";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 
MPRINT(JM_FMT):   PUT "ALERT:I: JM_VERSION PROCESSED - ";
MPRINT(JM_FMT):   put "********************************************************";
MPRINT(JM_FMT):   put " ";
MPRINT(JM_FMT):   put 'NOTE: [JM_FMT] is currently running macro %jm_fmt version 1.0.';
MPRINT(JM_FMT):   put " ";
MPRINT(JM_FMT):   run;


******************* Parameter Values *******************
ALERT:I: JM_DIR PROCESSED - 
ALERT:I: JM_INFILE PROCESSED - 
ALERT:I: JM_LIB PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - 
ALERT:I: JM_VERSION PROCESSED - 
********************************************************

NOTE: [JM_FMT] is currently running macro %jm_fmt version 1.0.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_FMT):   *** Verify if the SYMBOLGEN options is set ***;
MPRINT(JM_FMT):   data _null_;
MPRINT(JM_FMT):   set sashelp.voption;
MPRINT(JM_FMT):   where optname = 'SYMBOLGEN';
MPRINT(JM_FMT):   call symputx('c_symbolgen',setting);
MPRINT(JM_FMT):   run;

NOTE: There were 1 observations read from the data set SASHELP.VOPTION.
      WHERE optname='SYMBOLGEN';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_FMT):   *** Verify default parameters ***;
MLOGIC(JM_FMT):  %LET (variable name is _ERR)
MPRINT(JM_FMT):   data _null_;
MPRINT(JM_FMT):   *** Set default values ***;
SYMBOLGEN:  Macro variable JM_INFILE resolves to 
MPRINT(JM_FMT):   if compress("") = "" then call symputx('Jm_infile','JM_Formats.xlsx');
SYMBOLGEN:  Macro variable JM_LIB resolves to 
MPRINT(JM_FMT):   if compress("") = "" then call symputx('Jm_lib','WORK');
SYMBOLGEN:  Macro variable JM_VERSION resolves to 
MPRINT(JM_FMT):   if compress("") = "" then call symputx('Jm_Version','1');
SYMBOLGEN:  Macro variable JM_DEBUG resolves to 
MPRINT(JM_FMT):   debug=upcase(strip(""));
MPRINT(JM_FMT):   if compress(debug) = '' then do;
MPRINT(JM_FMT):   debug='N';
MPRINT(JM_FMT):   call symputx('jm_debug','N');
MPRINT(JM_FMT):   end;
MPRINT(JM_FMT):   if debug not in("N","Y") then do;
MPRINT(JM_FMT):   put " ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to 
MPRINT(JM_FMT):   put "ER" "ROR:[JM_FMT] An invalid character has specified to the parameter JM_DEBUG=. " 'Only "Y" or "N" is 
permitted. Please specify proper JM_DEBUG.';
MPRINT(JM_FMT):   call symput('_err','yes');
MPRINT(JM_FMT):   end;
                                                           The SAS System

MPRINT(JM_FMT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_FMT):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MLOGIC(JM_FMT):  %IF condition %upcase("&jm_debug") = "Y" or %upcase("&jm_debug") = "YES" is FALSE
MPRINT(JM_FMT):   *** Copy the Excel to temporary location incase it is locked ***;
MPRINT(JM_FMT):   data _null_;
MPRINT(JM_FMT):   length in_file copycmd $400;
MPRINT(JM_FMT):   curpath = pathname('work');
SYMBOLGEN:  Macro variable JM_DIR resolves to 
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   if compress("")='' then in_file=strip("JM_Formats.xlsx");
SYMBOLGEN:  Macro variable JM_DIR resolves to 
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   else in_file = strip("\") || strip("JM_Formats.xlsx");
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   out_file = strip(curpath) || "\" || strip("JM_Formats.xlsx");
MPRINT(JM_FMT):   *** Enhanced to use SYSTASK to prevent current window to display in background ***;
MPRINT(JM_FMT):   *** copycmd = "x '" || 'copy "' || strip(in_file) || '" "' || strip(out_file) || '"' || "'";
MPRINT(JM_FMT):   copycmd = "systask command '" || 'copy "' || strip(in_file) || '" "' || strip(out_file) || '"' || "' WAIT";
MPRINT(JM_FMT):   call symputx('copycmd',copycmd);
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   tmpfile = strip(curpath) || "\JM_Formats.xlsx";
MPRINT(JM_FMT):   call symputx('tmpfile',tmpfile);
MPRINT(JM_FMT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      38:129   curpath
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_FMT):   option noxwait xsync;
                                                           The SAS System

SYMBOLGEN:  Macro variable COPYCMD resolves to systask command 'copy "JM_Formats.xlsx" "E:\SAS Temporary 
            Files\npatil1\_TD75112_JAZZPROD_\JM_Formats.xlsx"' WAIT
MPRINT(JM_FMT):   systask command 'copy "JM_Formats.xlsx" "E:\SAS Temporary Files\npatil1\_TD75112_JAZZPROD_\JM_Formats.xlsx"' WAIT;
NOTE: Task "task1" produced no LOG/Output.
MPRINT(JM_FMT):   *** Set Symbolgen to no for PROC IMPORT ***;
SYMBOLGEN:  Macro variable C_SYMBOLGEN resolves to SYMBOLGEN
MLOGIC(JM_FMT):  %IF condition "&c_symbolgen" = "SYMBOLGEN" is TRUE
MPRINT(JM_FMT):   options nosymbolgen;
MPRINT(JM_FMT):   *** Create the format (2) ***;
MPRINT(JM_FMT):   PROC IMPORT OUT= WORK.FORMATS DATAFILE= "E:\SAS Temporary Files\npatil1\_TD75112_JAZZPROD_\JM_Formats.xlsx" 
DBMS=EXCEL REPLACE;
MPRINT(JM_FMT):   AEXC;
MPRINT(JM_FMT):   RANGE="SHEET1$";
MPRINT(JM_FMT):   GETNAMES=YES;
MPRINT(JM_FMT):   MIXED=YES;
MPRINT(JM_FMT):   SCANTEXT=YES;
MPRINT(JM_FMT):   USEDATE=YES;
MPRINT(JM_FMT):   SCANTIME=YES;
MPRINT(JM_FMT):   RUN;

                                            The SAS System

NOTE: Data source is connected in READ ONLY mode.
NOTE: WORK.FORMATS data set was successfully created.
NOTE: The data set WORK.FORMATS has 377 observations and 5 variables.
NOTE: PROCEDURE IMPORT used (Total process time):
      real time           8.91 seconds
      cpu time            0.06 seconds
      

MPRINT(JM_FMT):   *** Set Symbolgen back for PROC IMPORT ***;
MLOGIC(JM_FMT):  %IF condition "&c_symbolgen" = "SYMBOLGEN" is TRUE
MPRINT(JM_FMT):   options symbolgen;
MPRINT(JM_FMT):   *** Verify if formats is missing required END column ***;
SYMBOLGEN:  Macro variable JM_LIB resolves to WORK
MPRINT(JM_FMT):   proc contents data = WORK.FORMATS noprint out = v_formats;
MPRINT(JM_FMT):   run;

NOTE: The data set WORK.V_FORMATS has 5 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MLOGIC(JM_FMT):  %LET (variable name is ENDVAR)
MPRINT(JM_FMT):   data _null_;
MPRINT(JM_FMT):   set v_formats;
MPRINT(JM_FMT):   if upcase(name) = 'END' then call symput('endvar','yes');
MPRINT(JM_FMT):   run;

NOTE: There were 5 observations read from the data set WORK.V_FORMATS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_FMT):   *** Inform users of the missing END variable ***;
MPRINT(JM_FMT):   data _null_;
SYMBOLGEN:  Macro variable ENDVAR resolves to yes
MPRINT(JM_FMT):   if "yes" = "no" then do;
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   put "WAR" "NING:[JM_FMT] The Excel file specfied by JM_INFILE=JM_Formats.xlsx " "is missing a key column named 
'END'. " "This will be imputed to be the same value as the 'START' column.";
MPRINT(JM_FMT):   end;
MPRINT(JM_FMT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_FMT):   *** 3) If the FMTNAME, or START, or LABEL have missing values, the macro will delete records associated with that 
format ***;
SYMBOLGEN:  Macro variable JM_LIB resolves to WORK
MPRINT(JM_FMT):   data WORK.FORMATS;
SYMBOLGEN:  Macro variable JM_LIB resolves to WORK
MPRINT(JM_FMT):   set WORK.FORMATS;
MPRINT(JM_FMT):   *** Impute the END variable if not specified ***;
SYMBOLGEN:  Macro variable ENDVAR resolves to yes
MLOGIC(JM_FMT):  %IF condition "&endvar" = "no" is FALSE
MPRINT(JM_FMT):   if compress(fmtname) = '' and (start ne '' or end ne '' or label ne '') then do;
MPRINT(JM_FMT):   put " ";
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   put "WAR" "NING:[JM_FMT] Format from row " _n_ "in JM_INFILE=JM_Formats.xlsx " "won’t be created because values 
in column (A) FMTNAME is missing.";
                                                           The SAS System

MPRINT(JM_FMT):   delete;
MPRINT(JM_FMT):   end;
MPRINT(JM_FMT):   if compress(start) = '' then do;
MPRINT(JM_FMT):   put " ";
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   put "WAR" "NING:[JM_FMT] Format from row " _n_ "in JM_INFILE=JM_Formats.xlsx " "won’t be created because values 
in column (B) START is missing.";
MPRINT(JM_FMT):   delete;
MPRINT(JM_FMT):   end;
MPRINT(JM_FMT):   if compress(label) = '' then do;
MPRINT(JM_FMT):   put " ";
SYMBOLGEN:  Macro variable JM_INFILE resolves to JM_Formats.xlsx
MPRINT(JM_FMT):   put "WAR" "NING:[JM_FMT] Format from row " _n_ "in JM_INFILE=JM_Formats.xlsx " "won’t be created because values 
in column (D) LABEL is missing.";
MPRINT(JM_FMT):   delete;
MPRINT(JM_FMT):   end;
MPRINT(JM_FMT):   run;

NOTE: There were 377 observations read from the data set WORK.FORMATS.
NOTE: The data set WORK.FORMATS has 377 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_FMT):   *** Remove periods from format name ***;
SYMBOLGEN:  Macro variable JM_LIB resolves to WORK
MPRINT(JM_FMT):   data WORK.FORMATS;
SYMBOLGEN:  Macro variable JM_LIB resolves to WORK
MPRINT(JM_FMT):   set WORK.FORMATS ;
MPRINT(JM_FMT):   fmtname = compress(tranwrd(fmtname,'.',''));
MPRINT(JM_FMT):   run;

NOTE: There were 377 observations read from the data set WORK.FORMATS.
NOTE: The data set WORK.FORMATS has 377 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_LIB resolves to WORK
                                                           The SAS System

MPRINT(JM_FMT):   PROC FORMAT CNTLIN=WORK.FORMATS;
NOTE: Format $STATSF has been output.
NOTE: Format REASN has been output.
NOTE: Format $REASC has been output.
NOTE: Format $RACEC has been output.
NOTE: Format RACEN has been output.
NOTE: Format $SEXC has been output.
NOTE: Format SEXN has been output.
NOTE: Format SEX has been output.
NOTE: Format $SEXF has been output.
NOTE: Format $ETHNICC has been output.
NOTE: Format ETHNICN has been output.
NOTE: Format $REGIONC has been output.
NOTE: Format REGIONN has been output.
NOTE: Format $COUNTRYC has been output.
NOTE: Format COUNTRYN has been output.
NOTE: Format EXCRIT has been output.
NOTE: Format $CGISC has been output.
NOTE: Format $CGISN has been output.
NOTE: Format CGISN has been output.
NOTE: Format $OSAC has been output.
NOTE: Format OSAN has been output.
NOTE: Format $CGICC has been output.
NOTE: Format CGICN has been output.
NOTE: Format $YNC has been output.
NOTE: Format YNN has been output.
NOTE: Format YNO has been output.
NOTE: Format $PGIC has been output.
NOTE: Format PGICN has been output.
NOTE: Format $IND has been output.
NOTE: Format IND has been output.
NOTE: Format $YNC is already on the library WORK.FORMATS.
NOTE: Format $YNC has been output.
NOTE: Format YN has been output.
NOTE: Format YNT has been output.
NOTE: Format SCR has been output.
NOTE: Format $COMP has been output.
NOTE: Format COMPLN has been output.
NOTE: Format $MITTREAS has been output.
NOTE: Format MITTREASN has been output.
NOTE: Format $MITTN has been output.
                                                           The SAS System

NOTE: Format $SFREAS has been output.
NOTE: Format SFREAS has been output.
NOTE: Format CRIT has been output.
NOTE: Format $PPROTREAS has been output.
NOTE: Format PPROTREASN has been output.
NOTE: Format CRITR has been output.
NOTE: Format HRCRIT has been output.
NOTE: Format BPCRIT has been output.
NOTE: Format HRCRITNP has been output.
NOTE: Format BPCRITNP has been output.
NOTE: Format WTCRIT has been output.
NOTE: Format QOL has been output.
NOTE: Format DCPERIOD has been output.
NOTE: Format POSN has been output.
NOTE: Format ATOXGR has been output.
NOTE: Format AESEV has been output.
NOTE: Format $AESEV has been output.
NOTE: Format APERIOD has been output.
NOTE: Format APERIODN has been output.
NOTE: Format CHILDPOTN has been output.
NOTE: Format SSNRISN has been output.
NOTE: Format ADVCAT has been output.
NOTE: Format $DVSCAT has been output.
NOTE: Format DVSCATN has been output.
NOTE: Format AREL has been output.
NOTE: Format AGEGR1N has been output.
NOTE: Format AGEGR2N has been output.
NOTE: Format LBSHIFT has been output.
NOTE: Format PGIS has been output.
NOTE: Format CGIS has been output.
NOTE: Format CGIC has been output.
NOTE: Format YESNO has been output.
NOTE: Format PSYPTSD has been output.
NOTE: Format LECT has been output.
NOTE: Format INDXN has been output.
NOTE: Format NORM has been output.
NOTE: Format ABNORM has been output.
NOTE: Format PESHIFT has been output.
NOTE: Format ECGAVAL has been output.
MPRINT(JM_FMT):   RUN;
NOTE: PROCEDURE FORMAT used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: There were 377 observations read from the data set WORK.FORMATS.

MPRINT(JM_FMT):   *** Coy catalog if not in WORK area ***;
SYMBOLGEN:  Macro variable JM_LIB resolves to WORK
MLOGIC(JM_FMT):  %IF condition %upcase("&JM_LIB") ne "WORK" is FALSE
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MLOGIC(JM_FMT):  %IF condition %upcase("&jm_debug") = "Y" or %upcase("&jm_debug") = "YES" is FALSE
MPRINT(JM_FMT):   *** Mark the end of parameter checking ***;
MLOGIC(JM_FMT):  Ending execution.
MPRINT(JM_TLF_PRE):  ;
MPRINT(JM_TLF_PRE):   ***DEFAULTS FOR THE TLFS;
MLOGIC(JM_TLF_PRE):  %GLOBAL   _DEFAULT_TWIPS DEFAULT_FONTSIZE _DEFAULT_BOX _DEFAULT_BOXX _DEFAULT_SPAN_HEAD _DEFAULT_BYVARS
MLOGIC(JM_TLF_PRE):  %LET (variable name is _BIGN_DSN)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _BIGN_TRTVAR)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _BIGN_TRT_FMT)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _DEFAULT_BYVARS)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _COUNT_DSET)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _SUMM_DSET)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _DEFAULT_TWIPS)
MLOGIC(JM_TLF_PRE):  %LET (variable name is DEFAULT_FONTSIZE)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _DEFAULT_SPAN_HEAD)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _DEFAULT_WHERE)
MLOGIC(JM_TLF_PRE):  %LET (variable name is _BIGN_WHERE)
MLOGIC(JM_TLF_PRE):  %LET (variable name is JM_POINTSIZE)
MPRINT(JM_TLF_PRE):   ods escapechar="^";
MPRINT(JM_TLF_PRE):   proc copy in=adam out=work memtype=data;
SYMBOLGEN:  Macro variable DTNAMES resolves to adsl
MLOGIC(JM_TLF_PRE):  %IF condition &dtnames. ne  is TRUE
SYMBOLGEN:  Macro variable DTNAMES resolves to adsl
MPRINT(JM_TLF_PRE):   select adsl;
MPRINT(JM_TLF_PRE):   run;

INFO: COPY with SELECT performance is in use.
NOTE: Copying ADAM.ADSL to WORK.ADSL (memtype=DATA).
INFO: Engine's block-read method is in use.
INFO: Engine's block-write  method is in use.
NOTE: There were 270 observations read from the data set ADAM.ADSL.
                                                           The SAS System

NOTE: The data set WORK.ADSL has 270 observations and 74 variables.
NOTE: PROCEDURE COPY used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TLF_PRE):   data adae;
MPRINT(JM_TLF_PRE):   set adam.adae;
MPRINT(JM_TLF_PRE):   if AEOUT in ("NOT RECOVERED/NOT RESOLVED","RECOVERING/RESOLVING" ) then AE_R1="Y";
MPRINT(JM_TLF_PRE):   if AEOUT in ("NOT RECOVERED/NOT RESOLVED") then AE_R2="Y";
MPRINT(JM_TLF_PRE):   if AEOUT in ("RECOVERING/RESOLVING" ) then AE_R3="Y";
MPRINT(JM_TLF_PRE):   IF MISSING(AEBODSYS) THEN AEBODSYS="NOT CODED AEBODYSYS";
MPRINT(JM_TLF_PRE):   IF MISSING(AEDECOD) THEN AEDECOD="*NOT CODED AEDECOD";
MPRINT(JM_TLF_PRE):   AREL=AEREL;
MPRINT(JM_TLF_PRE):   run;

NOTE: There were 33 observations read from the data set ADAM.ADAE.
NOTE: The data set WORK.ADAE has 33 observations and 107 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TLF_PRE):   proc sql;
MPRINT(JM_TLF_PRE):   **Get max grade with in each subject **;
MPRINT(JM_TLF_PRE):   create table maxgrpt as select distinct usubjid,max(ASEVN) as maxgr_pt from adae group by usubjid;
NOTE: Table WORK.MAXGRPT created, with 18 rows and 2 columns.

MPRINT(JM_TLF_PRE):   **Get max rel ae grade with in each subject **;
MPRINT(JM_TLF_PRE):   create table maxgr_rel as select distinct usubjid,max(ASEVN) as maxgr_rel from adae where upcase(AREL) 
='RELATED' group by usubjid;
NOTE: Table WORK.MAXGR_REL created, with 12 rows and 2 columns.

MPRINT(JM_TLF_PRE):   **Get max grade with in each subject and within each period **;
MPRINT(JM_TLF_PRE):   create table maxgrpt_per as select distinct usubjid,aperiod,max(ASEVN) as maxgrpt_per from adae group by 
usubjid,aperiod;
NOTE: Table WORK.MAXGRPT_PER created, with 20 rows and 3 columns.

MPRINT(JM_TLF_PRE):   **Get max rel ae grade with in each subject **;
MPRINT(JM_TLF_PRE):   create table maxgr_rel_per as select distinct usubjid,aperiod,max(ASEVN) as maxgr_rel_per from adae where 
upcase(AREL) ='RELATED' group by usubjid,aperiod;
                                                           The SAS System

NOTE: Table WORK.MAXGR_REL_PER created, with 12 rows and 3 columns.

MPRINT(JM_TLF_PRE):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TLF_PRE):   data adae;
MPRINT(JM_TLF_PRE):   merge adae maxgrpt maxgr_rel;
MPRINT(JM_TLF_PRE):   by usubjid;
MPRINT(JM_TLF_PRE):   run;

NOTE: There were 33 observations read from the data set WORK.ADAE.
NOTE: There were 18 observations read from the data set WORK.MAXGRPT.
NOTE: There were 12 observations read from the data set WORK.MAXGR_REL.
NOTE: The data set WORK.ADAE has 33 observations and 109 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TLF_PRE):   proc sort data=adae;
MPRINT(JM_TLF_PRE):  by usubjid aperiod;
MPRINT(JM_TLF_PRE):  run;

NOTE: There were 33 observations read from the data set WORK.ADAE.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADAE has 33 observations and 109 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TLF_PRE):   data adae;
MPRINT(JM_TLF_PRE):   merge adae maxgrpt_per maxgr_rel_per;
MPRINT(JM_TLF_PRE):   by usubjid aperiod;
MPRINT(JM_TLF_PRE):   run;

NOTE: There were 33 observations read from the data set WORK.ADAE.
NOTE: There were 20 observations read from the data set WORK.MAXGRPT_PER.
                                                           The SAS System

NOTE: There were 12 observations read from the data set WORK.MAXGR_REL_PER.
NOTE: The data set WORK.ADAE has 33 observations and 111 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TLF_PRE):   data adcm;
MPRINT(JM_TLF_PRE):   set adam.adcm;
MPRINT(JM_TLF_PRE):   length cmtext $2000;
MPRINT(JM_TLF_PRE):   IF MISSING(cmatc4) THEN cmatc4="NOT CODED CM";
MPRINT(JM_TLF_PRE):   IF MISSING(cmdecod) THEN cmdecod="*NOT CODED drugname";
MPRINT(JM_TLF_PRE):   if cmdecod ne '' then cmdecod=tranwrd(cmdecod,';','; ');
MPRINT(JM_TLF_PRE):   cmtext=catx("*",cmatc4,cmdecod);
MPRINT(JM_TLF_PRE):   run;

NOTE: There were 149 observations read from the data set ADAM.ADCM.
NOTE: The data set WORK.ADCM has 149 observations and 99 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_TLF_PRE):  Ending execution.
39         
40               data _null_;
41         
42                tab_box='Body System|Visit, n (%)';
43               *** Create Global macro parameters for _DEFAULT_BOX & _DEFAULT_SPAN_HEAD ***;
44               call symputx("_DEFAULT_BOX",strip(tranwrd(tab_box,'|','|  ')),'g');
45               call symputx("_DEFAULT_BOXX",strip(tranwrd(tab_box,'|','|  ')),'g');
46            run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

47         
48         %let _default_span_head=(("^R'\brdrb\brdrs\brdrw4 ' Treatment Group" trtn1 trtn2 trtn3)  trtn99);
49         
                                                           The SAS System

50         data adsl;*(rename=( trt01an=trtn trt01a=trt));
51               set adam.adsl;
52              where saffl="Y" and trt01an in (1,2,3);
53            trtn = trt01an;
54            trt = trt01a;
55         
56               output;
57              if trt01an in (1,2 ) ;
58               trtn=99;
59               trt='JZP150 Total';
60               output;
61         /*      rename trt01an=trtn trt01a=trt;*/
62            run;

NOTE: There were 48 observations read from the data set ADAM.ADSL.
      WHERE (saffl='Y') and trt01an in (1, 2, 3);
NOTE: The data set WORK.ADSL has 76 observations and 76 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

63         
64         
65         *-----------------------------------------------------------------;
66         *BIGN CALCULATION.;
67         *-----------------------------------------------------------------;
68         *** Calculate the Big N denominator from ADEG by treatment ***;
69            %jm_gen_trt_fmt(jm_indsn=adsl,jm_intrtvar=trt);
MLOGIC:  Beginning compilation of JM_GEN_TRT_FMT using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_gen_trt_fmt.sas.
MLOGIC:  Ending compilation of JM_GEN_TRT_FMT.
MLOGIC(JM_GEN_TRT_FMT):  Beginning execution.
MLOGIC(JM_GEN_TRT_FMT):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_gen_trt_fmt.sas
MLOGIC(JM_GEN_TRT_FMT):  Parameter JM_INDSN has value adsl
MLOGIC(JM_GEN_TRT_FMT):  Parameter JM_INTRTVAR has value trt
MPRINT(JM_GEN_TRT_FMT):   *** 1. Document in log what parameter values were specified. ***;
MPRINT(JM_GEN_TRT_FMT):   data _null_;
MPRINT(JM_GEN_TRT_FMT):   put ' ';
MPRINT(JM_GEN_TRT_FMT):   put "******************* Parameter Values *******************";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to adsl
MPRINT(JM_GEN_TRT_FMT):   PUT "ALERT:I: JM_INDSN PROCESSED - adsl";
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MPRINT(JM_GEN_TRT_FMT):   PUT "ALERT:I: JM_INTRTVAR PROCESSED - trt";
MPRINT(JM_GEN_TRT_FMT):   put "********************************************************";
MPRINT(JM_GEN_TRT_FMT):   put " ";
MPRINT(JM_GEN_TRT_FMT):   put 'NOTE: [JM_GEN_TRT_FMT] is currently running macro %jm_gen_trt_fmt version 1.0.';
MPRINT(JM_GEN_TRT_FMT):   put " ";
MPRINT(JM_GEN_TRT_FMT):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - adsl
ALERT:I: JM_INTRTVAR PROCESSED - trt
********************************************************

NOTE: [JM_GEN_TRT_FMT] is currently running macro %jm_gen_trt_fmt version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_GEN_TRT_FMT):   *** 2. If missing, default the parameters to: jm_indsn=target and jm_intrtvar=trt. ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to adsl
MLOGIC(JM_GEN_TRT_FMT):  %IF condition &jm_indsn. eq  is FALSE
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MLOGIC(JM_GEN_TRT_FMT):  %IF condition &jm_intrtvar. eq  is FALSE
MPRINT(JM_GEN_TRT_FMT):   ****************************************************************************************;
MPRINT(JM_GEN_TRT_FMT):   *** Specification 4: Create TRT and $TRTC Formats for Treatment variables: TRTN, TRT ***;
MPRINT(JM_GEN_TRT_FMT):   ****************************************************************************************;
MPRINT(JM_GEN_TRT_FMT):   *** Create formats for Treatment variables ***;
MPRINT(JM_GEN_TRT_FMT):   *** Check if the TRT, TRTC formats exist in format catalog. if Yes, delete them ***;
MPRINT(JM_GEN_TRT_FMT):   proc format lib=work cntlout=fmtcatlog;
MPRINT(JM_GEN_TRT_FMT):   run;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
NOTE: The data set WORK.FMTCATLOG has 375 observations and 21 variables.

                                                           The SAS System

MPRINT(JM_GEN_TRT_FMT):   proc sql;
MPRINT(JM_GEN_TRT_FMT):   create table trtfmtexist as select * from fmtcatlog where index(upcase(fmtname),'TRT') gt 0;
NOTE: Table WORK.TRTFMTEXIST created, with 0 rows and 21 columns.

MPRINT(JM_GEN_TRT_FMT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_GEN_TRT_FMT):   *** 3. Delete the current WORK area formats TRT and TRTC if it already exists. ***;
MPRINT(JM_GEN_TRT_FMT):   data _null_;
MPRINT(JM_GEN_TRT_FMT):   if symget('sqlobs') > 0 then call symputx('skip',' ');
MPRINT(JM_GEN_TRT_FMT):   else call symputx('skip','*** ');
MPRINT(JM_GEN_TRT_FMT):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      69:227   
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable SKIP resolves to ***
MPRINT(JM_GEN_TRT_FMT):   *** proc catalog c=work.formats;
SYMBOLGEN:  Macro variable SKIP resolves to ***
MPRINT(JM_GEN_TRT_FMT):   *** delete trt/et=format;
SYMBOLGEN:  Macro variable SKIP resolves to ***
MPRINT(JM_GEN_TRT_FMT):   *** delete trtc/et=formatc;
SYMBOLGEN:  Macro variable SKIP resolves to ***
MPRINT(JM_GEN_TRT_FMT):   *** quit;
MPRINT(JM_GEN_TRT_FMT):   *** 4. Create the TRT, $TRTC formats for treatment variables: trtn, trt ***;
MPRINT(JM_GEN_TRT_FMT):   proc sql;
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
SYMBOLGEN:  Macro variable JM_INDSN resolves to adsl
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MPRINT(JM_GEN_TRT_FMT):   create table trtlist as select distinct trtn,trt from adsl where trtn ne . order by trtn;
NOTE: Table WORK.TRTLIST created, with 4 rows and 2 columns.

                                                           The SAS System

MPRINT(JM_GEN_TRT_FMT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_GEN_TRT_FMT):   data trtfmt;
MPRINT(JM_GEN_TRT_FMT):   set trtlist(in=a) trtlist(in=b);
MPRINT(JM_GEN_TRT_FMT):   length fmtname $30 start end label $200;
MPRINT(JM_GEN_TRT_FMT):   if a then do;
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MPRINT(JM_GEN_TRT_FMT):   start=strip(put(trtn,best.));
MPRINT(JM_GEN_TRT_FMT):   end=start;
MPRINT(JM_GEN_TRT_FMT):   fmtname='trt';
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MPRINT(JM_GEN_TRT_FMT):   label=trt;
MPRINT(JM_GEN_TRT_FMT):   type='N';
MPRINT(JM_GEN_TRT_FMT):   HLO='M';
MPRINT(JM_GEN_TRT_FMT):   output;
MPRINT(JM_GEN_TRT_FMT):   end;
MPRINT(JM_GEN_TRT_FMT):   if b then do;
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MPRINT(JM_GEN_TRT_FMT):   start=trt;
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MPRINT(JM_GEN_TRT_FMT):   end=trt;
MPRINT(JM_GEN_TRT_FMT):   fmtname='$trtc';
SYMBOLGEN:  Macro variable JM_INTRTVAR resolves to trt
MPRINT(JM_GEN_TRT_FMT):   label=strip(put(trtn,best.));
MPRINT(JM_GEN_TRT_FMT):   type='C';
MPRINT(JM_GEN_TRT_FMT):   hlo='';
MPRINT(JM_GEN_TRT_FMT):   output;
MPRINT(JM_GEN_TRT_FMT):   end;
MPRINT(JM_GEN_TRT_FMT):   keep start end fmtname label type hlo;
MPRINT(JM_GEN_TRT_FMT):   run;

NOTE: There were 4 observations read from the data set WORK.TRTLIST.
NOTE: There were 4 observations read from the data set WORK.TRTLIST.
NOTE: The data set WORK.TRTFMT has 8 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_GEN_TRT_FMT):   proc format cntlin=trtfmt;
NOTE: Format TRT has been output.
NOTE: Format $TRTC has been output.
MPRINT(JM_GEN_TRT_FMT):   run;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
NOTE: There were 8 observations read from the data set WORK.TRTFMT.

MLOGIC(JM_GEN_TRT_FMT):  Ending execution.
70         
71         %JM_BIGN(JM_INDSN=ADSL,jm_suffix=1, jm_trtvarn=trtn, jm_trtfmt=trt );
MLOGIC:  Beginning compilation of JM_BIGN using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_bign.sas.
MLOGIC:  Ending compilation of JM_BIGN.
MLOGIC(JM_BIGN):  Beginning execution.
MLOGIC(JM_BIGN):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_bign.sas
MLOGIC(JM_BIGN):  Parameter JM_INDSN has value ADSL
MLOGIC(JM_BIGN):  Parameter JM_SUFFIX has value 1
MLOGIC(JM_BIGN):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_BIGN):  Parameter JM_TRTFMT has value trt
MLOGIC(JM_BIGN):  Parameter JM_CNTVAR has value usubjid
MLOGIC(JM_BIGN):  Parameter JM_TRTVAR has value 
MLOGIC(JM_BIGN):  Parameter JM_BIGN_WHERE has value 
MLOGIC(JM_BIGN):  Parameter JM_DEBUG has value N
MLOGIC(JM_BIGN):  Parameter JM_SUBGRP has value 
MLOGIC(JM_BIGN):  Parameter JM_VERSION has value 1.0
MPRINT(JM_BIGN):   *** Handle case where JM_BIGN_WHERE contains double quotes ***;
MPRINT(JM_BIGN):   data _null_;
MPRINT(JM_BIGN):   length curwhere $400;
MPRINT(JM_BIGN):   curwhere = symget('JM_BIGN_WHERE');
MPRINT(JM_BIGN):   if index(curwhere,'"') > 0 then do;
MPRINT(JM_BIGN):   curwhere=strip(tranwrd(curwhere,'"',"'"));
MPRINT(JM_BIGN):   call symputx('JM_BIGN_WHERE',curwhere);
MPRINT(JM_BIGN):   end;
MPRINT(JM_BIGN):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   *** Document in log what parameter value specified ***;
MPRINT(JM_BIGN):   data _null_;
MPRINT(JM_BIGN):   put ' ';
MPRINT(JM_BIGN):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADSL
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_INDSN PROCESSED - ADSL";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_CNTVAR PROCESSED - usubjid";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_TRTFMT PROCESSED - trt";
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_BIGN_WHERE PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_SUFFIX PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_SUBGRP PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_BIGN):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
MPRINT(JM_BIGN):   put "********************************************************";
MPRINT(JM_BIGN):   put " ";
MPRINT(JM_BIGN):   put 'NOTE: [JM_BIGN] is currently running macro %jm_bign version 1.0.';
MPRINT(JM_BIGN):   put " ";
MPRINT(JM_BIGN):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADSL
ALERT:I: JM_CNTVAR PROCESSED - usubjid
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_TRTFMT PROCESSED - trt
                                                           The SAS System

ALERT:I: JM_BIGN_WHERE PROCESSED - 
ALERT:I: JM_SUFFIX PROCESSED - 1
ALERT:I: JM_SUBGRP PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
********************************************************

NOTE: [JM_BIGN] is currently running macro %jm_bign version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   *** Verify if jm_debug is valid ***;
MLOGIC(JM_BIGN):  %LET (variable name is _ERR)
MPRINT(JM_BIGN):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_BIGN):   debug=upcase(strip("N"));
MPRINT(JM_BIGN):   if debug not in("N","Y") then do;
MPRINT(JM_BIGN):   put ' ';
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_BIGN):   put "ER" "ROR:[jm_bign] An invalid character has specified to the parameter JM_DEBUG=N. " 'Only "Y" or "N" are 
permitted. Please specify proper JM_DEBUG.';
MPRINT(JM_BIGN):   call symput('_err','yes');
MPRINT(JM_BIGN):   end;
MPRINT(JM_BIGN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_BIGN):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_BIGN):   *** Verify If both JM_TRTFMT and JM_TRTVAR are not specified ***;
MPRINT(JM_BIGN):   data _null_;
SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_BIGN):   if compress("trt") = '' and compress("") = '' then do;
MPRINT(JM_BIGN):   put ' ';
MPRINT(JM_BIGN):   put 'ER' "ROR:[jm_bign] Please specify either macro parameter JM_TRTFMT or JM_TRTVAR. ";
                                                           The SAS System

MPRINT(JM_BIGN):   put ' ';
MPRINT(JM_BIGN):   call symput('_err','yes');
MPRINT(JM_BIGN):   end;
MPRINT(JM_BIGN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_BIGN):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_BIGN):   *** Apply debugging er ror checking if specified ***;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MLOGIC(JM_BIGN):  %IF condition %upcase("&jm_debug") = "Y" or %upcase("&jm_debug") = "YES" is FALSE
MPRINT(JM_BIGN):   *** Verify if user has defined $TRTC corresponding to format TRT ***;
MPRINT(JM_BIGN):   PROC FORMAT library=work.formats cntlout=v_trtfmt2;
MPRINT(JM_BIGN):   RUN;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: The data set WORK.V_TRTFMT2 has 383 observations and 21 variables.

MLOGIC(JM_BIGN):  %LET (variable name is TRTC_EXIST)
MPRINT(JM_BIGN):   data _null_;
MPRINT(JM_BIGN):   set v_trtfmt2;
MPRINT(JM_BIGN):   if upcase(strip(fmtname)) = 'TRTC' then call symput('trtc_exist','yes');
MPRINT(JM_BIGN):   run;

NOTE: There were 383 observations read from the data set WORK.V_TRTFMT2.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable TRTC_EXIST resolves to yes
MLOGIC(JM_BIGN):  %IF condition "&trtc_exist" = "no" is FALSE
MPRINT(JM_BIGN):   proc sql;
                                                           The SAS System

MPRINT(JM_BIGN):   drop table v_trtfmt2;
NOTE: Table WORK.V_TRTFMT2 has been dropped.
MPRINT(JM_BIGN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_BIGN):   *** Continue logic to retain original variable o_trtvar and use it in next step rather than using $format ... 
***;
MPRINT(JM_BIGN):   *** Create a work area dataset from the input dataset ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADSL
MPRINT(JM_BIGN):   data BIGNADSL;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADSL
MPRINT(JM_BIGN):   set ADSL;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_BIGN):   TRTVAR= trtn;
MPRINT(JM_BIGN):   _count=1;
MPRINT(JM_BIGN):   *** Apply the format if it is specified ***;
SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
MLOGIC(JM_BIGN):  %IF condition "&jm_trtfmt" ne "" is TRUE
MPRINT(JM_BIGN):   *** Hold onto the origignal unformated variable ***;
MPRINT(JM_BIGN):   format trtvar;
MPRINT(JM_BIGN):   o_trtvar = trtvar;
MPRINT(JM_BIGN):   *** Apply the format ***;
SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
MPRINT(JM_BIGN):   format TRTVAR trt.;
MPRINT(JM_BIGN):   run;

NOTE: There were 76 observations read from the data set WORK.ADSL.
NOTE: The data set WORK.BIGNADSL has 76 observations and 79 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   *** Sort and subset the dataset and retain only unique rows ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADSL
MPRINT(JM_BIGN):   PROC SORT DATA=BIGNADSL NODUPKEY;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
                                                           The SAS System

MPRINT(JM_BIGN):   BY usubjid TRTVAR;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_BIGN):  %IF condition &JM_BIGN_WHERE ^= is FALSE
MPRINT(JM_BIGN):   RUN;

NOTE: There were 76 observations read from the data set WORK.BIGNADSL.
NOTE: SAS sort was used.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.BIGNADSL has 76 observations and 79 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   *** Identify the number of records based upon unique rows ***;
MLOGIC(JM_BIGN):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADSL
MLOGIC(JM_BIGN):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_BIGN):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_BIGN):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_BIGN):   *** Only summarize if the dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 76
MLOGIC(JM_BIGN):  %IF condition &NOBS > 0 is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_BIGN):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_BIGN):   *** Calculate simple statistics from the input dataset ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADSL
MPRINT(JM_BIGN):   PROC MEANS DATA = BIGNADSL completetypes nway NOPRINT;
MPRINT(JM_BIGN):   CLASS TRTVAR /MLF preloadfmt;
MPRINT(JM_BIGN):   VAR _count;
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   OUTPUT OUT = JM_BIGN1 (drop=_ :) N=count;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_BIGN):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_BIGN):   RUN;

NOTE: Multiple concurrent threads will be used to summarize data.
NOTE: There were 76 observations read from the data set WORK.BIGNADSL.
                                                           The SAS System

NOTE: The data set WORK.JM_BIGN1 has 4 observations and 2 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_BIGN):   *** Verify if formats are valid ***;
MPRINT(JM_BIGN):   PROC FORMAT library=work.formats cntlout=v_trtfmt2 ;
MPRINT(JM_BIGN):   RUN;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: The data set WORK.V_TRTFMT2 has 383 observations and 21 variables.

MPRINT(JM_BIGN):   data v_trtfmt3 (keep = trtvar);
MPRINT(JM_BIGN):   set v_trtfmt2;
MPRINT(JM_BIGN):   where upcase(fmtname)='TRTC';
MPRINT(JM_BIGN):   length trtvar $40;
MPRINT(JM_BIGN):   trtvar = start;
MPRINT(JM_BIGN):   run;

NOTE: There were 4 observations read from the data set WORK.V_TRTFMT2.
      WHERE UPCASE(fmtname)='TRTC';
NOTE: The data set WORK.V_TRTFMT3 has 4 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   proc sort data = v_trtfmt3;
MPRINT(JM_BIGN):   by trtvar;
MPRINT(JM_BIGN):   run;

NOTE: There were 4 observations read from the data set WORK.V_TRTFMT3.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_TRTFMT3 has 4 observations and 1 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   proc sort data = JM_BIGN1 out= v_trtfmt4;
MPRINT(JM_BIGN):   by trtvar;
MPRINT(JM_BIGN):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_TRTFMT4 has 4 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   data _null_;
MPRINT(JM_BIGN):   length trtvar $200;
MPRINT(JM_BIGN):   merge v_trtfmt4 (in=A) v_trtfmt3 (in=B);
MPRINT(JM_BIGN):   by trtvar;
MPRINT(JM_BIGN):   if (A) and not(B) then do;
MPRINT(JM_BIGN):   put ' ';
MPRINT(JM_BIGN):   put "WAR" "NING:[jm_bign] contains a value '" trtvar +(-1) "' for the TRTVAR " "variable but is not found in 
$TRTC format.";
MPRINT(JM_BIGN):   put ' ';
MPRINT(JM_BIGN):   end;
MPRINT(JM_BIGN):   run;

NOTE: There were 4 observations read from the data set WORK.V_TRTFMT4.
NOTE: There were 4 observations read from the data set WORK.V_TRTFMT3.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_BIGN):   *** Summarize the N counts and update it into SAS format ***;
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   DATA JM_BIGN1;
MPRINT(JM_BIGN):   *** Create grouping by variable if specified ***;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_BIGN):  %IF condition &JM_TRTVAR ^= is FALSE
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
                                                           The SAS System

MPRINT(JM_BIGN):   SET JM_BIGN1;
MPRINT(JM_BIGN):   *** if index(trtvar,'|') > 0 then do;
MPRINT(JM_BIGN):   *** TRTVARN=input(put(trim(substr(TRTVAR,1,index(trtvar,'|')-1)), $TRTC.),best.);
MPRINT(JM_BIGN):   *** end;
MPRINT(JM_BIGN):   TRTVARN=input(put(TRTVAR, $TRTC.),best.);
MPRINT(JM_BIGN):   format trtvarn;
SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
MLOGIC(JM_BIGN):  %IF condition "&jm_trtfmt" = "" is FALSE
MPRINT(JM_BIGN):   START=TRTVARN;
MPRINT(JM_BIGN):   LABEL=STRIP(TRTVAR)||" |(N="||TRIM(LEFT(PUT(COUNT,BEST.)))||")";
MPRINT(JM_BIGN):   END= TRTVARN;
MPRINT(JM_BIGN):   *** Hold on to the N counts and name it BIGN ***;
MPRINT(JM_BIGN):   *** FMTNAME="&JM_TRTFMT";
MPRINT(JM_BIGN):   FMTNAME="BIGNTRTF";
MPRINT(JM_BIGN):   RENAME COUNT=BIGN;
MPRINT(JM_BIGN):   *** Update the format names if there are multiple Sub Groups ***;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_BIGN):  %IF condition "&JM_SUBGRP" ne "" is FALSE
MPRINT(JM_BIGN):   *** Assign grouping by variable if specified ***;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
MLOGIC(JM_BIGN):  %IF condition &JM_TRTVAR ^= and &JM_TRTFMT ^= is FALSE
MPRINT(JM_BIGN):   *** Hold onto original jm_trtvarn ***;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_BIGN):   trtn = trtvarn;
MPRINT(JM_BIGN):   RUN;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: The data set WORK.JM_BIGN1 has 4 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_BIGN):  %GLOBAL  TRTLAB0 TRTLAB1 TRTLAB2 TRTLAB3 TRTLAB4 TRTLAB5 TRTLAB99
MPRINT(JM_BIGN):   data v_jm_bign;
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   set JM_BIGN1 ;
MPRINT(JM_BIGN):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
                                                           The SAS System

NOTE: The data set WORK.V_JM_BIGN has 4 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
MLOGIC(JM_BIGN):  %IF condition "&jm_trtfmt" ne "" is TRUE
MPRINT(JM_BIGN):   *** Apply the format based upon the dataset upon the SAS format ***;
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   PROC FORMAT CNTLIN=JM_BIGN1;
NOTE: Format BIGNTRTF has been output.
MPRINT(JM_BIGN):   RUN;
NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.

MPRINT(JM_BIGN):   *** Update the variable for standard naming for JM_ ***;
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   data JM_BIGN1;
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   set JM_BIGN1;
MPRINT(JM_BIGN):   *** Update the label when no format is applied ***;
SYMBOLGEN:  Macro variable JM_TRTFMT resolves to trt
MPRINT(JM_BIGN):   if "trt" = "" then do;
MPRINT(JM_BIGN):   *** if "&JM_TRTVAR" ne '' then label = &JM_TRTVAR;
MPRINT(JM_BIGN):   end;
MPRINT(JM_BIGN):   rename bign = JM_AVAL_BIGN;
MPRINT(JM_BIGN):   rename start = JM_AVAL_START;
MPRINT(JM_BIGN):   rename fmtname = JM_AVAL_FMTNAME;
MPRINT(JM_BIGN):   rename label = JM_AVAL_BIGN_LABEL;
MPRINT(JM_BIGN):   rename trtvarn=JM_TRTVARN;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_BIGN):  %IF condition &JM_BIGN_WHERE ^= is FALSE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_BIGN):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_BIGN):   drop end ;
MPRINT(JM_BIGN):   run;
                                                           The SAS System


NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: The data set WORK.JM_BIGN1 has 4 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   *** Retain the original JM_TRTVAR if specified ***;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_BIGN):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_BIGN):   *** Create macro variables if specified ***;
MPRINT(JM_BIGN):   data _null_;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_BIGN):   if "trtn" ne '' then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_BIGN):   call symputx('JM_TRTVARN',"trtn");
MPRINT(JM_BIGN):   end;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_BIGN):   if "" ne '' then do;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_BIGN):   call symputx('JM_TRTVAR',"");
MPRINT(JM_BIGN):   end;
MPRINT(JM_BIGN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   *** Clean up intermediate dataset after processing BIGN ***;
MPRINT(JM_BIGN):   proc sql;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADSL
MPRINT(JM_BIGN):   drop table BIGNADSL;
NOTE: Table WORK.BIGNADSL has been dropped.
MPRINT(JM_BIGN):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_BIGN):   *** Apply debugging er ror checking if specified ***;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MLOGIC(JM_BIGN):  %IF condition %upcase("&jm_debug") = "Y" or %upcase("&jm_debug") = "YES" is FALSE
MPRINT(JM_BIGN):   *** Verify if dataset is created ***;
MPRINT(JM_BIGN):   data _null_;
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   if exist("JM_BIGN1") then do;
MPRINT(JM_BIGN):   put ' ';
SYMBOLGEN:  Macro variable JM_SUFFIX resolves to 1
MPRINT(JM_BIGN):   put "NOTE: [jm_bign] Macro: JM_BIGN - Version 1.0 Executed successfully and Produced JM_BIGN1 dataset.";
MPRINT(JM_BIGN):   end;
MPRINT(JM_BIGN):   run;


NOTE: [jm_bign] Macro: JM_BIGN - Version 1.0 Executed successfully and Produced JM_BIGN1 dataset.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_BIGN):   *** Mark the end of parameter checking ***;
MLOGIC(JM_BIGN):  Ending execution.
72         
73         data ADEG;
74          set adam.ADEG ;
75          if SAFFL="Y" and  avisitn in (0,1,4,8,12) and paramn  in (301,302,303,304,305,306,401,106,201) and ANL01FL="Y" ;
76         
77         trtn=trtan;
78         trt=trta;
79         
80         if paramn=106 then do;
81         if index(upcase(AVALC),"NORMAL SINUS RHYTHM")>=1 then AVALN=1;
82         if index(upcase(AVALC),"SINUS ARRHYTHMIA")>=1    then AVALN=2;
83         if index(upcase(AVALC),"SINUS TACHYCARDIA")>=1   then AVALN=3;
84         if index(upcase(AVALC),"SINUS BRADYCARDIA")>=1   then AVALN=4;
85         end;
86         
87         if paramn=201 then do;
88         if index(upcase(AVALC),"ABNORMAL")>=1 then AVALC="ABNORMAL";
89         if index(upcase(AVALC),"NORMAL")>=1   then AVALN=5;
                                                           The SAS System

90         if index(upcase(AVALC),"ABNORMAL")>=1 then AVALN=6;
91         if index(upcase(AVALC),"NOT EVALUABLE")>=1 then AVALN=7;
92         end;
93         
94           output;
95              if trtan in (1,2 ) ;
96               trtn=99;
97               trt='JZP150 Total';
98               output;
99         
100        run;

NOTE: There were 14122 observations read from the data set ADAM.ADEG.
NOTE: The data set WORK.ADEG has 4360 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.04 seconds
      

101        
102        
103        **Create Dummy - all subjects from ADSL, with all parameters and all visits in ADEG**;
104        proc sql;
105          create table dummyparm as
106          select a.*,b.*
107          from (select distinct paramcd, param,paramn from adeg where paramcd ne '') as a,
108              (select distinct avisitn,avisit from adeg where avisit ne '') as b;
NOTE: The execution of this query involves performing one or more Cartesian product joins that can not be optimized.
NOTE: SAS threaded sort was used.
NOTE: Table WORK.DUMMYPARM created, with 45 rows and 5 columns.

109          create table dummyadsl as
110          select a.*,b.*
111          from adsl as a, dummyparm as b
112          order by a.usubjid,b.paramn,b.param,b.avisitn;
NOTE: The execution of this query involves performing one or more Cartesian product joins that can not be optimized.
NOTE: SAS threaded sort was used.
NOTE: Table WORK.DUMMYADSL created, with 3420 rows and 81 columns.

113        quit;
NOTE: PROCEDURE SQL used (Total process time):
                                                           The SAS System

      real time           0.04 seconds
      cpu time            0.04 seconds
      

114        proc sort data=dummyparm;
115        by paramn;
116        run;

NOTE: There were 45 observations read from the data set WORK.DUMMYPARM.
NOTE: SAS sort was used.
NOTE: The data set WORK.DUMMYPARM has 45 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

117        
118        
119        proc freq data=ADEG;
120        table avisitn*avisit*paramn*param/out=paramn_fr nocol nopct;
121        where avalc ne "" and aval eq .;
122        
123        run;

NOTE: There were 2379 observations read from the data set WORK.ADEG.
      WHERE (avalc not = ' ') and (aval=.);
NOTE: The data set WORK.PARAMN_FR has 10 observations and 6 variables.
NOTE: The PROCEDURE FREQ printed pages 1-13.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

124        
125        
126        data ADEG_S;
127        set ADEG;
128        *if paramn not in (1,11,12,13,14,15,16);
129        
130        run;

                                                           The SAS System

NOTE: There were 4360 observations read from the data set WORK.ADEG.
NOTE: The data set WORK.ADEG_S has 4360 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

131        
132        proc sort data=ADEG out=ADEG_F;
133        by usubjid trtn paramn param   avisitn avisit avalc adt  ;
134        run;

NOTE: There were 4360 observations read from the data set WORK.ADEG.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADEG_F has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

135        
136        data ADEG_F;
137        set ADEG_F;
138        by usubjid trtn paramn param   avisitn avisit avalc adt  ;
139        *if paramn  in (1,11,12,13,14,15,16);
140        if last.avalc;
141        
142        run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_F.
NOTE: The data set WORK.ADEG_F has 2658 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

143        
144        
145        *------------------------------------------------------------------------------------------------------------------------
145      ! ----------;
146        * CALL SUMMARYSTAT FOR DESCRIPTIVE AND COUNTF FOR THE CATEGORICAL IN THE ORDER OF TABLE SHELL AND INCREMENT BLOCK NUMBERS
                                                           The SAS System

146      ! ;
147        *------------------------------------------------------------------------------------------------------------------------
147      ! ----------;
148        
149        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=aval, jm_bign=, jm_trtvarn=trtn, JM_SECONDARY_WHERE= AVISITN=0 and ABLFL="Y",
149      ! JM_AVAL_LABEL=%bquote(Baseline),
MLOGIC:  Beginning compilation of JM_AVAL_SUM using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas.
MLOGIC:  Ending compilation of JM_AVAL_SUM.
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
150         JM_BYVAR=  avisitn avisit PARAMN paramcd param , JM_BLOCK=101,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value aval
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN=0 and ABLFL="Y"
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value Baseline
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 101
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN=0 and ABLFL="Y"
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN=0 and ABLFL="Y"";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_VAR resolves to aval
NOTE: Line generated by the macro variable "JM_SECONDARY_WHERE".
150         "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN=0 and ABLFL="Y"
            ______________________________________________________________
            49
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Baseline
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - Baseline";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 101";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;

NOTE 49-169: The meaning of an identifier after a quoted string might change in a future SAS release.  Inserting white space 
             between a quoted string and the succeeding identifier is recommended.
                                                           The SAS System


NOTE: Variable Y is uninitialized.

******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN=0 and ABLFL=  "
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_AVAL_LABEL PROCESSED - Baseline
ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 101
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if compress("aval") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   if compress("101") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='aval' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("avisitn avisit PARAMN paramcd param"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=avisitn avisit PARAMN paramcd param " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   data e_byvar (keep=avisitn avisit PARAMN paramcd param datablock);
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   length datablock $100;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   datablock = "JM_AVAL_SUM101";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: The data set WORK.E_BYVAR has 4360 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("avisitn avisit PARAMN paramcd param"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("avisitn avisit PARAMN paramcd param"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
                                                           The SAS System

JM_TRTVARN/ avisitn avisit PARAMN paramcd param combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 1 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 1
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 1; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Baseline
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 0 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 1
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 1; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_BIGN1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Baseline
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_BIGN1
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Baseline', which already " "exists in dataset(s) [JM_BIGN1]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Analysis Value
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Baseline
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   v_block = input("101",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='101' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   if compress("101") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM101") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
                                                           The SAS System

JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=101, which already " "exists in dataset(s) [JM_AVAL_SUM101]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT101") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=101, which already " "exists in dataset(s) [JM_AVAL_SUM101]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      150:64    150:137   150:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      150:206   
NOTE: There were 4360 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA1 has 4360 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN=0 and ABLFL="Y"
NOTE: Line generated by the macro variable "JM_SECONDARY_WHERE".
150        "AVISITN=0 and ABLFL="Y"
           ______________________
           49
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN=0 and ABLFL="Y"
MPRINT(JM_AVAL_SUM):   where AVISITN=0 and ABLFL="Y";
MPRINT(JM_AVAL_SUM):   run;

NOTE 49-169: The meaning of an identifier after a quoted string might change in a future SAS release.  Inserting white space 
             between a quoted string and the succeeding identifier is recommended.

NOTE: There were 399 observations read from the data set WORK.ADEG_S.
      WHERE (AVISITN=0) and (ABLFL='Y');
NOTE: The data set WORK.V_EMPTY has 399 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 399
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   jm_block = "101";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID aval trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
                                                           The SAS System

      real time           0.02 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN=0 and ABLFL="Y"
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
NOTE: Line generated by the macro variable "JM_SECONDARY_WHERE".
150        "AVISITN=0 and ABLFL="Y"
           ______________________
           49
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN=0 and ABLFL="Y"
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if AVISITN=0 and ABLFL="Y" then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE 49-169: The meaning of an identifier after a quoted string might change in a future SAS release.  Inserting white space 
             between a quoted string and the succeeding identifier is recommended.

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 399 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   by avisitn avisit PARAMN paramcd param;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   if index("101",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("101",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      150:159  jm_block
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID avisitn avisit PARAMN paramcd param trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 399 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 399 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("aval") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 399
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY avisitn avisit PARAMN paramcd param trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 399 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 399 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY avisitn avisit PARAMN paramcd param trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   class aval;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   var aval;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 399 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 409 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Baseline
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      150:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Baseline
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("Baseline");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("101");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: There were 409 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 28 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   curvar = put(aval,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_AVAL_SUM):  Beginning compilation of JM_PREC_DECM using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_prec_decm.sas.
MLOGIC(JM_AVAL_SUM):  Ending compilation of JM_PREC_DECM.
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value aval
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 101
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 101";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param
ALERT:I: JM_BLOCK PROCESSED - 101
                                                           The SAS System

********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   if compress("aval") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   if compress("101") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   check=input("101",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '101' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'aval'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("avisitn avisit PARAMN 
paramcd param") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum101") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

                                                           The SAS System

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   data jm_aval_sum101;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
                                                           The SAS System

MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      150:200   150:31    150:133   150:216   150:70    150:151   150:228   150:57    150:132   150:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM101 has 28 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum101") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   data jm_aval_sum101;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_PREC_DECM):   set jm_aval_sum101;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: The data set WORK.JM_AVAL_SUM101 has 28 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
MPRINT(JM_AVAL_SUM):   data jm_aval_sum101;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 101
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   set jm_aval_sum101;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   drop aval;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Baseline
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "Baseline";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: The data set WORK.JM_AVAL_SUM101 has 28 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if aval ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 399 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   by avisitn avisit PARAMN paramcd param;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
151        
152        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=aval, jm_bign=, jm_trtvarn=trtn, JM_SECONDARY_WHERE= AVISITN =1 ,
152      ! JM_AVAL_LABEL=%bquote(End of Week 1),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
153         JM_BYVAR=   PARAMN paramcd param avisitn avisit, JM_BLOCK=102,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value aval
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN =1
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value End of Week 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 102
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =1";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 1";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 102";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =1
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 1
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 102
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if compress("aval") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   if compress("102") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='aval' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=PARAMN paramcd param avisitn avisit " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 4360 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 4360 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.E_BYVAR.
                                                           The SAS System

NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 8720 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=PARAMN paramcd param avisitn avisit should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=PARAMN paramcd param avisitn avisit, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("PARAMN paramcd param avisitn avisit"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ PARAMN paramcd param avisitn avisit combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;
                                                           The SAS System


NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 2 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 2
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 2; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
                                                           The SAS System

SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: SAS threaded sort was used.
NOTE: There were 1 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 1
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 1; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 1" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
                                                           The SAS System

SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 1', which already " "exists in dataset(s) 
[JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Analysis Value
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   v_block = input("102",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='102' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   if compress("102") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM102") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=102, which already " "exists in dataset(s) [JM_AVAL_SUM102]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT102") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=102, which already " "exists in dataset(s) [JM_AVAL_SUM102]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      153:64    153:137   153:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
                                                           The SAS System

      153:206   
NOTE: There were 8720 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA2 has 8720 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MPRINT(JM_AVAL_SUM):   where AVISITN =1;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 1169 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=1;
NOTE: The data set WORK.V_EMPTY has 1169 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 1169
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   jm_block = "102";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID aval trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MPRINT(JM_AVAL_SUM):   if AVISITN =1 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 1169 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   if index("102",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("102",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
                                                           The SAS System

      153:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID PARAMN paramcd param avisitn avisit trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 1169 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 505 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 664 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("aval") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 664
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 664 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 664 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   class aval;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   var aval;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 664 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 533 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      153:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("End of Week 1");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("102");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;
                                                           The SAS System


NOTE: There were 533 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   curvar = put(aval,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value aval
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 102
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 102";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BLOCK PROCESSED - 102
********************************************************
                                                           The SAS System

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   if compress("aval") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   if compress("102") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   check=input("102",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '102' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'aval'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("PARAMN paramcd param 
avisitn avisit") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum102") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   data jm_aval_sum102;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      153:200   153:31    153:133   153:216   153:70    153:151   153:228   153:57    153:132   153:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      8 at 153:36    8 at 153:112   8 at 153:233   8 at 153:65    8 at 153:145   8 at 153:225   8 at 153:51    8 at 153:131
      8 at 153:249   8 at 153:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM102 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum102") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   data jm_aval_sum102;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_PREC_DECM):   set jm_aval_sum102;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: The data set WORK.JM_AVAL_SUM102 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data jm_aval_sum102;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 102
MPRINT(JM_AVAL_SUM):   set jm_aval_sum102;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   drop aval;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "End of Week 1";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: The data set WORK.JM_AVAL_SUM102 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if aval ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 664 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
154        
155        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=chg, jm_bign=, jm_trtvarn=trtn,  JM_SECONDARY_WHERE= AVISITN =1 ,
155      ! JM_AVAL_LABEL=%bquote(Change from Baseline to End of Week 1),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
156         JM_BYVAR=  avisitn avisit PARAMN paramcd param , JM_BLOCK=103,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value chg
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN =1
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value Change from Baseline to End of Week 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 103
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =1";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 1";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 103";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =1
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 1
ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 103
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if compress("chg") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   if compress("103") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='chg' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("avisitn avisit PARAMN paramcd param"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=avisitn avisit PARAMN paramcd param " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   by avisitn avisit PARAMN paramcd param;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 8720 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 8720 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.05 seconds
                                                           The SAS System

      cpu time            0.06 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   by avisitn avisit PARAMN paramcd param;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   by avisitn avisit PARAMN paramcd param;
MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: The variable STUDYID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable USUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SITEID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COUNTRY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BRTHDTC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEU on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable SEX on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEXN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RACE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNIC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNICN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SAFFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ENRLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PKFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RANDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SCRFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable MFASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable FASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMPSFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PTSDHFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRISN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRIS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ASEQ on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTPN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTA on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTAN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTSDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTEDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP04FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP12FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREFID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSPID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGPOS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGORRES on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTRESC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTAT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREASND on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGNAM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGMETHOD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLEAD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGEVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLOBXFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITNUM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable VISIT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ATM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADTM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable DTYPE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ABLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BASE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PCHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL01FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL02FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL03FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trtn on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trt on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 8720 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: There were 8720 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 13080 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=avisitn avisit PARAMN paramcd param should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=avisitn avisit PARAMN paramcd param, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("avisitn avisit PARAMN paramcd param"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("avisitn avisit PARAMN paramcd param"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ avisitn avisit PARAMN paramcd param combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 3 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 3
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 3; by value is 1.  
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 2 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 2
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 2; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 1" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 1', which already " "exists in 
dataset(s) [JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 1" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 1', which already " "exists in 
dataset(s) [JM_AVAL_SUM102]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Change from Baseline
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   v_block = input("103",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='103' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   if compress("103") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM103") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=103, which already " "exists in dataset(s) [JM_AVAL_SUM103]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT103") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=103, which already " "exists in dataset(s) [JM_AVAL_SUM103]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      156:64    156:137   156:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      156:206   
NOTE: There were 13080 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA3 has 13080 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MPRINT(JM_AVAL_SUM):   where AVISITN =1;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 1169 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=1;
NOTE: The data set WORK.V_EMPTY has 1169 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 1169
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   jm_block = "103";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID chg trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =1
MPRINT(JM_AVAL_SUM):   if AVISITN =1 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 1169 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   by avisitn avisit PARAMN paramcd param;
MPRINT(JM_AVAL_SUM):   run;
                                                           The SAS System


NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   if index("103",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("103",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      156:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID avisitn avisit PARAMN paramcd param trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;
                                                           The SAS System


NOTE: There were 1169 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 505 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 664 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("chg") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 664
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY avisitn avisit PARAMN paramcd param trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 664 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 664 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY avisitn avisit PARAMN paramcd param trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   class chg;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   var chg;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 664 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 515 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      156:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("Change from Baseline to End of Week 1");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("103");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 515 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   curvar = put(chg,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value chg
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 103
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
                                                           The SAS System

MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 103";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - avisitn avisit PARAMN paramcd param
ALERT:I: JM_BLOCK PROCESSED - 103
********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   if compress("chg") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   if compress("103") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   check=input("103",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '103' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'chg'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;
                                                           The SAS System


NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("avisitn avisit PARAMN 
paramcd param") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum103") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   data jm_aval_sum103;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
                                                           The SAS System

MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      156:200   156:31    156:133   156:216   156:70    156:151   156:228   156:57    156:132   156:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
                                                           The SAS System

      Each place is given by: (Number of times) at (Line):(Column).
      8 at 156:36    8 at 156:112   8 at 156:233   8 at 156:65    8 at 156:145   8 at 156:225   8 at 156:51    8 at 156:131
      8 at 156:249   8 at 156:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM103 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum103") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   data jm_aval_sum103;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_PREC_DECM):   set jm_aval_sum103;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: The data set WORK.JM_AVAL_SUM103 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   data jm_aval_sum103;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 103
MPRINT(JM_AVAL_SUM):   set jm_aval_sum103;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   drop chg;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 1
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "Change from Baseline to End of Week 1";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: The data set WORK.JM_AVAL_SUM103 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if chg ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 664 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to avisitn avisit PARAMN paramcd param
MPRINT(JM_AVAL_SUM):   by avisitn avisit PARAMN paramcd param;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
                                                           The SAS System

      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
157        
158        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=aval, jm_bign=, jm_trtvarn=trtn, JM_SECONDARY_WHERE= AVISITN =4 ,
158      ! JM_AVAL_LABEL=%bquote(End of Week 4),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
159        JM_BYVAR=   PARAMN paramcd param avisitn avisit, JM_BLOCK=104,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value aval
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN =4
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value End of Week 4
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 104
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =4";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 4";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 104";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =4
                                                           The SAS System

ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 4
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 104
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
                                                           The SAS System

JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if compress("aval") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   if compress("104") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='aval' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=PARAMN paramcd param avisitn avisit " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 13080 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 13080 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: The variable STUDYID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable USUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SITEID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COUNTRY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BRTHDTC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEU on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEX on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEXN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RACE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNIC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNICN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SAFFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ENRLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PKFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RANDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SCRFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable MFASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable FASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMPSFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PTSDHFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRISN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRIS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ASEQ on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable TRTPN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTA on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTAN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTSDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTEDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP04FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP12FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREFID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSPID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGPOS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGORRES on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTRESC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTAT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREASND on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGNAM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGMETHOD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLEAD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGEVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLOBXFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITNUM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISIT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ATM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADTM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable DTYPE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ABLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BASE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PCHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable CHGCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL01FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL02FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL03FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trtn on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trt on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 13080 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 13080 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 17440 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.07 seconds
      

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=PARAMN paramcd param avisitn avisit should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=PARAMN paramcd param avisitn avisit, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("PARAMN paramcd param avisitn avisit"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ PARAMN paramcd param avisitn avisit combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 4 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 4
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 4; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 3 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 3
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 3; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 4" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 4', which already " "exists in dataset(s) 
[JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 4" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 4', which already " "exists in dataset(s) 
[JM_AVAL_SUM102]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
                                                           The SAS System

SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 4" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 4', which already " "exists in dataset(s) 
[JM_AVAL_SUM103]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Analysis Value
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
                                                           The SAS System

SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   v_block = input("104",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='104' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   if compress("104") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM104") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=104, which already " "exists in dataset(s) [JM_AVAL_SUM104]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT104") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=104, which already " "exists in dataset(s) [JM_AVAL_SUM104]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      159:64    159:137   159:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      159:206   
NOTE: There were 17440 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA4 has 17440 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MPRINT(JM_AVAL_SUM):   where AVISITN =4;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 902 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=4;
NOTE: The data set WORK.V_EMPTY has 902 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 902
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   jm_block = "104";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID aval trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MPRINT(JM_AVAL_SUM):   if AVISITN =4 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 902 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
                                                           The SAS System

NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   if index("104",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("104",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      159:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID PARAMN paramcd param avisitn avisit trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 902 observations read from the data set WORK.CUR_ADEG_S.
                                                           The SAS System

NOTE: SAS sort was used.
NOTE: 373 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 529 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("aval") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 529
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 529 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 529 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   class aval;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   var aval;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
                                                           The SAS System

MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 529 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 440 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      159:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("End of Week 4");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("104");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 440 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   curvar = put(aval,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value aval
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 104
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
                                                           The SAS System

MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 104";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BLOCK PROCESSED - 104
********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   if compress("aval") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   if compress("104") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   check=input("104",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '104' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'aval'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("PARAMN paramcd param 
avisitn avisit") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum104") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   data jm_aval_sum104;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      159:200   159:31    159:133   159:216   159:70    159:151   159:228   159:57    159:132   159:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      8 at 159:36    8 at 159:112   8 at 159:233   8 at 159:65    8 at 159:145   8 at 159:225   8 at 159:51    8 at 159:131
                                                           The SAS System

      8 at 159:249   8 at 159:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM104 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum104") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   data jm_aval_sum104;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_PREC_DECM):   set jm_aval_sum104;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: The data set WORK.JM_AVAL_SUM104 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   data jm_aval_sum104;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 104
MPRINT(JM_AVAL_SUM):   set jm_aval_sum104;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   drop aval;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "End of Week 4";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: The data set WORK.JM_AVAL_SUM104 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
                                                           The SAS System

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if aval ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 529 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
160        
161        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=chg, jm_bign=, jm_trtvarn=trtn,  JM_SECONDARY_WHERE= AVISITN =4 ,
161      ! JM_AVAL_LABEL=%bquote(Change from Baseline to End of Week 4),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
162        JM_BYVAR=  PARAMN paramcd param avisitn avisit, JM_BLOCK=105,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value chg
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN =4
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value Change from Baseline to End of Week 4
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 105
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =4";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 4";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 105";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =4
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 4
                                                           The SAS System

ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 105
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if compress("chg") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   if compress("105") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='chg' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=PARAMN paramcd param avisitn avisit " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 17440 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 17440 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.11 seconds
      cpu time            0.12 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted; it has been copied to the output data set.
NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: The variable STUDYID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable USUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SITEID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COUNTRY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BRTHDTC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEU on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEX on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEXN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RACE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNIC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNICN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SAFFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ENRLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PKFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RANDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SCRFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable MFASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable FASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMPSFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PTSDHFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRISN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRIS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ASEQ on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTPN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTA on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable TRTAN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTSDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTEDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP04FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP12FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREFID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSPID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGPOS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGORRES on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTRESC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTAT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREASND on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGNAM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGMETHOD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLEAD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGEVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLOBXFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITNUM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISIT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ATM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADTM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable DTYPE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ABLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BASE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PCHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL01FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable ANL02FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL03FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trtn on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trt on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 17440 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 17440 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 21800 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.08 seconds
      cpu time            0.07 seconds
      

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=PARAMN paramcd param avisitn avisit should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=PARAMN paramcd param avisitn avisit, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("PARAMN paramcd param avisitn avisit"));
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ PARAMN paramcd param avisitn avisit combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 5 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 5
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 5; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM104
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM104
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 4 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 4
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 4; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 4" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 4', which already " "exists in 
dataset(s) [JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
                                                           The SAS System

SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 4" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 4', which already " "exists in 
dataset(s) [JM_AVAL_SUM102]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
                                                           The SAS System

SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 4" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 4', which already " "exists in 
dataset(s) [JM_AVAL_SUM103]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM104;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 4" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 4', which already " "exists in 
dataset(s) [JM_AVAL_SUM104]. Please specify a different label in JM_AVAL_LABEL.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Change from Baseline
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   v_block = input("105",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='105' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
                                                           The SAS System

same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   if compress("105") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM105") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=105, which already " "exists in dataset(s) [JM_AVAL_SUM105]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT105") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=105, which already " "exists in dataset(s) [JM_AVAL_SUM105]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      162:64    162:137   162:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      162:206   
NOTE: There were 21800 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA5 has 21800 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.08 seconds
      cpu time            0.07 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MPRINT(JM_AVAL_SUM):   where AVISITN =4;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 902 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=4;
NOTE: The data set WORK.V_EMPTY has 902 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
                                                           The SAS System

SYMBOLGEN:  Macro variable NOBS resolves to 902
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   jm_block = "105";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID chg trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
                                                           The SAS System

NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
                                                           The SAS System

parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =4
MPRINT(JM_AVAL_SUM):   if AVISITN =4 then output;
MPRINT(JM_AVAL_SUM):   run;
                                                           The SAS System


NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 902 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   if index("105",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("105",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      162:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID PARAMN paramcd param avisitn avisit trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 902 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 373 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 529 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("chg") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 529
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 529 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 529 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   class chg;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   var chg;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 529 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 422 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      162:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("Change from Baseline to End of Week 4");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("105");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 422 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   curvar = put(chg,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value chg
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 105
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 105";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BLOCK PROCESSED - 105
********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   if compress("chg") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   if compress("105") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   check=input("105",best.);
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '105' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
                                                           The SAS System

SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'chg'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("PARAMN paramcd param 
avisitn avisit") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum105") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   data jm_aval_sum105;
                                                           The SAS System

SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      162:200   162:31    162:133   162:216   162:70    162:151   162:228   162:57    162:132   162:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      8 at 162:36    8 at 162:112   8 at 162:233   8 at 162:65    8 at 162:145   8 at 162:225   8 at 162:51    8 at 162:131
      8 at 162:249   8 at 162:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM105 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum105") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   data jm_aval_sum105;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_PREC_DECM):   set jm_aval_sum105;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: The data set WORK.JM_AVAL_SUM105 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   data jm_aval_sum105;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 105
MPRINT(JM_AVAL_SUM):   set jm_aval_sum105;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   drop chg;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 4
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "Change from Baseline to End of Week 4";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: The data set WORK.JM_AVAL_SUM105 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if chg ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 529 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
163        
164        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=aval, jm_bign=, jm_trtvarn=trtn, JM_SECONDARY_WHERE= AVISITN =8 ,
164      ! JM_AVAL_LABEL=%bquote(End of Week 8),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
165        JM_BYVAR=   PARAMN paramcd param avisitn avisit,  JM_BLOCK=106,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value aval
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN =8
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value End of Week 8
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 106
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =8";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 8";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 106";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =8
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 8
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 106
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if compress("aval") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   if compress("106") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='aval' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=PARAMN paramcd param avisitn avisit " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 21800 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 21800 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.14 seconds
      cpu time            0.14 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;
                                                           The SAS System


NOTE: Input data set is already sorted; it has been copied to the output data set.
NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: The variable STUDYID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable USUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SITEID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COUNTRY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BRTHDTC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEU on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEX on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEXN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RACE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNIC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNICN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SAFFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ENRLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PKFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable PDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RANDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SCRFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable MFASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable FASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMPSFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PTSDHFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRISN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRIS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ASEQ on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTPN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTA on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTAN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTSDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTEDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP04FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP12FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREFID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSPID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGPOS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGORRES on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTRESC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTAT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREASND on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGNAM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGMETHOD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLEAD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGEVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLOBXFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITNUM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISIT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ATM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADTM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable AVALC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable DTYPE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ABLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BASE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PCHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL01FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL02FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL03FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trtn on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trt on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 21800 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 21800 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 26160 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.11 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=PARAMN paramcd param avisitn avisit should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=PARAMN paramcd param avisitn avisit, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;
                                                           The SAS System


NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("PARAMN paramcd param avisitn avisit"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ PARAMN paramcd param avisitn avisit combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 6 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 6
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 6; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM104
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM104
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM105
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM105
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 7; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 5 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 5
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 5; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 8', which already " "exists in dataset(s) 
[JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 8', which already " "exists in dataset(s) 
[JM_AVAL_SUM102]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 8" then call symput('vlabel','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 8', which already " "exists in dataset(s) 
[JM_AVAL_SUM103]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM104;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 8', which already " "exists in dataset(s) 
[JM_AVAL_SUM104]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM105;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 8', which already " "exists in dataset(s) 
[JM_AVAL_SUM105]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Analysis Value
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   v_block = input("106",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='106' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   if compress("106") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM106") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=106, which already " "exists in dataset(s) [JM_AVAL_SUM106]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT106") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=106, which already " "exists in dataset(s) [JM_AVAL_SUM106]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      165:64    165:137   165:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      165:206   
NOTE: There were 26160 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA6 has 26160 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MPRINT(JM_AVAL_SUM):   where AVISITN =8;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 778 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=8;
NOTE: The data set WORK.V_EMPTY has 778 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 778
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   jm_block = "106";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID aval trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MPRINT(JM_AVAL_SUM):   if AVISITN =8 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 778 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   if index("106",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("106",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      165:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID PARAMN paramcd param avisitn avisit trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 778 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 310 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 468 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("aval") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 468
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 468 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 468 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   class aval;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   var aval;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 468 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 384 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      165:17   name
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("End of Week 8");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("106");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 384 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   curvar = put(aval,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value aval
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 106
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
                                                           The SAS System

MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 106";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BLOCK PROCESSED - 106
********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   if compress("aval") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   if compress("106") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   check=input("106",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '106' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'aval'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("PARAMN paramcd param 
avisitn avisit") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum106") then call symput('fexist','yes');
                                                           The SAS System

MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   data jm_aval_sum106;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
                                                           The SAS System

SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      165:200   165:31    165:133   165:216   165:70    165:151   165:228   165:57    165:132   165:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      8 at 165:36    8 at 165:112   8 at 165:233   8 at 165:65    8 at 165:145   8 at 165:225   8 at 165:51    8 at 165:131
      8 at 165:249   8 at 165:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM106 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum106") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   data jm_aval_sum106;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_PREC_DECM):   set jm_aval_sum106;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
NOTE: The data set WORK.JM_AVAL_SUM106 has 36 observations and 41 variables.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   data jm_aval_sum106;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 106
MPRINT(JM_AVAL_SUM):   set jm_aval_sum106;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   drop aval;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "End of Week 8";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
NOTE: The data set WORK.JM_AVAL_SUM106 has 36 observations and 41 variables.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if aval ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 468 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
166        
167        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=chg, jm_bign=, jm_trtvarn=trtn,  JM_SECONDARY_WHERE= AVISITN =8 ,
167      ! JM_AVAL_LABEL=%bquote(Change from Baseline to End of Week 8),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
168        JM_BYVAR=   PARAMN paramcd param avisitn avisit, JM_BLOCK=107,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value chg
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN =8
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value Change from Baseline to End of Week 8
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 107
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =8";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 8";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 107";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =8
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 8
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 107
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if compress("chg") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   if compress("107") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='chg' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=PARAMN paramcd param avisitn avisit " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 26160 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 26160 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.16 seconds
      cpu time            0.17 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted; it has been copied to the output data set.
NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
                                                           The SAS System

      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: The variable STUDYID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable USUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SITEID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COUNTRY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BRTHDTC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEU on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEX on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEXN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RACE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNIC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNICN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SAFFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ENRLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PKFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RANDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SCRFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable MFASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable FASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMPSFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PTSDHFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable SSNRISN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRIS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ASEQ on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTPN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTA on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTAN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTSDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTEDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP04FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP12FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREFID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSPID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGPOS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGORRES on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTRESC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTAT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREASND on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGNAM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGMETHOD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLEAD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGEVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLOBXFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITNUM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISIT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ATM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADTM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable DTYPE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ABLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BASE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PCHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable CRIT1FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL01FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL02FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL03FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trtn on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trt on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 26160 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.06 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 26160 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 30520 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.12 seconds
      

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=PARAMN paramcd param avisitn avisit should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=PARAMN paramcd param avisitn avisit, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("PARAMN paramcd param avisitn avisit"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ PARAMN paramcd param avisitn avisit combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 7 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 7
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 7; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM104
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM104
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM105
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM105
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM106
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM106
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 7; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 8; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 6 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 6
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 6; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 8', which already " "exists in 
dataset(s) [JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 8" then call symput('vlabel','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 8', which already " "exists in 
dataset(s) [JM_AVAL_SUM102]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 8', which already " "exists in 
dataset(s) [JM_AVAL_SUM103]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM104;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 8', which already " "exists in 
dataset(s) [JM_AVAL_SUM104]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM105;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 8', which already " "exists in 
dataset(s) [JM_AVAL_SUM105]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM106;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 8" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 8', which already " "exists in 
dataset(s) [JM_AVAL_SUM106]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 7; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Change from Baseline
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   v_block = input("107",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='107' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   if compress("107") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM107") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=107, which already " "exists in dataset(s) [JM_AVAL_SUM107]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT107") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=107, which already " "exists in dataset(s) [JM_AVAL_SUM107]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
                                                           The SAS System

statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      168:64    168:137   168:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      168:206   
                                                           The SAS System

NOTE: There were 30520 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA7 has 30520 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.09 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MPRINT(JM_AVAL_SUM):   where AVISITN =8;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 778 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=8;
NOTE: The data set WORK.V_EMPTY has 778 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 778
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   jm_block = "107";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   by USUBJID chg trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =8
MPRINT(JM_AVAL_SUM):   if AVISITN =8 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 778 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   if index("107",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("107",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      168:159  jm_block
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID PARAMN paramcd param avisitn avisit trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 778 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 310 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 468 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("chg") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 468
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 468 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 468 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   class chg;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   var chg;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 468 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 377 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      168:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("Change from Baseline to End of Week 8");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("107");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: There were 377 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   curvar = put(chg,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value chg
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 107
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 107";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BLOCK PROCESSED - 107
********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   if compress("chg") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   if compress("107") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   check=input("107",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '107' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'chg'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;
                                                           The SAS System


NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("PARAMN paramcd param 
avisitn avisit") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum107") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   data jm_aval_sum107;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
                                                           The SAS System

without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      168:200   168:31    168:133   168:216   168:70    168:151   168:228   168:57    168:132   168:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      8 at 168:36    8 at 168:112   8 at 168:233   8 at 168:65    8 at 168:145   8 at 168:225   8 at 168:51    8 at 168:131
      8 at 168:249   8 at 168:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM107 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum107") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   data jm_aval_sum107;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_PREC_DECM):   set jm_aval_sum107;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
NOTE: The data set WORK.JM_AVAL_SUM107 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   data jm_aval_sum107;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 107
MPRINT(JM_AVAL_SUM):   set jm_aval_sum107;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   drop chg;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 8
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "Change from Baseline to End of Week 8";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
NOTE: The data set WORK.JM_AVAL_SUM107 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if chg ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 468 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
169        
170        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=aval, jm_bign=, jm_trtvarn=trtn, JM_SECONDARY_WHERE= AVISITN =12,
170      ! JM_AVAL_LABEL=%bquote(End of Week 12),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
171        JM_BYVAR=   PARAMN paramcd param avisitn avisit,  JM_BLOCK=108,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value aval
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN =12
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value End of Week 12
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 108
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =12
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =12";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 12";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 108";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN =12
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_AVAL_LABEL PROCESSED - End of Week 12
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 108
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if compress("aval") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   if compress("108") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("aval") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='aval' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=PARAMN paramcd param avisitn avisit " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 30520 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 30520 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.20 seconds
      cpu time            0.20 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted; it has been copied to the output data set.
NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: The variable STUDYID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable USUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SITEID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COUNTRY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BRTHDTC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEU on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEX on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEXN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RACE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable ETHNIC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNICN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SAFFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ENRLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PKFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RANDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SCRFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable MFASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable FASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMPSFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PTSDHFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRISN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRIS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ASEQ on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTPN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTA on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTAN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTSDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTEDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP04FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP12FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREFID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSPID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGPOS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGORRES on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTRESC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTAT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREASND on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGNAM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGMETHOD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLEAD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGEVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLOBXFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITNUM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISIT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ATM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable ADTM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable DTYPE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ABLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BASE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PCHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL01FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL02FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL03FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trtn on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trt on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 30520 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.07 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 30520 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 34880 observations and 87 variables.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.13 seconds
      cpu time            0.12 seconds
      

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=PARAMN paramcd param avisitn avisit should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=PARAMN paramcd param avisitn avisit, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
                                                           The SAS System

order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("PARAMN paramcd param avisitn avisit"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ PARAMN paramcd param avisitn avisit combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 8 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.07 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 8
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 8; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
                                                           The SAS System

SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM104
                                                           The SAS System

MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM104
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM105
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM105
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM106
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM106
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 7; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM107
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM107
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 8; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 9; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 7 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 7
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 7; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 12', which already " "exists in dataset(s) 
[JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
                                                           The SAS System

SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 12', which already " "exists in dataset(s) 
[JM_AVAL_SUM102]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 12', which already " "exists in dataset(s) 
[JM_AVAL_SUM103]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM104;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 12', which already " "exists in dataset(s) 
[JM_AVAL_SUM104]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM105;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
                                                           The SAS System

SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 12', which already " "exists in dataset(s) 
[JM_AVAL_SUM105]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM106;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 12', which already " "exists in dataset(s) 
[JM_AVAL_SUM106]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 7; loop will iterate again.
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM107;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='End of Week 12', which already " "exists in dataset(s) 
[JM_AVAL_SUM107]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 8; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Analysis Value
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   v_block = input("108",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='108' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   if compress("108") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM108") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=108, which already " "exists in dataset(s) [JM_AVAL_SUM108]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT108") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=108, which already " "exists in dataset(s) [JM_AVAL_SUM108]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      171:64    171:137   171:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      171:206   
NOTE: There were 34880 observations read from the data set WORK.E_BYVAR.
NOTE: The data set WORK.DATA8 has 34880 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.12 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =12
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =12
MPRINT(JM_AVAL_SUM):   where AVISITN =12;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 610 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=12;
NOTE: The data set WORK.V_EMPTY has 610 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 610
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   jm_block = "108";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID aval trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =12
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN =12
MPRINT(JM_AVAL_SUM):   if AVISITN =12 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 610 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
                                                           The SAS System

      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   if index("108",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("108",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      171:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID PARAMN paramcd param avisitn avisit trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 610 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 238 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 372 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("aval") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
                                                           The SAS System

SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 372
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 372 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 372 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   class aval;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   var aval;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 372 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 316 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
MPRINT(JM_AVAL_SUM):   do i=1 to num;
MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
                                                           The SAS System

      171:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("End of Week 12");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("108");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 316 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   curvar = put(aval,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value aval
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 108
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
                                                           The SAS System

MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - aval";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 108";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - aval
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BLOCK PROCESSED - 108
********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   if compress("aval") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   if compress("108") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   check=input("108",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '108' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'aval'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("PARAMN paramcd param 
avisitn avisit") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
                                                           The SAS System

      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum108") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   data jm_aval_sum108;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
                                                           The SAS System

SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      171:200   171:31    171:133   171:216   171:70    171:151   171:228   171:57    171:132   171:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      8 at 171:36    8 at 171:112   8 at 171:233   8 at 171:65    8 at 171:145   8 at 171:225   8 at 171:51    8 at 171:131
      8 at 171:249   8 at 171:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM108 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum108") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   data jm_aval_sum108;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_PREC_DECM):   set jm_aval_sum108;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

                                                           The SAS System

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM108.
NOTE: The data set WORK.JM_AVAL_SUM108 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   data jm_aval_sum108;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 108
MPRINT(JM_AVAL_SUM):   set jm_aval_sum108;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   drop aval;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "End of Week 12";
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM108.
NOTE: The data set WORK.JM_AVAL_SUM108 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to aval
MPRINT(JM_AVAL_SUM):   if aval ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 372 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
172        
173        %JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=chg, jm_bign=, jm_trtvarn=trtn,  JM_SECONDARY_WHERE= AVISITN = 12,
173      ! JM_AVAL_LABEL=%bquote(Change from Baseline to End of Week 12),
MLOGIC(JM_AVAL_SUM):  Beginning execution.
MLOGIC(JM_AVAL_SUM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_aval_sum.sas
174        JM_BYVAR=   PARAMN paramcd param avisitn avisit, JM_BLOCK=109,JM_SIGD=1 );
MLOGIC(JM_AVAL_SUM):  Parameter JM_INDSN has value ADEG_S
MLOGIC(JM_AVAL_SUM):  Parameter JM_VAR has value chg
MLOGIC(JM_AVAL_SUM):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_SUM):  Parameter JM_SECONDARY_WHERE has value AVISITN = 12
MLOGIC(JM_AVAL_SUM):  Parameter JM_AVAL_LABEL has value Change from Baseline to End of Week 12
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  Parameter JM_BLOCK has value 109
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_SUM):  Parameter JM_CNTVAR has value USUBJID
MLOGIC(JM_AVAL_SUM):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_ALPHA has value 0.05
MLOGIC(JM_AVAL_SUM):  Parameter JM_CAP_3DEC has value Y
MLOGIC(JM_AVAL_SUM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_AVAL_SUM):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_SUM):  Parameter JM_VERSION has value 1.0
MLOGIC(JM_AVAL_SUM):  Parameter JM_FMT has value 
MPRINT(JM_AVAL_SUM):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "******************* Parameter Values *******************";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_S";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CNTVAR PROCESSED - USUBJID";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN = 12
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN = 12";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 12";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 109";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_ALPHA PROCESSED - 0.05";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_SUM):   PUT "ALERT:I: JM_FMT PROCESSED - ";
MPRINT(JM_AVAL_SUM):   put "********************************************************";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   put 'NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.';
MPRINT(JM_AVAL_SUM):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_S
ALERT:I: JM_CNTVAR PROCESSED - USUBJID
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - AVISITN = 12
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_AVAL_LABEL PROCESSED - Change from Baseline to End of Week 12
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 109
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_ALPHA PROCESSED - 0.05
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
ALERT:I: JM_FMT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_SUM] is currently running macro %jm_aval_sum version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** hold onto original jm_sigd ***;
MLOGIC(JM_AVAL_SUM):  %GLOBAL  O_JM_SIGD
MLOGIC(JM_AVAL_SUM):  %LET (variable name is O_JM_SIGD)
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   *** Verify if a macro variable for reporting attributes exists ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
MLOGIC(JM_AVAL_SUM):  %IF condition %symexist(_default_box)= 0 or            %symexist(_default_twips)= 0 or            
      %symexist(_DEFAULT_SPAN_HEAD)= 0 is FALSE
MPRINT(JM_AVAL_SUM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, JM_SIGD, 
JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if compress("ADEG_S") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if compress("USUBJID") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if compress("chg") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   if compress("109") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   if compress("trtn") = "" then do;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_TRTVARN is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Macro parameter JM_CAP_3DEC is required. Please specify it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   if upcase(compress("N")) not in ("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   *** Verify if it contains characters other than numbers or periods ***;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   o_JM_VERSION = strip("1.0");
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   JM_VERSION = strip("1.0");
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'1','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'2','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'3','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'4','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'5','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'6','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'7','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'8','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'9','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'0','');
MPRINT(JM_AVAL_SUM):   JM_VERSION = tranwrd(JM_VERSION,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   version = input(o_JM_VERSION,best.);
MPRINT(JM_AVAL_SUM):   if version <=0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] JM_VERSION should be a number > 0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   if exist("ADEG_S") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Dataset JM_INDSN = ADEG_S does not exist. " "Please specify proper dataset in 
JM_INDSN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror message. 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc contents data = ADEG_S out=v_jm_indsn noprint;
MPRINT(JM_AVAL_SUM):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if JMVAR has a label and is numeric ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   set v_jm_indsn;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   retain allvars;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_SUM):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") then call symputx('jmvar_label',label);
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("chg") and type = 2 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put "ER" "ROR:[JM_AVAL_SUM] Variable VAR='chg' in dataset JM_INDSN='ADEG_S' should " "be numeric, please 
correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length allvars $20000;
MPRINT(JM_AVAL_SUM):   allvars = strip(upcase(symget('allvars')));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   jm_byvar = upcase(strip("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_SUM):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   do while (space > 0 );
MPRINT(JM_AVAL_SUM):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_SUM):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_SUM):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_SUM):   test = index(allvars,curvar);
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Variables in JM_BYVAR=PARAMN paramcd param avisitn avisit " "should be 
separated only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   space=0;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVAR: &JM_BYVAR should be the same in all other related datasets (JM_AVAL_COUNTxx, 
JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is E_BYVAR)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   *** Check existince of previously defined JM_BYVAR **;
MPRINT(JM_AVAL_SUM):   if exist('work.e_byvar') = 1 then call symputx('e_byvar','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Initialize datablock ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DATABLOCK)
SYMBOLGEN:  Macro variable E_BYVAR resolves to yes
MLOGIC(JM_AVAL_SUM):  %IF condition "&e_byvar" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the current JM_BYVAR is the same as previoyusly defined ***;
MPRINT(JM_AVAL_SUM):   proc sort data = e_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 34880 observations read from the data set WORK.E_BYVAR.
NOTE: SAS sort was used.
NOTE: The data set WORK.E_BYVAR has 34880 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.23 seconds
      cpu time            0.25 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=v_byvar;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted; it has been copied to the output data set.
NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: The data set WORK.V_BYVAR has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
                                                           The SAS System

      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is SAME_PREV)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length datablock $100;
MPRINT(JM_AVAL_SUM):   merge e_byvar (in=A) v_byvar (in=B);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   if (A) and not(B) then do;
MPRINT(JM_AVAL_SUM):   call symputx('same_prev','no');
MPRINT(JM_AVAL_SUM):   call symputx('datablock',datablock);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: The variable STUDYID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable USUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SUBJID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SITEID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COUNTRY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BRTHDTC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEU on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR1N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AGEGR2N on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEX on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SEXN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RACE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNIC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ETHNICN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SAFFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ENRLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PKFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable RANDFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SCRFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable MFASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable FASFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable COMPSFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PTSDHFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRISN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable SSNRIS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITTYN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ASEQ on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTP on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTPN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTA on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTAN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTSDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable TRTEDT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP04FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable COMP12FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREFID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSPID on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGPOS on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGORRES on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTRESC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGSTAT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGREASND on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGNAM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGMETHOD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLEAD on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGEVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable EGLOBXFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISITNUM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable VISIT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADT on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ATM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADTM on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ADY on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable PARCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVAL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALC on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable DTYPE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ABLFL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable BASE on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
                                                           The SAS System

INFO: The variable PCHG on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT1FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT2FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CRIT3FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT1 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable CHGCAT2 on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL01FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL02FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable ANL03FL on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trtn on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable trt on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
INFO: The variable AVALN on data set WORK.E_BYVAR will be overwritten by data set WORK.V_BYVAR.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 34880 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.07 seconds
      

MPRINT(JM_AVAL_SUM):   *** Append new JM_BYVAR ***;
MPRINT(JM_AVAL_SUM):   data e_byvar;
MPRINT(JM_AVAL_SUM):   set e_byvar v_byvar;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 34880 observations read from the data set WORK.E_BYVAR.
NOTE: There were 4360 observations read from the data set WORK.V_BYVAR.
NOTE: The data set WORK.E_BYVAR has 39240 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.15 seconds
      cpu time            0.15 seconds
      

MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable SAME_PREV resolves to yes
MPRINT(JM_AVAL_SUM):   if "yes" = "no" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable DATABLOCK resolves to 
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BYVAR=PARAMN paramcd param avisitn avisit should be the same in all related 
datasets - " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx. You declared JM_BYVAR=PARAMN paramcd param avisitn avisit, but in dataset " "[]. " 
"Please make JM_BYVAR consistent across all " "JM_AVAL_COUNTxx, JM_AVAL_SUMxx datasets. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   if exist("") = 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' 'ROR: [JM_AVAL_SUM]: Dataset JM_BIGN = &JM_BIGN does not exist. ' "Please specify proper dataset in 
JM_BIGN parameter.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length v_where $200;
MPRINT(JM_AVAL_SUM):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_SUM):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length JM_CNTVAR JM_TRTVARN JM_VAR allvars $20000;
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase(symget('JM_CNTVAR')));
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase(symget('JM_TRTVARN')));
MPRINT(JM_AVAL_SUM):   JM_VAR=compress(upcase(symget('JM_VAR')));
MPRINT(JM_AVAL_SUM):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_CNTVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed 
in order for macro to work properly. Please add variable JM_TRTVARN to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   jm_byvar = strip(upcase("PARAMN paramcd param avisitn avisit"));
MPRINT(JM_AVAL_SUM):   *** Handle single valriable ***;
MPRINT(JM_AVAL_SUM):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   else do;
MPRINT(JM_AVAL_SUM):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_SUM):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_SUM):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " curvar "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: " jm_var= "is not in dataset JM_INDSN=ADEG_S." " This variable is needed in 
order for macro to work properly. Please add variable JM_VAR to " "dataset JM_INDSN=ADEG_S.  ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM):   set jm_bign1;
MPRINT(JM_AVAL_SUM):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_SUM):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
                                                           The SAS System

***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   JM_CNTVAR=compress(upcase("USUBJID"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   JM_BYVAR=compress(upcase("PARAMN paramcd param avisitn avisit"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR )) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR )) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: in dataset JM_INDSN=ADEG_S, there are duplicates for JM_CNTVAR/ " " 
JM_TRTVARN/ PARAMN paramcd param avisitn avisit combination. Please remove these duplicates." ;
MPRINT(JM_AVAL_SUM):   put " " ;
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_JM_AVAL_SUMxx, 
JM_AVAL_SUMxx) for the same JM_TRTVARN ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is VDATCNT)
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(upcase(memname),"JM_BIGN")=1 or index(upcase(memname),"JM_AVAL_SUM")=1 or 
index(upcase(memname),"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 9 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(UPCASE(memname), 'JM_BIGN')=1) or (INDEX(UPCASE(memname), 'JM_AVAL_SUM')=1) or 
      (INDEX(UPCASE(memname), 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable VDATCNT resolves to 9
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 9; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM104
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM104
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM105
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM105
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM106
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM106
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 7; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM107
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM107
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 8; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM108
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM108
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM108
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 9; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable VDAT9 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 10; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_SUMxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   retain vdatcnt 0;
MPRINT(JM_AVAL_SUM):   set sashelp.vstable;
MPRINT(JM_AVAL_SUM):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_SUM):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_SUM):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_SUM):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_SUM):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 8 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 8
MLOGIC(JM_AVAL_SUM):  %DO loop beginning; index variable I; start value is 1; stop value is 8; by value is 1.  
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM101]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM102]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM103]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM104;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;
                                                           The SAS System


NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM104]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
                                                           The SAS System

SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM105;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM105]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
                                                           The SAS System

SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM106;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM106]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 7; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM107;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM107]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 8; loop will iterate again.
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM108
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition %sysfunc(varnum(&dsid,JM_AVAL_LABEL)) is TRUE
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM108
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM108;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   if jm_aval_label = "Change from Baseline to End of Week 12" then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM108.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_SUM):   if "no" = "yes" then do;
MPRINT(JM_AVAL_SUM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
                                                           The SAS System

SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM108
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [JM_AVAL_SUM]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL='Change from Baseline to End of Week 12', which already " "exists 
in dataset(s) [JM_AVAL_SUM108]. Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   *** call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %DO loop index variable I is now 9; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of 
them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Change from Baseline
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   v_block = input("109",best.);
MPRINT(JM_AVAL_SUM):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_BLOCK='109' should be a number, please correct it.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   if compress("109") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_SUM109") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=109, which already " "exists in dataset(s) [JM_AVAL_SUM109]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   if exist("JM_AVAL_COUNT109") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=109, which already " "exists in dataset(s) [JM_AVAL_SUM109]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_ALPHA" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   alpha = input("0.05",best.);
MPRINT(JM_AVAL_SUM):   if alpha < 0 or alpha > 1 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_ALPHA should be a number between 0 and 1. Please specify proper JM_ALPHA.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_AVAL_SUM):   if upcase("Y") not in("Y","N") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_CAP_3DEC should be either Y or N. Please specify proper JM_CAP_3DEC.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_CAP_3DEC" = "Y" and "&JM_SIGD" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   JM_SIGD = strip("1");
MPRINT(JM_AVAL_SUM):   if JM_SIGD not in ("0" "1" "2" "3") then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: Macro parameter JM_CAP_3DEC = Y, which means that decimals for all " "summary 
statistics will be capped at 3. Therefore, please specify either 0 <= JM_SIGD <= 3 , or " "JM_CAP_3DEC = N.";
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   sigd = input(jm_sigd,best.);
MPRINT(JM_AVAL_SUM):   if int(sigd) ne sigd or sigd < 0 then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_SIGD should be an integer >=0. Please specify proper JM_SIGD. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_AVAL_SUM):   if "1" ne "" and "" ne "" then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM] Either JM_SIGD_BYVAR should be specified or JM_SIGD - but not both. ";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR is populated but &JM_BYVARFMT is not populated, check whether user associated formats to 
var-s in &JM_BYVAR prior to running this macro ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" and "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is CHECKBIG)
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MPRINT(JM_AVAL_SUM):   if 0=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   put 'WAR' "NING: [jm_aval_sum]: contains empty or missing values for " "BIGN in dataset ''. " "This may 
result in missing percentage summaries.";
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

WARNING: [jm_aval_sum]: contains empty or missing values for BIGN in dataset ''. This may result in missing percentage summaries.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 0
MLOGIC(JM_AVAL_SUM):  %IF condition &checkbig=0 is TRUE
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   data ;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_SUM):   set ;
MPRINT(JM_AVAL_SUM):   if index(jm_aval_bign_label,'(N=') then do;
MPRINT(JM_AVAL_SUM):   jm_aval_bign_label=substr(jm_aval_bign_label,1, index(jm_aval_bign_label,'(N=')-1) || '(N=0)';
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      174:64    174:137   174:177   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      174:206   
NOTE: There were 39240 observations read from the data set WORK.E_BYVAR.
                                                           The SAS System

NOTE: The data set WORK.DATA9 has 39240 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.14 seconds
      cpu time            0.14 seconds
      

MPRINT(JM_AVAL_SUM):   *** Check &JM_BYVARFMT: are formats separated by blanks? If not, issue er ror ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvarfmt" ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_SUM):   jm_debug=compress("N");
MPRINT(JM_AVAL_SUM):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_SUM):   jm_version=compress("1.0");
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'4','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_SUM):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_SUM):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_SUM):   put 'ER' "ROR: [JM_AVAL_SUM]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_SUM):   put " ";
MPRINT(JM_AVAL_SUM):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if the input dataset is empty ***;
MPRINT(JM_AVAL_SUM):   data v_empty;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN = 12
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN = 12
MPRINT(JM_AVAL_SUM):   where AVISITN = 12;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 610 observations read from the data set WORK.ADEG_S.
      WHERE AVISITN=12;
NOTE: The data set WORK.V_EMPTY has 610 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
                                                           The SAS System

MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 610
MLOGIC(JM_AVAL_SUM):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is V_EMPTY)
MPRINT(JM_AVAL_SUM):   *** If &JM_SIGD_BYVAR is missing then macro will assign JM_SIGD_BYVAR to the first variable in &JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Verify if &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated based on 
just &JM_VAR ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_SUM):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   jm_block = "109";
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd(jm_block,'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN and 
JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S out=cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by USUBJID chg trtn;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

MLOGIC(JM_AVAL_SUM):  %LET (variable name is BIGWHERE)
MPRINT(JM_AVAL_SUM):   *** Only merge with JM_BIGN if specified since it is optional ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_BIGN" ne "" is FALSE
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified, sort to merge with JM_BIGN ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   by trtn;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 4360 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   data count_prep1;
MPRINT(JM_AVAL_SUM):   *** Process option with JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_bign" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Process without JM_BIGN option ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   set cur_ADEG_S (in=A);
MPRINT(JM_AVAL_SUM):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   *** call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_SUM):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_SUM):   length jm_trtvarn 8;
MPRINT(JM_AVAL_SUM):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_SUM):   output;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.COUNT_PREP1 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_SUM):   data count_prep2;
MPRINT(JM_AVAL_SUM):   set count_prep1;
SYMBOLGEN:  Macro variable BIGWHERE resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&bigwhere" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN = 12
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   *** If &JM_SECONDARY_WHERE is not blank then macro will subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   data cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   set cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to AVISITN = 12
MPRINT(JM_AVAL_SUM):   if AVISITN = 12 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.CUR_ADEG_S has 610 observations and 86 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_SUM):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 4360 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 4360 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   if index("109",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   jm_block = tranwrd("109",'.','_');
MPRINT(JM_AVAL_SUM):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      174:159  jm_block
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_SUM):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   PROC SORT DATA=cur_ADEG_S NODUPKEY;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   BY USUBJID PARAMN paramcd param avisitn avisit trtn;
MPRINT(JM_AVAL_SUM):   *** WHERE &JM_SECONDARY_WHERE.;
MPRINT(JM_AVAL_SUM):   RUN;

NOTE: There were 610 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: 238 observations with duplicate key values were deleted.
NOTE: The data set WORK.CUR_ADEG_S has 372 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_SUM):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("chg") and upcase(memname) = "ADEG_S" ;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_SUM):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
JM_VAR_type=NUM
MPRINT(JM_AVAL_SUM):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MLOGIC(JM_AVAL_SUM):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_SUM):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_SUM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_SUM):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 372
MLOGIC(JM_AVAL_SUM):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_SUM):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = cur_ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 372 observations read from the data set WORK.CUR_ADEG_S.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_S has 372 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM):   **** PROCESS PROC MEANS for JM_AVAL_SUM ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
SYMBOLGEN:  Macro variable JM_ALPHA resolves to 0.05
MPRINT(JM_AVAL_SUM):   proc means data=cur_ADEG_S ALPHA=0.05 completetypes noprint;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   BY PARAMN paramcd param avisitn avisit trtn ;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition %length(&JM_FMT)>0 is FALSE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   class chg;
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to NUM 
MLOGIC(JM_AVAL_SUM):  %IF condition &JM_VAR_type ne CHAR is TRUE
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   var chg;
MPRINT(JM_AVAL_SUM):   output out= JM_AVAL_SUM_PRE N=JM_N MEAN=JM_MEAN MEDIAN=JM_MEDIAN STD=JM_STD STDERR=JM_STDERR MIN=JM_MIN 
MAX=JM_MAX LCLM=JM_LCLM UCLM=JM_UCLM Q1=JM_Q1 Q3=JM_Q3;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 372 observations read from the data set WORK.CUR_ADEG_S.
NOTE: The data set WORK.JM_AVAL_SUM_PRE has 316 observations and 20 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_SUM):   *** Vefify if JM_CNTVAR exists ***;
MPRINT(JM_AVAL_SUM):   data _null_;
MPRINT(JM_AVAL_SUM):   call symputx('cntvar_exist','no');
MPRINT(JM_AVAL_SUM):   dsid=open("JM_AVAL_SUM_PRE", "i");
MPRINT(JM_AVAL_SUM):   if dsid ne 0 then do;
MPRINT(JM_AVAL_SUM):   num=attrn(dsid, "nvars");
MPRINT(JM_AVAL_SUM):   do i=1 to num;
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   name=varname(dsid, i);
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to USUBJID
MPRINT(JM_AVAL_SUM):   if upcase(name) = upcase("USUBJID") then call symputx('cntvar_exist','yes');
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   rc=close(dsid);
MPRINT(JM_AVAL_SUM):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      174:17   name
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Add the JM_AVAL_LABEL to the dataset ***;
MPRINT(JM_AVAL_SUM):   data JM_AVAL_SUM_PRE;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_LABEL $200 JM_BLOCK $10 JM_TRTVARN 8;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_SUM):   length JM_TYPE $20;
MPRINT(JM_AVAL_SUM):   JM_TYPE = "SUMMARY";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_LABEL = strip("Change from Baseline to End of Week 12");
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   JM_BLOCK = strip("109");
MPRINT(JM_AVAL_SUM):   set JM_AVAL_SUM_PRE;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&JM_TRTVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   JM_TRTVARN=trtn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_SUM):   drop trtn;
SYMBOLGEN:  Macro variable CNTVAR_EXIST resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&cntvar_exist" = "yes" is FALSE
MPRINT(JM_AVAL_SUM):   *** Output summary ***;
MPRINT(JM_AVAL_SUM):   if _type_ = 0 then output;
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 316 observations read from the data set WORK.JM_AVAL_SUM_PRE.
                                                           The SAS System

NOTE: The data set WORK.JM_AVAL_SUM_PRE has 36 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Hadnle If "&jm_sigd" is missing, then decimals will be calculated based on just &JM_VAR. ***;
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_SUM):   if "1" = "" then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set ADEG_S;
MPRINT(JM_AVAL_SUM):   *** Identify the decimal places based on JM_VAR ***;
MPRINT(JM_AVAL_SUM):   retain maxsig 0;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   curvar = put(chg,best.);
MPRINT(JM_AVAL_SUM):   if index(curvar,'.') = 0 then sigd=0;
MPRINT(JM_AVAL_SUM):   else sigd = length(curvar)-index(curvar,'.');
MPRINT(JM_AVAL_SUM):   if maxsig < sigd then maxsig = sigd;
MPRINT(JM_AVAL_SUM):   call symputx('JM_SIGD',maxsig);
MPRINT(JM_AVAL_SUM):   end;
MPRINT(JM_AVAL_SUM):   run;

NOTE: DATA STEP stopped due to looping.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Invoke %JM_PREC_DECM with output from PROC MEANS ***;
MLOGIC(JM_PREC_DECM):  Beginning execution.
MLOGIC(JM_PREC_DECM):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_prec_decm.sas
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MLOGIC(JM_PREC_DECM):  Parameter JM_AVAL_SUM_PRE has value JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  Parameter JM_VAR has value chg
MLOGIC(JM_PREC_DECM):  Parameter JM_CAP_3DEC has value Y
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD has value 1
MLOGIC(JM_PREC_DECM):  Parameter JM_SIGD_BYVAR has value 
MLOGIC(JM_PREC_DECM):  Parameter JM_BYVAR has value PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  Parameter JM_BLOCK has value 109
MPRINT(JM_PREC_DECM):   *** Document in log what parameter value specified ***;
MPRINT(JM_PREC_DECM):   data _null_;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE";
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_VAR PROCESSED - chg";
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_CAP_3DEC PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_SIGD_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   PUT "ALERT:I: JM_BLOCK PROCESSED - 109";
MPRINT(JM_PREC_DECM):   put "********************************************************";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   put 'NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.';
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   run;


******************* Parameter Values *******************
ALERT:I: JM_AVAL_SUM_PRE PROCESSED - JM_AVAL_SUM_PRE
ALERT:I: JM_VAR PROCESSED - chg
ALERT:I: JM_CAP_3DEC PROCESSED - Y
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_SIGD_BYVAR PROCESSED - 
ALERT:I: JM_BYVAR PROCESSED - PARAMN paramcd param avisitn avisit
ALERT:I: JM_BLOCK PROCESSED - 109
********************************************************

NOTE: [JM_PREC_DECM] is currently running macro %jm_prec_decm version 1.0.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
MPRINT(JM_PREC_DECM):   *** Checking for missing required parameters ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if compress("JM_AVAL_SUM_PRE") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_AVAL_SUM_PRE. ' 'This specifies the input SAS 
dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   if compress("chg") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_VAR. ' 'This specifies the numeric variable 
for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   if compress("109") = '' then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put 'ER' 'ROR:[JM_PREC_DECM] is missing required parameter JM_BLOCK. ' 'This specifies the output dataset 
name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_BLOCK ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   check=input("109",best.);
MPRINT(JM_PREC_DECM):   if check = . then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value '109' for parameter JM_BLOCK. " 'This specifies the 
output dataset name ' 'containing grouping variables (i.e. 101).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Checking for invalid required parameters JM_AVAL_SUM_PRE ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   if exist("JM_AVAL_SUM_PRE") = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_AVAL_SUM_PRE 'JM_AVAL_SUM_PRE'. " 'This 
specifies the input SAS dataset name (i.e. JM_AVAL_SUM_PRE).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_VAR ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MLOGIC(JM_PREC_DECM):  %LET (variable name is VARPOS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MLOGIC(JM_PREC_DECM):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable VARPOS resolves to 10
MPRINT(JM_PREC_DECM):   if 10 = 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_VAR 'chg'. " 'This specifies the numeric 
variable for ' 'which this macro will produce summary statistics.';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_CAP_3DEC ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   JM_CAP_3DEC = upcase("Y");
MPRINT(JM_PREC_DECM):   if JM_CAP_3DEC ne '' and JM_CAP_3DEC not in("Y","N") then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_CAP_3DEC 'Y'. " 'This specifies the option to 
apply to all summary statistics to ' 'be capped at 3 (Default Y).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = input("1",best.);
MPRINT(JM_PREC_DECM):   if JM_SIGD = . or JM_SIGD < 0 or JM_SIGD > 20 then do;
MPRINT(JM_PREC_DECM):   put ' ';
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put 'ER' "ROR:[JM_PREC_DECM] contains an invalid value for JM_SIGD '1'. " 'This specifies the Significant 
Digits for the Decimal ' 'Precision Of Min/Max (i.e. 0, 1, 2 or 3).';
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Check invalid parameter JM_SIGD_BYVAR ***;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD_BYVAR" ne "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 3) ***;
MLOGIC(JM_PREC_DECM):  %LET (variable name is _ERR)
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable O_JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&o_jm_sigd" = "2" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 6) ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR" ne "" and "&JM_BYVAR" 
      ne "" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 7) ***;
MPRINT(JM_PREC_DECM):   *** Verify JM_SIGD_BYVAR should have only 1 variable name. ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_PREC_DECM):   if upcase("Y") = "Y" and compress("1") = "" and compress("") ne "" and compress("PARAMN paramcd param 
avisitn avisit") ne "" then do;
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MPRINT(JM_PREC_DECM):   JM_SIGD_BYVAR=upcase(strip(""));
MPRINT(JM_PREC_DECM):   if index(JM_SIGD_BYVAR,' ') > 0 then do;
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   put "ER" "ROR:[JM_PREC_DECM] JM_SIGD_BYVAR should have only 1 variable name. " "Please specify proper 
variable name. If you do need more than 1 variable name " "in JM_SIGD_BYVAR, please create a new variable name " "(with 2+ 
variables concatenated).";
MPRINT(JM_PREC_DECM):   put " ";
MPRINT(JM_PREC_DECM):   call symput('_err','yes');
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 4) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
                                                           The SAS System

MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "4" and "&JM_SIGD_BYVAR"="" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 1) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 2) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" and "&JM_SIGD" = "2" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 5) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and %upcase("&JM_SIGD_BYVAR")="PARAMCD" is 
      FALSE
MPRINT(JM_PREC_DECM):   *** Process Scenario 8) ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "Y" and "&JM_SIGD" = "" and "&JM_SIGD_BYVAR"="" and "&JM_BYVAR" ne 
      "" is FALSE
MPRINT(JM_PREC_DECM):   *** Process 1.1) If &JM_SIGD_BYVAR is missing and &JM_BYVAR is missing, then decimals will be calculated 
based on just &JM_VAR. ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
SYMBOLGEN:  Macro variable JM_SIGD_BYVAR resolves to 
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD"="" and "&JM_SIGD_BYVAR" = "" and "&JM_BYVAR" = "" is FALSE
MPRINT(JM_PREC_DECM):   *** Set Significant digit to 2 as the default if it is set to missing ***;
MPRINT(JM_PREC_DECM):   *** data _null_;
MPRINT(JM_PREC_DECM):   *** if compress("&JM_SIGD") = "" then do;
MPRINT(JM_PREC_DECM):   *** call symputx('JM_SIGD',"2");
MPRINT(JM_PREC_DECM):   *** put "NOTE:[JM_PREC_DECM] Since JM_SIGD is not specified, the default value of '2' is set as default.";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   *** end;
MPRINT(JM_PREC_DECM):   *** run;
MPRINT(JM_PREC_DECM):   *** Process 2) &JM_SIGD will be used to derive variables JM_MIN_ROUND, JM_MEAN_ROUND, and JM_STD_ROUND, 
JM_STDERR_ROUND in dataset JM_AVAL_SUMxx ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MLOGIC(JM_PREC_DECM):  %IF condition "&JM_SIGD" ne "" is TRUE
MLOGIC(JM_PREC_DECM):  %LET (variable name is FEXIST)
MPRINT(JM_PREC_DECM):   *** Verify if final dataset is already created ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   if exist("WORK.jm_aval_sum109") then call symput('fexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Define the format for correct display of number digits based upon rounding ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Define format for mean ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round=0 then call symputx('meanfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.1 then call symputx('meanfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.01 then call symputx('meanfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.001 then call symputx('meanfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.0001 then call symputx('meanfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_mean_round=0.00001 then call symputx('meanfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for min ***;
MPRINT(JM_PREC_DECM):   if jm_min_round=0 then call symputx('minfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.1 then call symputx('minfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.01 then call symputx('minfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.001 then call symputx('minfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.0001 then call symputx('minfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_min_round=0.00001 then call symputx('minfmt', "12.5");
MPRINT(JM_PREC_DECM):   *** Define format for std ***;
MPRINT(JM_PREC_DECM):   if jm_std_round=0 then call symputx('stdfmt', "10.0");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.1 then call symputx('stdfmt', "10.1");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.01 then call symputx('stdfmt', "10.2");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.001 then call symputx('stdfmt', "10.3");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.0001 then call symputx('stdfmt', "11.4");
MPRINT(JM_PREC_DECM):   if jm_std_round=0.00001 then call symputx('stdfmt', "12.5");
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   data jm_aval_sum109;
SYMBOLGEN:  Macro variable FEXIST resolves to no
MLOGIC(JM_PREC_DECM):  %IF condition "&fexist" = "no" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_SUM_PRE resolves to JM_AVAL_SUM_PRE
MPRINT(JM_PREC_DECM):   set JM_AVAL_SUM_PRE;
MPRINT(JM_PREC_DECM):   *** &JM_SIGD will become variable JM_PREC_DECM ***;
MPRINT(JM_PREC_DECM):   length JM_PREC_DECM $20;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_PREC_DECM = strip("1");
MPRINT(JM_PREC_DECM):   *** Calculate JM_MIN_ROUND, JM_MEAN_ROUND, JM_STD_ROUND and JM_STDERR_ROUND ***;
SYMBOLGEN:  Macro variable JM_CAP_3DEC resolves to Y
MLOGIC(JM_PREC_DECM):  %IF condition %upcase("&JM_CAP_3DEC") = "N" is FALSE
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=1 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.1;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=2 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.01;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=3 then do;
MPRINT(JM_PREC_DECM):   JM_MIN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_MEAN_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   JM_STD_ROUND = 0.001;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   if _n_ = 1 then do;
MPRINT(JM_PREC_DECM):   put " ";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=" JM_MIN_ROUND +(-1) ", JM_MEAN_ROUND=" JM_MEAN_ROUND 
+(-1) ", JM_STD_ROUND=" JM_STD_ROUND ;
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.1) JM_MIN_ROUND will be used to derive JM_MINC and JM_MAXC. ***;
MPRINT(JM_PREC_DECM):   if jm_min_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(JM_MIN),10.1));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(JM_MAX),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(round(jm_min , jm_min_round),10.1));
SYMBOLGEN:  Macro variable MINFMT resolves to 10.1
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(round(jm_max , jm_min_round),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.2) JM_MEAN_ROUND will be used to derive JM_MEANC, JM_MEDIANC, JM_Q1C, JM_Q3C, JM_LCLMC, 
JM_UCLMC. ***;
MPRINT(JM_PREC_DECM):   if jm_mean_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(int(JM_MEAN),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(int(JM_MEDIAN),10.1));
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(int(JM_LCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(int(JM_UCLM),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(int(JM_Q1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(int(JM_Q3),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(jm_mean , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(jm_median, jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_LCLMC = strip(put(round(jm_lclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_UCLMC = strip(put(round(jm_uclm , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(jm_q1 , jm_mean_round),10.2));
SYMBOLGEN:  Macro variable MEANFMT resolves to 10.2
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(jm_q3 , jm_mean_round),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.3) JM_STD_ROUND will be used to derive JM_STDC and JM_STDERRC. ***;
MPRINT(JM_PREC_DECM):   if jm_std_round = 0 then do;
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(int(JM_STD),10.1));
                                                           The SAS System

MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(int(JM_STDERR),10.1));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   else do;
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(jm_std , JM_STD_ROUND),10.3));
SYMBOLGEN:  Macro variable STDFMT resolves to 10.3
MPRINT(JM_PREC_DECM):   JM_STDERRC = strip(put(round(jm_stderr, JM_STD_ROUND),10.3));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 4.4) &JM_SIGD=0 JM_MIN_ROUND=0, JM_MEAN_ROUND=0.1, JM_STD_ROUND=.01. ***;
MPRINT(JM_PREC_DECM):   *** JM_MINC will have no decimals, JM_MEANC will have 1 decimal, JM_STDC will have 2 decimals ***;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   if 1=0 and JM_MIN_ROUND=0 and JM_MEAN_ROUND=0.1 and JM_STD_ROUND=.01 then do;
MPRINT(JM_PREC_DECM):   JM_MINC = strip(put(int(jm_min), best.));
MPRINT(JM_PREC_DECM):   JM_MAXC = strip(put(int(jm_max), best.));
MPRINT(JM_PREC_DECM):   JM_MEANC = strip(put(round(JM_MEAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_MEDIANC = strip(put(round(JM_MEDIAN,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q1C = strip(put(round(JM_Q1,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_Q3C = strip(put(round(JM_Q3,.1),10.1));
MPRINT(JM_PREC_DECM):   JM_STDC = strip(put(round(JM_STD,.01),10.2));
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   *** Process 5) JM_NC will be just a copy of JM_N ***;
MPRINT(JM_PREC_DECM):   JM_NC = strip(put(JM_N,best.));
MPRINT(JM_PREC_DECM):   *** Process 6) JM_MEANSTDC will be calculated as a concatenation of JM_MEANC and JM_STDC, where JM_STDC is 
enclosed in brackets. Example: xxx (yyyy). ***;
MPRINT(JM_PREC_DECM):   length part1 part2 $20;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if jm_stdc = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(jm_stdc);
MPRINT(JM_PREC_DECM):   JM_MEANSTDC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 7) JM_MEANSTDERRC will be calculated as a concatenation of JM_MEANC and JM_STDERRC, where 
JM_STDERRC is enclosed in brackets. Example: xxx (yyyy).***;
MPRINT(JM_PREC_DECM):   length JM_MEANSTDERRC $40;
MPRINT(JM_PREC_DECM):   if jm_meanc = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(jm_meanc);
MPRINT(JM_PREC_DECM):   if JM_STDERRC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_STDERRC);
MPRINT(JM_PREC_DECM):   JM_MEANSTDERRC = strip(part1) || " (" || trim(part2) || ')';
MPRINT(JM_PREC_DECM):   *** Process 8) JM_RANGEC will be calculated as a concatenation of JM_MINC and JM_MAXC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
                                                           The SAS System

MPRINT(JM_PREC_DECM):   length JM_RANGEC $40;
MPRINT(JM_PREC_DECM):   if JM_MINC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_MINC);
MPRINT(JM_PREC_DECM):   if JM_MAXC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_MAXC);
MPRINT(JM_PREC_DECM):   JM_RANGEC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   *** Process 9) JM_Q1C_Q3C will be calculated as a concatenation of JM_Q1C and JM_Q3C, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_Q1C_Q3C $40;
MPRINT(JM_PREC_DECM):   if JM_Q1C = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_Q1C);
MPRINT(JM_PREC_DECM):   if JM_Q3C = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_Q3C);
MPRINT(JM_PREC_DECM):   JM_Q1C_Q3C = strip(part1) || ", " || strip(part2) ;
MPRINT(JM_PREC_DECM):   *** Process 10) JM_CIC will be calculated as a concatenation of JM_LCLMC and JM_UCLMC, separated by commas, 
without brackers. Example: xxx, yyyy. ***;
MPRINT(JM_PREC_DECM):   length JM_CIC $40;
MPRINT(JM_PREC_DECM):   if JM_LCLMC = . then part1 = 'na';
MPRINT(JM_PREC_DECM):   else part1 = strip(JM_LCLMC);
MPRINT(JM_PREC_DECM):   if JM_UCLMC = . then part2 = 'na';
MPRINT(JM_PREC_DECM):   else part2 = strip(JM_UCLMC);
MPRINT(JM_PREC_DECM):   JM_CIC = strip(part1) || ", " || strip(part2);
MPRINT(JM_PREC_DECM):   drop part1 part2;
MPRINT(JM_PREC_DECM):   *** Label variables ***;
MPRINT(JM_PREC_DECM):   label JM_LCLM = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_LCLMC = "Lower Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_MAX = "Max";
MPRINT(JM_PREC_DECM):   label JM_MAXC = "Max";
MPRINT(JM_PREC_DECM):   label JM_MEAN = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANC = "Mean";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDC = "Mean (SD)";
MPRINT(JM_PREC_DECM):   label JM_MEANSTDERRC = "Mean (SE)";
MPRINT(JM_PREC_DECM):   label JM_MEAN_ROUND = "Mean Round";
MPRINT(JM_PREC_DECM):   label JM_MEDIAN = "Median";
MPRINT(JM_PREC_DECM):   label JM_MEDIANC = "Median";
MPRINT(JM_PREC_DECM):   label JM_MIN = "Min";
MPRINT(JM_PREC_DECM):   label JM_MINC = "Min";
MPRINT(JM_PREC_DECM):   label JM_MIN_ROUND = "Min Round";
MPRINT(JM_PREC_DECM):   label JM_N = "n";
MPRINT(JM_PREC_DECM):   label JM_NC = "n";
MPRINT(JM_PREC_DECM):   label JM_Q1 = "Q1";
                                                           The SAS System

MPRINT(JM_PREC_DECM):   label JM_Q3 = "Q3";
MPRINT(JM_PREC_DECM):   label JM_Q1C = "Q1";
MPRINT(JM_PREC_DECM):   label JM_Q1C_Q3C = "Q1, Q3";
MPRINT(JM_PREC_DECM):   label JM_Q3C = "Q3C";
MPRINT(JM_PREC_DECM):   label JM_RANGEC = "Min, Max";
MPRINT(JM_PREC_DECM):   label JM_STD = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDC = "SD";
MPRINT(JM_PREC_DECM):   label JM_STDERR = "SE";
MPRINT(JM_PREC_DECM):   label JM_STDERRC = "SE";
MPRINT(JM_PREC_DECM):   label JM_STD_ROUND = "SD Round";
MPRINT(JM_PREC_DECM):   label JM_UCLM = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   label JM_UCLMC = "Upper Confidence Limit for Mean";
MPRINT(JM_PREC_DECM):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      174:200   174:31    174:133   174:216   174:70    174:151   174:228   174:57    174:132   174:215   

NOTE: [JM_PREC_DECM] Macro assigned JM_MIN_ROUND=0.1, JM_MEAN_ROUND=0.01, JM_STD_ROUND=0.001
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      8 at 174:36    8 at 174:112   8 at 174:233   8 at 174:65    8 at 174:145   8 at 174:225   8 at 174:51    8 at 174:131
      8 at 174:249   8 at 174:74    
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM_PRE.
NOTE: The data set WORK.JM_AVAL_SUM109 has 36 observations and 43 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_PREC_DECM):  %LET (variable name is DATEXIST)
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   if exist ("jm_aval_sum109") then call symput('datexist','yes');
MPRINT(JM_PREC_DECM):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 2.6) Output Datasets /Macro Variables/ Global Macro Variables/Formats ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable DATEXIST resolves to yes
MLOGIC(JM_PREC_DECM):  %IF condition "&datexist" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   data jm_aval_sum109;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_PREC_DECM):   set jm_aval_sum109;
MPRINT(JM_PREC_DECM):   drop _type_ _freq_;
MPRINT(JM_PREC_DECM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM109.
NOTE: The data set WORK.JM_AVAL_SUM109 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Process 3) Macro will provide a note in the log, stating (for each &JM_SIGD_BYVAR, if &JM_SIGD_BYVAR is 
not missing) ***;
MPRINT(JM_PREC_DECM):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   JM_SIGD = strip("1");
MPRINT(JM_PREC_DECM):   if JM_SIGD ne '' then do;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_PREC_DECM):   put "NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. ";
MPRINT(JM_PREC_DECM):   put ' ';
MPRINT(JM_PREC_DECM):   end;
MPRINT(JM_PREC_DECM):   run;

NOTE: [JM_PREC_DECM] User specified '1' for parameter JM_SIGD. 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PREC_DECM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PREC_DECM):  Ending execution.
MPRINT(JM_AVAL_SUM):  ;
MPRINT(JM_AVAL_SUM):   *** Drop extra variable ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
MPRINT(JM_AVAL_SUM):   data jm_aval_sum109;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 109
                                                           The SAS System

MPRINT(JM_AVAL_SUM):   set jm_aval_sum109;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   drop chg;
MPRINT(JM_AVAL_SUM):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to Change from Baseline to End of Week 12
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_SUM):   JM_AVAL_NAMEC = "Change from Baseline to End of Week 12";
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM109.
NOTE: The data set WORK.JM_AVAL_SUM109 has 36 observations and 41 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Remove temporary JM_AVAL_SUM_PRE dataset ***;
MPRINT(JM_AVAL_SUM):   proc datasets noprint;
MPRINT(JM_AVAL_SUM):   delete jm_aval_sum_pre;
MPRINT(JM_AVAL_SUM):   quit;
NOTE: Deleting WORK.JM_AVAL_SUM_PRE (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Verify if input dataset has any missing values ***;
MLOGIC(JM_AVAL_SUM):  %LET (variable name is MISSING)
MPRINT(JM_AVAL_SUM):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   set cur_ADEG_S ;
SYMBOLGEN:  Macro variable JM_VAR resolves to chg
MPRINT(JM_AVAL_SUM):   if chg ne . then call symputx('missing','no');
MPRINT(JM_AVAL_SUM):   run;

NOTE: There were 372 observations read from the data set WORK.CUR_ADEG_S.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable MISSING resolves to no
SYMBOLGEN:  Macro variable V_EMPTY resolves to no
MLOGIC(JM_AVAL_SUM):  %IF condition "&missing" = "yes" and "&v_empty" = "no" is FALSE
MPRINT(JM_AVAL_SUM):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_S
MPRINT(JM_AVAL_SUM):   proc sort data = ADEG_S;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to PARAMN paramcd param avisitn avisit
MPRINT(JM_AVAL_SUM):   by PARAMN paramcd param avisitn avisit;
MPRINT(JM_AVAL_SUM):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM):  Ending execution.
175        
176        %*JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=aval, jm_bign=, jm_trtvarn=trtn, JM_SECONDARY_WHERE= AVISITN = 92,
176      ! JM_AVAL_LABEL=%bquote(Safety Follow-up),
177        JM_BYVAR=  PARAMN paramcd param avisitn avisit,  JM_BLOCK=110,JM_SIGD=0 );
178        
179        %*JM_AVAL_SUM(JM_INDSN=ADEG_S, jm_var=chg, jm_bign=, jm_trtvarn=trtn,  JM_SECONDARY_WHERE= AVISITN = 92,
179      ! JM_AVAL_LABEL=%bquote(Change from Baseline to Safety Follow-up),
180        JM_BYVAR=  PARAMN paramcd param avisitn avisit, JM_BLOCK=111,JM_SIGD=0 );
181        
182        %JM_AVAL_COUNT(JM_INDSN=ADEG_F, jm_var= AVALC , JM_SECONDARY_WHERE= avalc ne "" and aval eq . and  paramn  in (106),
182      ! jm_bign=jm_bign1, jm_trtvarn=trtn,
MLOGIC:  Beginning compilation of JM_AVAL_COUNT using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_count.sas.
MLOGIC:  Ending compilation of JM_AVAL_COUNT.
MLOGIC(JM_AVAL_COUNT):  Beginning execution.
MLOGIC(JM_AVAL_COUNT):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_count.sas
183        jm_block=112, jm_cntvar=usubjid, JM_BYVAR= paramn param avisitn avisit AVALN, JM_FMT=, JM_AVAL_LABEL=%bquote(SNRARRY) );
MLOGIC(JM_AVAL_COUNT):  Parameter JM_INDSN has value ADEG_F
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  Parameter JM_VAR has value AVALC
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SECONDARY_WHERE has value avalc ne "" and aval eq . and  paramn  in (106)
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BIGN has value jm_bign1
MLOGIC(JM_AVAL_COUNT):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BLOCK has value 112
MLOGIC(JM_AVAL_COUNT):  Parameter JM_CNTVAR has value usubjid
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BYVAR has value paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  Parameter JM_FMT has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_AVAL_LABEL has value SNRARRY
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SMALLN has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SHOW_PERCENT has value Y
MLOGIC(JM_AVAL_COUNT):  Parameter JM_ONLY_TOTALS has value N
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SHOW_OVERALL_PERCENT has value N
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SUBGRP has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_COUNT):  Parameter JM_VERSION has value 1.0
MPRINT(JM_AVAL_COUNT):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   JM_SECONDARY_WHERE = symget('JM_SECONDARY_WHERE');
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_F";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_CNTVAR PROCESSED - usubjid";
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BIGN PROCESSED - jm_bign1";
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SMALLN PROCESSED - ";
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - " JM_SECONDARY_WHERE;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_VAR PROCESSED - AVALC";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_FMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SHOW_PERCENT PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_ONLY_TOTALS resolves to N
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_ONLY_TOTALS PROCESSED - N";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SHOW_OVERALL_PERCENT resolves to N
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SHOW_OVERALL_PERCENT PROCESSED - N";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - SNRARRY";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BYVAR PROCESSED - paramn param avisitn avisit AVALN";
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BLOCK PROCESSED - 112";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SUBGRP PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
MPRINT(JM_AVAL_COUNT):   put "********************************************************";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   put 'NOTE: [JM_AVAL_COUNT] is currently running macro %jm_aval_count version 1.1.';
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      183:81   JM_SECONDARY_WHERE

******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_F
ALERT:I: JM_CNTVAR PROCESSED - usubjid
ALERT:I: JM_BIGN PROCESSED - jm_bign1
ALERT:I: JM_SMALLN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - avalc ne "" and aval eq . and  paramn  in (106)
ALERT:I: JM_VAR PROCESSED - AVALC
ALERT:I: JM_FMT PROCESSED - 
ALERT:I: JM_SHOW_PERCENT PROCESSED - Y
                                                           The SAS System

ALERT:I: JM_ONLY_TOTALS PROCESSED - N
ALERT:I: JM_SHOW_OVERALL_PERCENT PROCESSED - N
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_AVAL_LABEL PROCESSED - SNRARRY
ALERT:I: JM_BYVAR PROCESSED - paramn param avisitn avisit AVALN
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 112
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
ALERT:I: JM_SUBGRP PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
********************************************************

NOTE: [JM_AVAL_COUNT] is currently running macro %jm_aval_count version 1.1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, 
JM_ONLY_TOTALS , JM_SHOW_OVERALL_PERCENT, JM_SIGD, JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   if compress("ADEG_F") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   if compress("usubjid") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   if compress("jm_bign1") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_BIGN is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put "  ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   if compress("AVALC") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_SHOW_PERCENT is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_ONLY_TOTALS resolves to N
MPRINT(JM_AVAL_COUNT):   if compress("N") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_ONLY_TOTALS is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SHOW_OVERALL_PERCENT resolves to N
MPRINT(JM_AVAL_COUNT):   if compress("N") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_SHOW_OVERALL_PERCENT is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   if compress("1") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_SIGD is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   if compress("112") = "" then do;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_TRTVARN is required. " "Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_COUNT):   if compress("N") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_DEBUG is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_COUNT):   if compress("1.0") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_VERSION is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify if Sub Group was applied consistently ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
MPRINT(JM_AVAL_COUNT):   if _n_ = 1 then do;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MPRINT(JM_AVAL_COUNT):   if upcase(jm_subgrp) ne upcase("") and compress(jm_subgrp) ne '' then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] specified JM_SUBGRP=‘’ which is different from JM_SUBGRP=‘" jm_subgrp +(-1) 
'’ specified in %JM_BIGN macro call.';
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Variable jm_subgrp is uninitialized.
NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_SIGD: if it contains characters other than integers ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   JM_SIGD=compress("1");
MPRINT(JM_AVAL_COUNT):   o_jm_sigd = jm_sigd;
MPRINT(JM_AVAL_COUNT):   if JM_SIGD ne '' then do;
MPRINT(JM_AVAL_COUNT):   *** Remove numbers to test ***;
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'1','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'2','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'3','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'4','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'5','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'6','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'7','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'8','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'9','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'0','');
MPRINT(JM_AVAL_COUNT):   if compress(jm_sigd) ne '' then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] JM_SIGD: " o_jm_sigd "should be an integer >=0. Please specify proper 
                                                           The SAS System

JM_SIGD.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   if exist("ADEG_F") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR:[jm_aval_count]: Dataset JM_INDSN = ADEG_F does not exist. " "Please specify proper dataset 
in JM_INDSN parameter.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify if the input dataset is empty ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 2658
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  %IF condition &nobs = 0 is FALSE
MPRINT(JM_AVAL_COUNT):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror 
message. ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   proc contents data = ADEG_F out=v_jm_indsn noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Verify if JMVAR has a label ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_jm_indsn;
MPRINT(JM_AVAL_COUNT):   length allvars $20000;
MPRINT(JM_AVAL_COUNT):   retain allvars;
MPRINT(JM_AVAL_COUNT):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_COUNT):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   if upcase(name) = upcase("AVALC") then call symputx('jmvar_label',label);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Initialize first JM_BYVAR ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is JM_BYVAR1)
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length allvars $20000;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   jm_byvar = upcase(strip("paramn param avisitn avisit AVALN"));
MPRINT(JM_AVAL_COUNT):   *** Remove extra spaces **;
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_COUNT):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_COUNT):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_COUNT):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_COUNT):   cnt = 1;
MPRINT(JM_AVAL_COUNT):   do while (space > 0 );
MPRINT(JM_AVAL_COUNT):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_COUNT):   jm_byvar = substr(jm_byvar,space+1);
MPRINT(JM_AVAL_COUNT):   *** Hold onto first jm_byvar ***;
MPRINT(JM_AVAL_COUNT):   if cnt = 1 then do;
MPRINT(JM_AVAL_COUNT):   call symputx('jm_byvar1',curvar);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   cnt = cnt + 1;
MPRINT(JM_AVAL_COUNT):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_COUNT):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Variables in JM_BYVAR=paramn param avisitn avisit AVALN should be 
separated " "only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   space=0;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   if exist("jm_bign1") = 0 then do;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Dataset JM_BIGN = jm_bign1 does not exist. " "Please specify proper 
dataset in JM_BIGN parameter.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_SMALLN exists ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MPRINT(JM_AVAL_COUNT):   if compress("") ne '' and exist("") = 0 then do;
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Dataset JM_SMALLN =  does not exist. " "Please specify proper dataset in 
JM_SMALLN parameter.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether &JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length v_where $400;
MPRINT(JM_AVAL_COUNT):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_COUNT):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   JM_CNTVAR=compress(upcase("usubjid"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   JM_VAR=compress(upcase("AVALC"));
MPRINT(JM_AVAL_COUNT):   length allvars $20000;
MPRINT(JM_AVAL_COUNT):   allvars = strip(upcase(symget('allvars')));
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_F." " This variable is 
needed in order for macro to work properly. Please add variable JM_CNTVAR to dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_F." " This variable is 
needed in order for macro to work properly. Please add variable JM_TRTVARN to dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(upcase("paramn param avisitn avisit AVALN"));
MPRINT(JM_AVAL_COUNT):   *** Remove extra spaces **;
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   *** Handle single valriable ***;
MPRINT(JM_AVAL_COUNT):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_AVAL_COUNT]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_F." " This variable is needed 
in order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   else do;
MPRINT(JM_AVAL_COUNT):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_COUNT):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_COUNT):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_AVAL_COUNT]: " curvar "is not in dataset JM_INDSN=ADEG_F." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: " jm_var= "is not in dataset JM_INDSN=ADEG_F." " This variable is needed 
in order for macro to work properly. Please add variable JM_VAR to dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   JM_CNTVAR=compress(upcase("usubjid"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   JM_BYVAR=compress(upcase("paramn param avisitn avisit AVALN"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR)) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR)) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: in dataset JM_INDSN=ADEG_F, there are duplicates for JM_CNTVAR/ 
JM_TRTVARN/ paramn param avisitn avisit AVALN combination. " "Please remove these duplicates." ;
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is CHECKBIG)
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
MPRINT(JM_AVAL_COUNT):   retain checkbig 0;
MPRINT(JM_AVAL_COUNT):   if jm_aval_bign ne . then checkbig=checkbig+jm_aval_bign;
MPRINT(JM_AVAL_COUNT):   call symputx('checkbig',checkbig);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 76
MPRINT(JM_AVAL_COUNT):   if 76=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: contains empty or missing values for " "BIGN in dataset 'jm_bign1'. " 
"This may result in missing percentage summaries.";
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 76
MLOGIC(JM_AVAL_COUNT):  %IF condition &checkbig=0 is FALSE
MPRINT(JM_AVAL_COUNT):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_COUNT):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is TRUE
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   data v_jm_bign1;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   if trtn = . then trtn = jm_trtvarn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: The data set WORK.V_JM_BIGN1 has 4 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   proc sql;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   create table v_jm_indsn as select distinct trtn from ADEG_F;
NOTE: Table WORK.V_JM_INDSN created, with 4 rows and 1 columns.

SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   create table v_jm_bign as select distinct trtn from v_jm_bign1;
NOTE: Table WORK.V_JM_BIGN created, with 4 rows and 1 columns.

MPRINT(JM_AVAL_COUNT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   proc sort data = v_jm_indsn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   proc sort data = v_jm_bign;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data v_jm_trtvarn;
MPRINT(JM_AVAL_COUNT):   merge v_jm_indsn (in=A) v_jm_bign (in=B);
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   if (A) and not(B) then do;
MPRINT(JM_AVAL_COUNT):   output;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.V_JM_INDSN.
NOTE: There were 4 observations read from the data set WORK.V_JM_BIGN.
NOTE: The data set WORK.V_JM_TRTVARN has 0 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is TRTLIST)
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_jm_trtvarn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   curvar = trtn;
MPRINT(JM_AVAL_COUNT):   length trtlist $300;
MPRINT(JM_AVAL_COUNT):   retain trtlist;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   trtlist = strip(trtlist) || " " || strip(put(trtn,best.));
MPRINT(JM_AVAL_COUNT):   call symputx('trtlist',trtlist);
MPRINT(JM_AVAL_COUNT):   run;

                                                           The SAS System

NOTE: There were 0 observations read from the data set WORK.V_JM_TRTVARN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable TRTLIST resolves to none
MLOGIC(JM_AVAL_COUNT):  %IF condition "&trtlist" ne "none" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_AVAL_SUMxx, 
JM_AVAL_COUNTxx) for the same JM_TRTVARN ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   retain vdatcnt 0;
MPRINT(JM_AVAL_COUNT):   set sashelp.vstable;
MPRINT(JM_AVAL_COUNT):   where libname = "WORK" and ( index(memname,"JM_BIGN")=1 or index(memname,"JM_AVAL_SUM")=1 or 
index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_COUNT):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_COUNT):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_COUNT):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 10 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_BIGN')=1) or (INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 
      'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

SYMBOLGEN:  Macro variable VDATCNT resolves to 10
MLOGIC(JM_AVAL_COUNT):  %DO loop beginning; index variable I; start value is 1; stop value is 10; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM104
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM104
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM105
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM105
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM106
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM106
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 7; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM107
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM107
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 8; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
                                                           The SAS System

SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM108
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM108
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM108
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 9; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable VDAT9 resolves to JM_AVAL_SUM109
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM109
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM109
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 10; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable VDAT10 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 11; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
                                                           The SAS System

JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   retain vdatcnt 0;
MPRINT(JM_AVAL_COUNT):   set sashelp.vstable;
MPRINT(JM_AVAL_COUNT):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_COUNT):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_COUNT):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_COUNT):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 9 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 9
MLOGIC(JM_AVAL_COUNT):  %DO loop beginning; index variable I; start value is 1; stop value is 9; by value is 1.  
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM101]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 2; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM102]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 3; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM103]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 4; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM104;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM104]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 5; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM105;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM105]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 6; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM106;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM106]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 7; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM107;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM107]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 8; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM108
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM108;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM108.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM108
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM108]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 9; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable VDAT9 resolves to JM_AVAL_SUM109
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM109;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "SNRARRY" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM109.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable VDAT9 resolves to JM_AVAL_SUM109
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=SNRARRY, which already " "exists in dataset [JM_AVAL_SUM109]. 
Please specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 10; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any 
of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Analysis Value (C)
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   v_block = input("112",best.);
MPRINT(JM_AVAL_COUNT):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Macro parameter JM_BLOCK=112 should be a number, please correct it.";
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   if compress("112") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   if exist("JM_AVAL_SUM112") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=112, which already " "exists in dataset(s) [JM_AVAL_SUM112]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   if exist("JM_AVAL_COUNT112") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=112, which already " "exists in dataset(s) [JM_AVAL_COUNT112]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_COUNT):   jm_debug=compress("N");
MPRINT(JM_AVAL_COUNT):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_COUNT):   jm_version=compress("1.0");
MPRINT(JM_AVAL_COUNT):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_COUNT):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'5','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'9','');
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_COUNT):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_SHOW_PERCENT: if it’s not Y or N ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   jm_show_percent=compress("Y");
MPRINT(JM_AVAL_COUNT):   if jm_show_percent ne '' and upcase(jm_show_percent) not in('Y','N') then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_SHOW_PERCENT should be either Y or N. " "Please specify proper 
JM_SHOW_PERCENT.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_SHOW_OVERALL_PERCENT: if it’s not Y or N ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SHOW_OVERALL_PERCENT resolves to N
MPRINT(JM_AVAL_COUNT):   jm_show_overall_percent=compress("N");
MPRINT(JM_AVAL_COUNT):   if jm_show_overall_percent ne '' and upcase(jm_show_overall_percent) not in('Y','N') then do;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_SHOW_OVERALL_PERCENT should be either Y or N. " "Please specify proper 
JM_SHOW_OVERALL_PERCENT.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_ONLY_TOTALS: if it’s not Y or N ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_ONLY_TOTALS resolves to N
MPRINT(JM_AVAL_COUNT):   JM_ONLY_TOTALS=compress("N");
MPRINT(JM_AVAL_COUNT):   if JM_ONLY_TOTALS ne '' and upcase(JM_ONLY_TOTALS) not in('Y','N') then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_ONLY_TOTALS should be either Y or N. " "Please specify proper 
JM_ONLY_TOTALS.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_COUNT):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
MPRINT(JM_AVAL_COUNT):   *** Handle case where JM_SECONDARY_WHERE contains double quotes ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length curwhere $400;
MPRINT(JM_AVAL_COUNT):   curwhere = symget('JM_SECONDARY_WHERE');
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   if index(curwhere,'"') > 0 then do;
MPRINT(JM_AVAL_COUNT):   curwhere=strip(tranwrd(curwhere,'"',"'"));
MPRINT(JM_AVAL_COUNT):   call symputx('JM_SECONDARY_WHERE',curwhere);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Create a dataset which defines the grouping variable and apply formats ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   data ADEG_F_112;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   set ADEG_F;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   trtVAR= trtn;
MPRINT(JM_AVAL_COUNT):   _count=1;
MPRINT(JM_AVAL_COUNT):   *** Assign grouping variable ***;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   grpvar=AVALC;
MPRINT(JM_AVAL_COUNT):   length grplabel $200;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   grplabel=VLABEL(AVALC);
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   box=VLABEL(AVALC);
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition &JM_FMT. NE is FALSE
MPRINT(JM_AVAL_COUNT):   *** Apply treatment format to treatment variable ***;
MPRINT(JM_AVAL_COUNT):   format TRTVAR trt.;
MPRINT(JM_AVAL_COUNT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      183:155  box
NOTE: There were 2658 observations read from the data set WORK.ADEG_F.
NOTE: The data set WORK.ADEG_F_112 has 2658 observations and 91 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_COUNT):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN 
and JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   proc sort data = ADEG_F out=cur_ADEG_F;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MLOGIC(JM_AVAL_COUNT):  %IF condition %upcase("&jm_cntvar") = %upcase("&jm_var") is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   by trtn usubjid AVALC ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 2658 observations read from the data set WORK.ADEG_F.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_F has 2658 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.03 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Set the user specified treatment numeric variable ***;
MPRINT(JM_AVAL_COUNT):   data cur_jm_bign2;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   trtn = jm_trtvarn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: The data set WORK.CUR_JM_BIGN2 has 4 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   proc sort data = cur_jm_bign2 out=cur_jm_bign1;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN2.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_JM_BIGN1 has 4 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Verify what variables exists in BIGN ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   proc contents data = cur_jm_bign1 out=v_bign noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_BIGN has 7 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_WHERE)
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_CNTVAR)
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_VAR)
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_JM_TRTVAR)
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_bign;
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "JM_BIGN_WHERE" then call symputx('v_where','yes');
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "usubjid" then call symputx('v_cntvar','yes');
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "AVALC" then call symputx('v_var','yes');
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "JM_TRTVAR" then call symputx('v_jm_trtvar','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 7 observations read from the data set WORK.V_BIGN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable V_JM_TRTVAR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_jm_trtvar" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   data count_prep1;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable V_WHERE resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_where" = "yes" is FALSE
SYMBOLGEN:  Macro variable V_CNTVAR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_cntvar" = "yes" is FALSE
SYMBOLGEN:  Macro variable V_VAR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_var" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   merge cur_jm_bign1 (keep = trtn in=B) cur_ADEG_F (in=A);
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_COUNT):   call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_COUNT):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_COUNT):   length jm_trtvarn 8;
MPRINT(JM_AVAL_COUNT):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_COUNT):   output;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN1.
NOTE: There were 2658 observations read from the data set WORK.CUR_ADEG_F.
NOTE: The data set WORK.COUNT_PREP1 has 2658 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Set where clause to missing if it is ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length curwhere $200;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MPRINT(JM_AVAL_COUNT):   curwhere = strip("");
MPRINT(JM_AVAL_COUNT):   if curwhere = '.' then curwhere = '';
MPRINT(JM_AVAL_COUNT):   call symputx('JM_BIGN_WHERE',curwhere);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_COUNT):   data count_prep2;
MPRINT(JM_AVAL_COUNT):   set count_prep1;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_bign_where" ne "" and "&jm_bign_where" ne "." is FALSE
MPRINT(JM_AVAL_COUNT):   *** If &JM_SECONDARY_WHERE is not blank then subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MPRINT(JM_AVAL_COUNT):   if avalc ne '' and aval eq . and paramn in (106) then output;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 2658 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 305 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   by paramn param avisitn avisit AVALN;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 305 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
                                                           The SAS System

NOTE: The data set WORK.COUNT_PREP2 has 305 observations and 88 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   if index("112",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   jm_block = tranwrd("112",'.','_');
MPRINT(JM_AVAL_COUNT):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      183:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify the variable type of JM_BIGN_WHERE ***;
MPRINT(JM_AVAL_COUNT):   proc contents data = count_prep2 varnum out=v_bign_where noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_BIGN_WHERE has 88 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is _VARTYPE)
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_bign_where;
MPRINT(JM_AVAL_COUNT):   where upcase(name) = 'JM_BIGN_WHERE';
MPRINT(JM_AVAL_COUNT):   if type = 1 then call symputx('_vartype','num');
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 1 observations read from the data set WORK.V_BIGN_WHERE.
      WHERE UPCASE(name)='JM_BIGN_WHERE';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_COUNT):   *** Final dataset created by macro – will be JM_AVAL_COUNT&JM_BLOCK ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   data JM_AVAL_COUNT112;
SYMBOLGEN:  Macro variable _VARTYPE resolves to num
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_vartype" = "num" is TRUE
MPRINT(JM_AVAL_COUNT):   set count_prep2 (rename=jm_bign_where=_jm_bign_where) ;
MPRINT(JM_AVAL_COUNT):   *** Add logic here to check for JM_BIGN_WHERE type char ***;
SYMBOLGEN:  Macro variable _VARTYPE resolves to num
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_vartype" = "num" is TRUE
MPRINT(JM_AVAL_COUNT):   length jm_bign_where $200;
MPRINT(JM_AVAL_COUNT):   if _jm_bign_where = . then jm_bign_where = '';
MPRINT(JM_AVAL_COUNT):   else jm_bign_where = put(_jm_bign_where,best.);
MPRINT(JM_AVAL_COUNT):   drop _jm_bign_where;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 305 observations read from the data set WORK.COUNT_PREP2.
NOTE: The data set WORK.JM_AVAL_COUNT112 has 305 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   PROC SORT DATA=ADEG_F_112 NODUPKEY;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   BY AVALC usubjid paramn param avisitn avisit AVALN trtn;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MPRINT(JM_AVAL_COUNT):   WHERE avalc ne '' and aval eq . and paramn in (106);
MPRINT(JM_AVAL_COUNT):   RUN;

NOTE: There were 305 observations read from the data set WORK.ADEG_F_112.
      WHERE (avalc not = ' ') and (aval=.) and (paramn=106);
NOTE: SAS sort was used.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.ADEG_F_112 has 305 observations and 91 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_COUNT):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("AVALC") and upcase(memname) = "ADEG_F" ;
MPRINT(JM_AVAL_COUNT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to CHAR
JM_VAR_type=CHAR
MPRINT(JM_AVAL_COUNT):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_COUNT):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 305
MLOGIC(JM_AVAL_COUNT):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_COUNT):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition %length(&JM_FMT)>0 is FALSE
MPRINT(JM_AVAL_COUNT):   *** Subset by condition &JM_BIGN_WHERE. ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   data ADEG_F_112 ;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   set ADEG_F_112 ;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_bign_where" ne "" and "&jm_bign_where" ne "." is FALSE
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 305 observations read from the data set WORK.ADEG_F_112.
NOTE: The data set WORK.ADEG_F_112 has 305 observations and 91 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   proc sort data = ADEG_F_112 ;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   BY paramn param avisitn avisit AVALN GRPLABEL;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 305 observations read from the data set WORK.ADEG_F_112.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADEG_F_112 has 305 observations and 91 variables.
NOTE: PROCEDURE SORT used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Identify if variable has format ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   proc contents data = ADEG_F_112 out=v_hasfmt noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_HASFMT has 91 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is HASFMT)
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_hasfmt;
MPRINT(JM_AVAL_COUNT):   where upcase(name) = "GRPVAR";
MPRINT(JM_AVAL_COUNT):   if format ne '' then call symputx('hasfmt','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 1 observations read from the data set WORK.V_HASFMT.
      WHERE UPCASE(name)='GRPVAR';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Process case with formated JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MPRINT(JM_AVAL_COUNT):   PROC MEANS DATA = ADEG_F_112 (where = ( avalc ne '' and aval eq . and paramn in (106) ) ) completetypes 
nway NOPRINT;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   BY paramn param avisitn avisit AVALN GRPLABEL;
SYMBOLGEN:  Macro variable HASFMT resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&hasfmt" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   CLASS TRTVAR GRPVAR/MLF ;
MPRINT(JM_AVAL_COUNT):   VAR _count;
MPRINT(JM_AVAL_COUNT):   OUTPUT OUT = count_prep4 (drop=_freq_ ) N=JM_AVAL_COUNT;
MPRINT(JM_AVAL_COUNT):   RUN;

NOTE: There were 305 observations read from the data set WORK.ADEG_F_112.
      WHERE (avalc not = ' ') and (aval=.) and (paramn=106);
NOTE: The data set WORK.COUNT_PREP4 has 48 observations and 10 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Impute the significant ditit ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   JM_SIGD = 1;
MPRINT(JM_AVAL_COUNT):   part1 = 3+jm_sigd;
MPRINT(JM_AVAL_COUNT):   part2 =jm_sigd;
MPRINT(JM_AVAL_COUNT):   sigfmt = strip(put(part1,best.)) || "." || strip(put(part2,best.));
MPRINT(JM_AVAL_COUNT):   call symputx('sigfmt',sigfmt);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_COUNT):   proc format library=work cntlout=rfmt;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System

NOTE: The data set WORK.RFMT has 387 observations and 21 variables.

SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" and "&jm_byvarfmt" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   data count_prep4a;
MPRINT(JM_AVAL_COUNT):   set count_prep4;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP4.
NOTE: The data set WORK.COUNT_PREP4A has 48 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Calculate total count if JM_BYVAR is specified ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data count_prep4b;
MPRINT(JM_AVAL_COUNT):   set count_prep4;
MPRINT(JM_AVAL_COUNT):   where _type_ in(2,3);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP4.
      WHERE _type_ in (2, 3);
NOTE: The data set WORK.COUNT_PREP4B has 48 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep4b;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   by paramn param avisitn avisit AVALN _type_ trtvar grpvar jm_aval_count;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP4B.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP4B has 48 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   data count_prep4c;
MPRINT(JM_AVAL_COUNT):   set count_prep4b;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   by paramn param avisitn avisit AVALN _type_ trtvar grpvar jm_aval_count;
MPRINT(JM_AVAL_COUNT):   retain order 0;
MPRINT(JM_AVAL_COUNT):   if _type_ = 2 then JM_AVAL_NAMEN = -99;
MPRINT(JM_AVAL_COUNT):   if _type_ = 3 then do;
MPRINT(JM_AVAL_COUNT):   *** if first.&jm_trtvarn. then do;
MPRINT(JM_AVAL_COUNT):   *** order = 1;
MPRINT(JM_AVAL_COUNT):   *** end;
MPRINT(JM_AVAL_COUNT):   *** else do;
MPRINT(JM_AVAL_COUNT):   *** order = order + 1;
MPRINT(JM_AVAL_COUNT):   *** end;
MPRINT(JM_AVAL_COUNT):   order = order + 1;
MPRINT(JM_AVAL_COUNT):   JM_AVAL_NAMEN = order;
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   drop order _type_;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP4B.
NOTE: The data set WORK.COUNT_PREP4C has 48 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data count_prep4;
MPRINT(JM_AVAL_COUNT):   set count_prep4c;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP4C.
NOTE: The data set WORK.COUNT_PREP4 has 48 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_COUNT):   *** Capture the format order for JM_AVAL_NAMEN ***;
MPRINT(JM_AVAL_COUNT):   proc format library=work cntlout=v_fmt3;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: The data set WORK.V_FMT3 has 387 observations and 21 variables.

MPRINT(JM_AVAL_COUNT):   proc sort data = v_fmt3;
MPRINT(JM_AVAL_COUNT):   by fmtname start label;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 387 observations read from the data set WORK.V_FMT3.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_FMT3 has 387 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_fmt3;
MPRINT(JM_AVAL_COUNT):   by fmtname start label;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_COUNT):   curfmt = upcase("");
MPRINT(JM_AVAL_COUNT):   curfmt = tranwrd(curfmt,'.','');
MPRINT(JM_AVAL_COUNT):   *** Handle case when no JM_BYFARFMT was specified ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to SNRARRY
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if compress(curfmt) = '' then call symputx('namen',"SNRARRY");
MPRINT(JM_AVAL_COUNT):   if curfmt = fmtname and first.fmtname then call symputx('namen',label);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 387 observations read from the data set WORK.V_FMT3.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_COUNT):   *** Sort data in order to have group totals appear first for total counts ***;
MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep4;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   by trtvar grpvar ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP4.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP4 has 48 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   proc sort data = cur_jm_bign1;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   by trtvar;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN1.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_JM_BIGN1 has 4 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Calculate JM_AVAL_COUNTC ***;
MPRINT(JM_AVAL_COUNT):   data count_prep5;
MPRINT(JM_AVAL_COUNT):   length JM_AVAL_LABEL JM_AVAL_COUNTC JM_AVAL_NAMEC $2000 JM_BLOCK $10 JM_BIGN_WHERE $200;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   merge count_prep4 (in=A) cur_jm_bign1 (keep= trtvar jm_aval_bign );
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   by trtvar;
MPRINT(JM_AVAL_COUNT):   retain namen 0;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MPRINT(JM_AVAL_COUNT):   JM_BIGN_WHERE = "";
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN = input(put(trtvar,$trtc.),best.);
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
MPRINT(JM_AVAL_COUNT):   JM_BLOCK = strip("112");
MPRINT(JM_AVAL_COUNT):   jm_aval_label = strip(symget('jm_aval_label'));
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = '' then jm_aval_label = grplabel;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   if jm_aval_count = 0 then percent = 0;
MPRINT(JM_AVAL_COUNT):   else do;
MPRINT(JM_AVAL_COUNT):   if jm_aval_bign = 0 then percent = 0;
MPRINT(JM_AVAL_COUNT):   else percent = (jm_aval_count/jm_aval_bign)*100;
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   if upcase("Y") = "N" then JM_AVAL_COUNTC = strip(put(jm_aval_count,best.));
SYMBOLGEN:  Macro variable SIGFMT resolves to 4.1
MPRINT(JM_AVAL_COUNT):   else JM_AVAL_COUNTC = strip(put(jm_aval_count,best.)) || " (" || strip(put(percent,4.1)) || ')';
MPRINT(JM_AVAL_COUNT):   if jm_aval_count = 0 then do;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   if upcase("Y") = "N" then jm_aval_countc = "0";
MPRINT(JM_AVAL_COUNT):   else jm_aval_countc = "0 (0)";
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   drop percent;
MPRINT(JM_AVAL_COUNT):   *** Assign format if specified ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Handle multiple JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_BYVAR1 resolves to PARAMN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar1" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   *** Assign label with proper BY variable ***;
SYMBOLGEN:  Macro variable JM_BYVAR1 resolves to PARAMN
MPRINT(JM_AVAL_COUNT):   if JM_AVAL_NAMEN = -99 then JM_AVAL_NAMEC = strip(PARAMN);
SYMBOLGEN:  Macro variable JM_BYVAR1 resolves to PARAMN
MPRINT(JM_AVAL_COUNT):   else JM_AVAL_NAMEC = "   " || strip(PARAMN);
MPRINT(JM_AVAL_COUNT):   *** Assign JM_BIGN_WHERE (=&JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_BIGN_WHERE" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Assign JM_SECONDARY_WHERE (=&JM_SECONDARY_WHERE ) ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   length JM_SECONDARY_WHERE $200;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (106)
MPRINT(JM_AVAL_COUNT):   JM_SECONDARY_WHERE = "avalc ne '' and aval eq . and  paramn  in (106)";
MPRINT(JM_AVAL_COUNT):   *** Assign JM_TRTVAR (=&JM_TRTVAR ) ***;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   if (A);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" = "" is FALSE
MPRINT(JM_AVAL_COUNT):   drop grplabel namen percent ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      183:1   183:1   
NOTE: There were 48 observations read from the data set WORK.COUNT_PREP4.
NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN1.
NOTE: The data set WORK.COUNT_PREP5 has 48 observations and 17 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Sort the data by treament and then JMAVAL_NAMEN ***;
MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep5;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   by JM_AVAL_NAMEN JM_AVAL_NAMEC JM_TRTVARN ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP5.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP5 has 48 observations and 17 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Generate the final output dataset ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 112
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   data JM_AVAL_COUNT112;
MPRINT(JM_AVAL_COUNT):   length JM_TYPE $20;
MPRINT(JM_AVAL_COUNT):   set count_prep5;
MPRINT(JM_AVAL_COUNT):   JM_TYPE = 'COUNT';
MPRINT(JM_AVAL_COUNT):   *** Handle case of empty of missing BIGN ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 76
MPRINT(JM_AVAL_COUNT):   if 76=0 then do;
MPRINT(JM_AVAL_COUNT):   jm_aval_countc = tranwrd(jm_aval_countc,'(.)','(No Data)');
MPRINT(JM_AVAL_COUNT):   jm_aval_countc = tranwrd(jm_aval_countc,'(0.0)','(No Data)');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.COUNT_PREP5.
NOTE: The data set WORK.JM_AVAL_COUNT112 has 48 observations and 18 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Update counts if JM_SMALLN is specified ***;
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_smalln" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_COUNT):  Ending execution.
184        
185        %JM_AVAL_COUNT(JM_INDSN=ADEG_F, jm_var= AVALC , JM_SECONDARY_WHERE= avalc ne "" and aval eq . and  paramn  in (201),
185      ! jm_bign=jm_bign1, jm_trtvarn=trtn,
MLOGIC(JM_AVAL_COUNT):  Beginning execution.
MLOGIC(JM_AVAL_COUNT):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_count.sas
186        jm_block=113, jm_cntvar=usubjid, JM_BYVAR= paramn param avisitn avisit AVALN, JM_FMT=, JM_AVAL_LABEL=%bquote(INTP) );
MLOGIC(JM_AVAL_COUNT):  Parameter JM_INDSN has value ADEG_F
MLOGIC(JM_AVAL_COUNT):  Parameter JM_VAR has value AVALC
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SECONDARY_WHERE has value avalc ne "" and aval eq . and  paramn  in (201)
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BIGN has value jm_bign1
MLOGIC(JM_AVAL_COUNT):  Parameter JM_TRTVARN has value trtn
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BLOCK has value 113
MLOGIC(JM_AVAL_COUNT):  Parameter JM_CNTVAR has value usubjid
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BYVAR has value paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  Parameter JM_FMT has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_AVAL_LABEL has value INTP
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  Parameter JM_SMALLN has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SHOW_PERCENT has value Y
MLOGIC(JM_AVAL_COUNT):  Parameter JM_ONLY_TOTALS has value N
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SHOW_OVERALL_PERCENT has value N
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SIGD has value 1
MLOGIC(JM_AVAL_COUNT):  Parameter JM_BYVARFMT has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_TRTVAR has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_SUBGRP has value 
MLOGIC(JM_AVAL_COUNT):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_COUNT):  Parameter JM_VERSION has value 1.0
MPRINT(JM_AVAL_COUNT):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   JM_SECONDARY_WHERE = symget('JM_SECONDARY_WHERE');
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_INDSN PROCESSED - ADEG_F";
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_CNTVAR PROCESSED - usubjid";
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BIGN PROCESSED - jm_bign1";
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SMALLN PROCESSED - ";
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SECONDARY_WHERE PROCESSED - " JM_SECONDARY_WHERE;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_VAR PROCESSED - AVALC";
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_FMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SHOW_PERCENT PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_ONLY_TOTALS resolves to N
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_ONLY_TOTALS PROCESSED - N";
SYMBOLGEN:  Macro variable JM_SHOW_OVERALL_PERCENT resolves to N
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SHOW_OVERALL_PERCENT PROCESSED - N";
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SIGD PROCESSED - 1";
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_AVAL_LABEL PROCESSED - INTP";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BYVAR PROCESSED - paramn param avisitn avisit AVALN";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BYVARFMT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_BLOCK PROCESSED - 113";
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_TRTVARN PROCESSED - trtn";
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_TRTVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_SUBGRP PROCESSED - ";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_COUNT):   PUT "ALERT:I: JM_VERSION PROCESSED - 1.0";
MPRINT(JM_AVAL_COUNT):   put "********************************************************";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   put 'NOTE: [JM_AVAL_COUNT] is currently running macro %jm_aval_count version 1.1.';
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      186:81   JM_SECONDARY_WHERE

******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - ADEG_F
ALERT:I: JM_CNTVAR PROCESSED - usubjid
ALERT:I: JM_BIGN PROCESSED - jm_bign1
ALERT:I: JM_SMALLN PROCESSED - 
ALERT:I: JM_SECONDARY_WHERE PROCESSED - avalc ne "" and aval eq . and  paramn  in (201)
ALERT:I: JM_VAR PROCESSED - AVALC
ALERT:I: JM_FMT PROCESSED - 
ALERT:I: JM_SHOW_PERCENT PROCESSED - Y
ALERT:I: JM_ONLY_TOTALS PROCESSED - N
ALERT:I: JM_SHOW_OVERALL_PERCENT PROCESSED - N
ALERT:I: JM_SIGD PROCESSED - 1
ALERT:I: JM_AVAL_LABEL PROCESSED - INTP
ALERT:I: JM_BYVAR PROCESSED - paramn param avisitn avisit AVALN
ALERT:I: JM_BYVARFMT PROCESSED - 
ALERT:I: JM_BLOCK PROCESSED - 113
ALERT:I: JM_TRTVARN PROCESSED - trtn
ALERT:I: JM_TRTVAR PROCESSED - 
                                                           The SAS System

ALERT:I: JM_SUBGRP PROCESSED - 
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1.0
********************************************************

NOTE: [JM_AVAL_COUNT] is currently running macro %jm_aval_count version 1.1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Check whether all required parameters (JM_INDSN, JM_CNTVAR, JM_BIGN, JM_VAR, JM_SHOW_PERCENT, 
JM_ONLY_TOTALS , JM_SHOW_OVERALL_PERCENT, JM_SIGD, JM_BLOCK, JM_TRTVARN, JM_DEBUG, JM_VERSION) are not missing. ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   if compress("ADEG_F") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_INDSN is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   if compress("usubjid") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_CNTVAR is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   if compress("jm_bign1") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_BIGN is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put "  ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   if compress("AVALC") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_VAR is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   if compress("Y") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_SHOW_PERCENT is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_ONLY_TOTALS resolves to N
MPRINT(JM_AVAL_COUNT):   if compress("N") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_ONLY_TOTALS is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SHOW_OVERALL_PERCENT resolves to N
MPRINT(JM_AVAL_COUNT):   if compress("N") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_SHOW_OVERALL_PERCENT is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   if compress("1") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_SIGD is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   if compress("113") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_BLOCK is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   if compress("trtn") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_TRTVARN is required. " "Please specify it.";
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_COUNT):   if compress("N") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_DEBUG is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_COUNT):   if compress("1.0") = "" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] Macro parameter JM_VERSION is required. Please specify it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify if Sub Group was applied consistently ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
MPRINT(JM_AVAL_COUNT):   if _n_ = 1 then do;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MPRINT(JM_AVAL_COUNT):   if upcase(jm_subgrp) ne upcase("") and compress(jm_subgrp) ne '' then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] specified JM_SUBGRP=‘’ which is different from JM_SUBGRP=‘" jm_subgrp +(-1) 
'’ specified in %JM_BIGN macro call.';
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Variable jm_subgrp is uninitialized.
NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_SIGD: if it contains characters other than integers ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   JM_SIGD=compress("1");
MPRINT(JM_AVAL_COUNT):   o_jm_sigd = jm_sigd;
MPRINT(JM_AVAL_COUNT):   if JM_SIGD ne '' then do;
MPRINT(JM_AVAL_COUNT):   *** Remove numbers to test ***;
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'1','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'2','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'3','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'4','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'5','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'6','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'7','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'8','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'9','');
MPRINT(JM_AVAL_COUNT):   jm_sigd = tranwrd(jm_sigd,'0','');
MPRINT(JM_AVAL_COUNT):   if compress(jm_sigd) ne '' then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
MPRINT(JM_AVAL_COUNT):   put "ER" "ROR:[jm_aval_count] JM_SIGD: " o_jm_sigd "should be an integer >=0. Please specify proper 
JM_SIGD.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_INDSN exists ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   if exist("ADEG_F") = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR:[jm_aval_count]: Dataset JM_INDSN = ADEG_F does not exist. " "Please specify proper dataset 
in JM_INDSN parameter.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify if the input dataset is empty ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 2658
MLOGIC(JM_AVAL_COUNT):  %IF condition &nobs = 0 is FALSE
MPRINT(JM_AVAL_COUNT):   *** JM_BYVAR=&JM_BYVAR: check whether variables are separated only by blanks. If not, issue er ror 
message. ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   proc contents data = ADEG_F out=v_jm_indsn noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_JM_INDSN has 86 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Verify if JMVAR has a label ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_jm_indsn;
MPRINT(JM_AVAL_COUNT):   length allvars $20000;
MPRINT(JM_AVAL_COUNT):   retain allvars;
MPRINT(JM_AVAL_COUNT):   allvars = strip(upcase(name)) || " " || allvars;
MPRINT(JM_AVAL_COUNT):   call symputx('allvars',allvars);
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   if upcase(name) = upcase("AVALC") then call symputx('jmvar_label',label);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 86 observations read from the data set WORK.V_JM_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Initialize first JM_BYVAR ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is JM_BYVAR1)
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length allvars $20000;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   jm_byvar = upcase(strip("paramn param avisitn avisit AVALN"));
MPRINT(JM_AVAL_COUNT):   *** Remove extra spaces **;
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   allvars = strip(symget('allvars'));
MPRINT(JM_AVAL_COUNT):   if index(allvars,jm_byvar) = 0 then do;
MPRINT(JM_AVAL_COUNT):   if length(compress(jm_byvar)) ne length(jm_byvar) then do;
MPRINT(JM_AVAL_COUNT):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_COUNT):   cnt = 1;
MPRINT(JM_AVAL_COUNT):   do while (space > 0 );
MPRINT(JM_AVAL_COUNT):   curvar = strip(substr(jm_byvar,1,space));
MPRINT(JM_AVAL_COUNT):   jm_byvar = substr(jm_byvar,space+1);
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   *** Hold onto first jm_byvar ***;
MPRINT(JM_AVAL_COUNT):   if cnt = 1 then do;
MPRINT(JM_AVAL_COUNT):   call symputx('jm_byvar1',curvar);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   cnt = cnt + 1;
MPRINT(JM_AVAL_COUNT):   space = index(jm_byvar,' ');
MPRINT(JM_AVAL_COUNT):   if jm_byvar='' then space=0;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(curvar)) = 0 then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Variables in JM_BYVAR=paramn param avisitn avisit AVALN should be 
separated " "only by blanks/spaces. Please specify proper JM_BYVAR.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   space=0;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_BIGN exists ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   if exist("jm_bign1") = 0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Dataset JM_BIGN = jm_bign1 does not exist. " "Please specify proper 
dataset in JM_BIGN parameter.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_SMALLN exists ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MPRINT(JM_AVAL_COUNT):   if compress("") ne '' and exist("") = 0 then do;
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Dataset JM_SMALLN =  does not exist. " "Please specify proper dataset in 
JM_SMALLN parameter.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether &JM_SECONDARY_WHERE contains words IF or WHERE, or starts with parentheses. ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length v_where $400;
MPRINT(JM_AVAL_COUNT):   v_where=upcase(strip(symget('JM_SECONDARY_WHERE')));
MPRINT(JM_AVAL_COUNT):   if index(v_where,"IF ") > 0 or index(v_where,"WHERE ") > 0 or index(v_where,"WHERE(") > 0 or 
substr(v_where,1,1) = '(' then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Macro parameter JM_SECONDARY_WHERE should not contain IF or WHERE, " "and 
shouldn’t start with parentheses. Please remove them." ;
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_INDSN has the following variables: &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR (if it 
was specified), &JM_VAR. ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   JM_CNTVAR=compress(upcase("usubjid"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   JM_VAR=compress(upcase("AVALC"));
MPRINT(JM_AVAL_COUNT):   length allvars $20000;
MPRINT(JM_AVAL_COUNT):   allvars = strip(upcase(symget('allvars')));
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_CNTVAR)) = 0 and JM_CNTVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: " jm_cntvar= "is not in dataset JM_INDSN=ADEG_F." " This variable is 
needed in order for macro to work properly. Please add variable JM_CNTVAR to dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_TRTVARN)) = 0 and JM_TRTVARN ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: " jm_trtvarn= "is not in dataset JM_INDSN=ADEG_F." " This variable is 
needed in order for macro to work properly. Please add variable JM_TRTVARN to dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(upcase("paramn param avisitn avisit AVALN"));
MPRINT(JM_AVAL_COUNT):   *** Remove extra spaces **;
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   jm_byvar = strip(tranwrd(jm_byvar,'  ',' '));
MPRINT(JM_AVAL_COUNT):   *** Handle single valriable ***;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   if jm_byvar = compress(jm_byvar) then do;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_BYVAR)) = 0 and JM_BYVAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_AVAL_COUNT]: " jm_byvar= "is not in dataset JM_INDSN=ADEG_F." " This variable is needed 
in order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   else do;
MPRINT(JM_AVAL_COUNT):   *** Handle multiple variables separated by spaces ***;
MPRINT(JM_AVAL_COUNT):   do while((index(jm_byvar,' ') > 0) and compress(jm_byvar) ne '');
MPRINT(JM_AVAL_COUNT):   curvar = substr(jm_byvar,1,index(jm_byvar,' '));
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(curvar)) = 0 then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_AVAL_COUNT]: " curvar "is not in dataset JM_INDSN=ADEG_F." " This variable is needed in 
order for macro to work properly. Please add variable JM_BYVAR to " " dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   jm_byvar = substr(jm_byvar,index(jm_byvar,' ')+1);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   if index(allvars,compress(JM_VAR)) = 0 and JM_VAR ne '' then do;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: " jm_var= "is not in dataset JM_INDSN=ADEG_F." " This variable is needed 
in order for macro to work properly. Please add variable JM_VAR to dataset JM_INDSN=ADEG_F.  ";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check whether dataset &JM_INDSN has any duplicates for &JM_CNTVAR/ &JM_TRTVARN/ &JM_BYVAR combination. 
***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   JM_CNTVAR=compress(upcase("usubjid"));
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN=compress(upcase("trtn"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   JM_BYVAR=compress(upcase("paramn param avisitn avisit AVALN"));
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   if (JM_CNTVAR ne '' and (JM_CNTVAR=JM_TRTVARN or JM_CNTVAR=JM_BYVAR)) or (JM_TRTVARN ne '' and 
(JM_TRTVARN=JM_CNTVAR or JM_TRTVARN=JM_BYVAR)) or (JM_BYVAR ne '' and (JM_BYVAR=JM_TRTVARN or JM_BYVAR=JM_CNTVAR)) then do;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: in dataset JM_INDSN=ADEG_F, there are duplicates for JM_CNTVAR/ 
JM_TRTVARN/ paramn param avisitn avisit AVALN combination. " "Please remove these duplicates." ;
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify when JM_BIGN is empty or missing ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is CHECKBIG)
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
MPRINT(JM_AVAL_COUNT):   retain checkbig 0;
MPRINT(JM_AVAL_COUNT):   if jm_aval_bign ne . then checkbig=checkbig+jm_aval_bign;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   call symputx('checkbig',checkbig);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 76
MPRINT(JM_AVAL_COUNT):   if 76=0 then do;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: contains empty or missing values for " "BIGN in dataset 'jm_bign1'. " 
"This may result in missing percentage summaries.";
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Update the label of BIGN for empty cases ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 76
MLOGIC(JM_AVAL_COUNT):  %IF condition &checkbig=0 is FALSE
MPRINT(JM_AVAL_COUNT):   *** JM_TRTVARN+JM_TRTVAR should be the same in all other related datasets. ***;
MPRINT(JM_AVAL_COUNT):   *** Check JM_TRTVARN: If JM_TRTVARN in &JM_INDSN has values which are not in any of the JM_BIGNxx datasets 
***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_INDSN" ne "" and "&JM_BIGN" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data v_jm_bign1;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   if trtn = . then trtn = jm_trtvarn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
                                                           The SAS System

NOTE: The data set WORK.V_JM_BIGN1 has 4 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   proc sql;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   create table v_jm_indsn as select distinct trtn from ADEG_F;
NOTE: Table WORK.V_JM_INDSN created, with 4 rows and 1 columns.

SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   create table v_jm_bign as select distinct trtn from v_jm_bign1;
NOTE: Table WORK.V_JM_BIGN created, with 4 rows and 1 columns.

MPRINT(JM_AVAL_COUNT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   proc sort data = v_jm_indsn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   proc sort data = v_jm_bign;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data v_jm_trtvarn;
MPRINT(JM_AVAL_COUNT):   merge v_jm_indsn (in=A) v_jm_bign (in=B);
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   if (A) and not(B) then do;
MPRINT(JM_AVAL_COUNT):   output;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.V_JM_INDSN.
NOTE: There were 4 observations read from the data set WORK.V_JM_BIGN.
NOTE: The data set WORK.V_JM_TRTVARN has 0 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is TRTLIST)
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_jm_trtvarn;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   curvar = trtn;
MPRINT(JM_AVAL_COUNT):   length trtlist $300;
MPRINT(JM_AVAL_COUNT):   retain trtlist;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   trtlist = strip(trtlist) || " " || strip(put(trtn,best.));
MPRINT(JM_AVAL_COUNT):   call symputx('trtlist',trtlist);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 0 observations read from the data set WORK.V_JM_TRTVARN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable TRTLIST resolves to none
MLOGIC(JM_AVAL_COUNT):  %IF condition "&trtlist" ne "none" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_TRTVAR in &JM_INDSN is different from JM_TRTVAR in ( JM_BIGNxx, JM_AVAL_SUMxx, 
                                                           The SAS System

JM_AVAL_COUNTxx) for the same JM_TRTVARN ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   retain vdatcnt 0;
MPRINT(JM_AVAL_COUNT):   set sashelp.vstable;
MPRINT(JM_AVAL_COUNT):   where libname = "WORK" and ( index(memname,"JM_BIGN")=1 or index(memname,"JM_AVAL_SUM")=1 or 
index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_COUNT):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_COUNT):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_COUNT):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 11 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_BIGN')=1) or (INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 
      'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.04 seconds
      

SYMBOLGEN:  Macro variable VDATCNT resolves to 11
MLOGIC(JM_AVAL_COUNT):  %DO loop beginning; index variable I; start value is 1; stop value is 11; by value is 1.  
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_COUNT112
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_COUNT112
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_COUNT112
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM101
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM101
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM101
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM102
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM102
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM102
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM103
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM103
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM103
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM104
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM104
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM104
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM105
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM105
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM105
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 7; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM106
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM106
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM106
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 8; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM107
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM107
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM107
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
                                                           The SAS System

MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 9; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable VDAT9 resolves to JM_AVAL_SUM108
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM108
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM108
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 10; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable VDAT10 resolves to JM_AVAL_SUM109
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_AVAL_SUM109
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_AVAL_SUM109
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 11; loop will iterate again.
MLOGIC(V_JM_TRTVAR):  Beginning execution.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 11
SYMBOLGEN:  Macro variable VDAT11 resolves to JM_BIGN1
MLOGIC(V_JM_TRTVAR):  Parameter COMPDAT has value JM_BIGN1
MPRINT(V_JM_TRTVAR):   *** Only perform this verificaton if optional JM_TRTVAR is specified ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable COMPDAT resolves to JM_BIGN1
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(V_JM_TRTVAR):  %IF condition "&JM_INDSN" ne "" and "&compdat" ne "" and "&jm_trtvar" ne "" is FALSE
MLOGIC(V_JM_TRTVAR):  Ending execution.
MPRINT(JM_AVAL_COUNT):  ;
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 12; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_AVAL_LABEL was populated: macro will check JM_AVAL_LABEL in other related datasets - 
JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_AVAL_LABEL" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   retain vdatcnt 0;
MPRINT(JM_AVAL_COUNT):   set sashelp.vstable;
MPRINT(JM_AVAL_COUNT):   where libname = "WORK" and ( index(memname,"JM_AVAL_SUM")=1 or index(memname,"JM_AVAL_COUNT")=1 );
MPRINT(JM_AVAL_COUNT):   vdatcnt = vdatcnt + 1;
MPRINT(JM_AVAL_COUNT):   call symputx(compress('vdat'|| put(vdatcnt,best.)),memname);
MPRINT(JM_AVAL_COUNT):   call symputx('vdatcnt',vdatcnt);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: SAS threaded sort was used.
NOTE: There were 10 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and ((INDEX(memname, 'JM_AVAL_SUM')=1) or (INDEX(memname, 'JM_AVAL_COUNT')=1));
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
      cpu time            0.07 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Verify labels for all datsets ***;
SYMBOLGEN:  Macro variable VDATCNT resolves to 10
MLOGIC(JM_AVAL_COUNT):  %DO loop beginning; index variable I; start value is 1; stop value is 10; by value is 1.  
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_COUNT112
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_COUNT112;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 48 observations read from the data set WORK.JM_AVAL_COUNT112.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable VDAT1 resolves to JM_AVAL_COUNT112
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_COUNT112]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 2; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM101;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable VDAT2 resolves to JM_AVAL_SUM101
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM101]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 3; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM102;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable VDAT3 resolves to JM_AVAL_SUM102
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM102]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 4; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM103;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable VDAT4 resolves to JM_AVAL_SUM103
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM103]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 5; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM104;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable VDAT5 resolves to JM_AVAL_SUM104
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM104]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 6; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM105;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable VDAT6 resolves to JM_AVAL_SUM105
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM105]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 7; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM106;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable VDAT7 resolves to JM_AVAL_SUM106
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM106]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 8; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM107;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable VDAT8 resolves to JM_AVAL_SUM107
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM107]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 9; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable VDAT9 resolves to JM_AVAL_SUM108
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM108;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM108.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable VDAT9 resolves to JM_AVAL_SUM108
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM108]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 10; loop will iterate again.
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length jm_aval_label $2000;
MPRINT(JM_AVAL_COUNT):   jm_aval_label = ' ';
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable VDAT10 resolves to JM_AVAL_SUM109
MPRINT(JM_AVAL_COUNT):   set JM_AVAL_SUM109;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = "INTP" then call symput('vlabel','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM109.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable VLABEL resolves to no
MPRINT(JM_AVAL_COUNT):   if "no" = "yes" then do;
MPRINT(JM_AVAL_COUNT):   put ' ';
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable VDAT10 resolves to JM_AVAL_SUM109
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_AVAL_LABEL should be used only once across all JM_AVAL_SUMxx and " 
"JM_AVAL_COUNTxx datasets. However, you specified JM_AVAL_LABEL=INTP, which already " "exists in dataset [JM_AVAL_SUM109]. Please 
specify a different label in JM_AVAL_LABEL.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %DO loop index variable I is now 11; loop will not iterate again.
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Macro will check JM_AVAL_LABEL in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any 
of them have the same JM_AVAL_LABEL ***;
SYMBOLGEN:  Macro variable JMVAR_LABEL resolves to Analysis Value (C)
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jmvar_label" ne "" and "&JM_AVAL_LABEL" = "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_BLOCK: if it’s not numeric ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_block" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   v_block = input("113",best.);
MPRINT(JM_AVAL_COUNT):   if v_block = . then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: Macro parameter JM_BLOCK=113 should be a number, please correct it.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_BLOCK in other related datasets - JM_AVAL_SUMxx, JM_AVAL_COUNTxx, and if any of them have the 
same JM_BLOCK ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   if compress("113") ne '' then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   if exist("JM_AVAL_SUM113") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=113, which already " "exists in dataset(s) [JM_AVAL_SUM113]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   if exist("JM_AVAL_COUNT113") then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_BLOCK should be used only once across all JM_AVAL_SUMxx " "and 
JM_AVAL_COUNTxx datasets. However, you specified JM_BLOCK=113, which already " "exists in dataset(s) [JM_AVAL_COUNT113]. Please 
specify a different block number in JM_BLOCK.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_DEBUG: if it’s not Y or N **;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_COUNT):   jm_debug=compress("N");
MPRINT(JM_AVAL_COUNT):   if jm_debug ne '' and upcase(jm_debug) not in('Y','N') then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_DEBUG should be either Y or N. Please specify proper JM_DEBUG.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check JM_VERSION: if it contains characters other than numbers or periods ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1.0
MPRINT(JM_AVAL_COUNT):   jm_version=compress("1.0");
MPRINT(JM_AVAL_COUNT):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_COUNT):   *** Remove numbers and periods to verify ***;
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'1','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'2','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'3','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'4','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'5','');
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'6','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'7','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'8','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'9','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'0','');
MPRINT(JM_AVAL_COUNT):   jm_version = tranwrd(jm_version,'.','');
MPRINT(JM_AVAL_COUNT):   if compress(jm_version) ne '' then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_VERSION should be a number >0. Please specify proper JM_VERSION.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_SHOW_PERCENT: if it’s not Y or N ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   jm_show_percent=compress("Y");
MPRINT(JM_AVAL_COUNT):   if jm_show_percent ne '' and upcase(jm_show_percent) not in('Y','N') then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_SHOW_PERCENT should be either Y or N. " "Please specify proper 
JM_SHOW_PERCENT.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_SHOW_OVERALL_PERCENT: if it’s not Y or N ***;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SHOW_OVERALL_PERCENT resolves to N
MPRINT(JM_AVAL_COUNT):   jm_show_overall_percent=compress("N");
MPRINT(JM_AVAL_COUNT):   if jm_show_overall_percent ne '' and upcase(jm_show_overall_percent) not in('Y','N') then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_SHOW_OVERALL_PERCENT should be either Y or N. " "Please specify proper 
JM_SHOW_OVERALL_PERCENT.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Check &JM_ONLY_TOTALS: if it’s not Y or N ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_ONLY_TOTALS resolves to N
MPRINT(JM_AVAL_COUNT):   JM_ONLY_TOTALS=compress("N");
MPRINT(JM_AVAL_COUNT):   if JM_ONLY_TOTALS ne '' and upcase(JM_ONLY_TOTALS) not in('Y','N') then do;
MPRINT(JM_AVAL_COUNT):   put 'ER' "ROR: [jm_aval_count]: JM_ONLY_TOTALS should be either Y or N. " "Please specify proper 
JM_ONLY_TOTALS.";
MPRINT(JM_AVAL_COUNT):   put " ";
MPRINT(JM_AVAL_COUNT):   call symput('_err','yes');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_err" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition &JM_BYVARFMT. EQ is TRUE
MLOGIC(JM_AVAL_COUNT):  %PUT "ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
"ALERT:I: GROUP FMT IS NOT PASSED TO THE MACRO"
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   *** Handle case where JM_SECONDARY_WHERE contains double quotes ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length curwhere $400;
MPRINT(JM_AVAL_COUNT):   curwhere = symget('JM_SECONDARY_WHERE');
MPRINT(JM_AVAL_COUNT):   if index(curwhere,'"') > 0 then do;
MPRINT(JM_AVAL_COUNT):   curwhere=strip(tranwrd(curwhere,'"',"'"));
MPRINT(JM_AVAL_COUNT):   call symputx('JM_SECONDARY_WHERE',curwhere);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Create a dataset which defines the grouping variable and apply formats ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   data ADEG_F_113;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   set ADEG_F;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   trtVAR= trtn;
MPRINT(JM_AVAL_COUNT):   _count=1;
MPRINT(JM_AVAL_COUNT):   *** Assign grouping variable ***;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   grpvar=AVALC;
MPRINT(JM_AVAL_COUNT):   length grplabel $200;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   grplabel=VLABEL(AVALC);
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   box=VLABEL(AVALC);
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition &JM_FMT. NE is FALSE
MPRINT(JM_AVAL_COUNT):   *** Apply treatment format to treatment variable ***;
MPRINT(JM_AVAL_COUNT):   format TRTVAR trt.;
MPRINT(JM_AVAL_COUNT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      186:155  box
NOTE: There were 2658 observations read from the data set WORK.ADEG_F.
                                                           The SAS System

NOTE: The data set WORK.ADEG_F_113 has 2658 observations and 91 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Merge dataset &JM_INDSN with dataset &JM_BIGN (from dataset &JM_BIGN, keep only variables JM_TRTVARN 
and JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   proc sort data = ADEG_F out=cur_ADEG_F;
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MLOGIC(JM_AVAL_COUNT):  %IF condition %upcase("&jm_cntvar") = %upcase("&jm_var") is FALSE
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   by trtn usubjid AVALC ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 2658 observations read from the data set WORK.ADEG_F.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_ADEG_F has 2658 observations and 86 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Set the user specified treatment numeric variable ***;
MPRINT(JM_AVAL_COUNT):   data cur_jm_bign2;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   set jm_bign1;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   trtn = jm_trtvarn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: The data set WORK.CUR_JM_BIGN2 has 4 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   proc sort data = cur_jm_bign2 out=cur_jm_bign1;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN2.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_JM_BIGN1 has 4 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Verify what variables exists in BIGN ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   proc contents data = cur_jm_bign1 out=v_bign noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_BIGN has 7 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_WHERE)
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_CNTVAR)
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_VAR)
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is V_JM_TRTVAR)
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_bign;
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "JM_BIGN_WHERE" then call symputx('v_where','yes');
SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "usubjid" then call symputx('v_cntvar','yes');
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "AVALC" then call symputx('v_var','yes');
MPRINT(JM_AVAL_COUNT):   if upcase(name) = "JM_TRTVAR" then call symputx('v_jm_trtvar','yes');
MPRINT(JM_AVAL_COUNT):   run;

                                                           The SAS System

NOTE: There were 7 observations read from the data set WORK.V_BIGN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable V_JM_TRTVAR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_jm_trtvar" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   data count_prep1;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
SYMBOLGEN:  Macro variable V_WHERE resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_where" = "yes" is FALSE
SYMBOLGEN:  Macro variable V_CNTVAR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_cntvar" = "yes" is FALSE
SYMBOLGEN:  Macro variable V_VAR resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&v_var" = "yes" is FALSE
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   merge cur_jm_bign1 (keep = trtn in=B) cur_ADEG_F (in=A);
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   by trtn;
MPRINT(JM_AVAL_COUNT):   *** Create a local macro variable &JM_BIGN_WHERE, equal to JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_COUNT):   call symputx ('jm_bign_where',jm_bign_where);
MPRINT(JM_AVAL_COUNT):   *** Keep only JM_TRTVARN which are in dataset &JM_INDSN. Note: since we decided *not* to make macro 
parameter %JM_TRTFMT required, we can’t produce missing statistics for JM_TRTVARN which are not in &JM_INDSN but are in JM_BIGN. 
***;
MPRINT(JM_AVAL_COUNT):   length jm_trtvarn 8;
MPRINT(JM_AVAL_COUNT):   if (A) then do;
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN=trtn;
MPRINT(JM_AVAL_COUNT):   output;
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN1.
NOTE: There were 2658 observations read from the data set WORK.CUR_ADEG_F.
NOTE: The data set WORK.COUNT_PREP1 has 2658 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_COUNT):   *** Set where clause to missing if it is ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   length curwhere $200;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MPRINT(JM_AVAL_COUNT):   curwhere = strip("");
MPRINT(JM_AVAL_COUNT):   if curwhere = '.' then curwhere = '';
MPRINT(JM_AVAL_COUNT):   call symputx('JM_BIGN_WHERE',curwhere);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Subset &JM_INDSN by condition &JM_BIGN_WHERE. ***;
MPRINT(JM_AVAL_COUNT):   data count_prep2;
MPRINT(JM_AVAL_COUNT):   set count_prep1;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_bign_where" ne "" and "&jm_bign_where" ne "." is FALSE
MPRINT(JM_AVAL_COUNT):   *** If &JM_SECONDARY_WHERE is not blank then subset dataset &JM_INDSN by &JM_SECONDARY_WHERE ***;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MPRINT(JM_AVAL_COUNT):   if avalc ne '' and aval eq . and paramn in (201) then output;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 2658 observations read from the data set WORK.COUNT_PREP1.
NOTE: The data set WORK.COUNT_PREP2 has 372 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** If &JM_BYVAR was specified then sort &JM_INDSN by &JM_BYVAR.***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep2;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   by paramn param avisitn avisit AVALN;
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 372 observations read from the data set WORK.COUNT_PREP2.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP2 has 372 observations and 88 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** If &JM_BLOCK has decimals then macro will convert decimals to underscores ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   if index("113",'.') > 0 then do;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   jm_block = tranwrd("113",'.','_');
MPRINT(JM_AVAL_COUNT):   call symputx('jm_block',jm_block);
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      186:159  jm_block
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Capture the value of the formats in order to fill in missing values ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_fmt" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Verify the variable type of JM_BIGN_WHERE ***;
MPRINT(JM_AVAL_COUNT):   proc contents data = count_prep2 varnum out=v_bign_where noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_BIGN_WHERE has 88 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is _VARTYPE)
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_bign_where;
MPRINT(JM_AVAL_COUNT):   where upcase(name) = 'JM_BIGN_WHERE';
MPRINT(JM_AVAL_COUNT):   if type = 1 then call symputx('_vartype','num');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 1 observations read from the data set WORK.V_BIGN_WHERE.
      WHERE UPCASE(name)='JM_BIGN_WHERE';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Calculate counts for &JM_CNTVAR, &JM_TRTVARN, &JM_BYVAR, &JM_VAR (all sub-categories), ***;
MPRINT(JM_AVAL_COUNT):   *** Final dataset created by macro – will be JM_AVAL_COUNT&JM_BLOCK ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   data JM_AVAL_COUNT113;
SYMBOLGEN:  Macro variable _VARTYPE resolves to num
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_vartype" = "num" is TRUE
MPRINT(JM_AVAL_COUNT):   set count_prep2 (rename=jm_bign_where=_jm_bign_where) ;
MPRINT(JM_AVAL_COUNT):   *** Add logic here to check for JM_BIGN_WHERE type char ***;
SYMBOLGEN:  Macro variable _VARTYPE resolves to num
MLOGIC(JM_AVAL_COUNT):  %IF condition "&_vartype" = "num" is TRUE
MPRINT(JM_AVAL_COUNT):   length jm_bign_where $200;
MPRINT(JM_AVAL_COUNT):   if _jm_bign_where = . then jm_bign_where = '';
MPRINT(JM_AVAL_COUNT):   else jm_bign_where = put(_jm_bign_where,best.);
MPRINT(JM_AVAL_COUNT):   drop _jm_bign_where;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 372 observations read from the data set WORK.COUNT_PREP2.
NOTE: The data set WORK.JM_AVAL_COUNT113 has 372 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Sort the dataset by key fields and remove duplicates ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   PROC SORT DATA=ADEG_F_113 NODUPKEY;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_CNTVAR resolves to usubjid
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
SYMBOLGEN:  Macro variable JM_TRTVARN resolves to trtn
MPRINT(JM_AVAL_COUNT):   BY AVALC usubjid paramn param avisitn avisit AVALN trtn;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MPRINT(JM_AVAL_COUNT):   WHERE avalc ne '' and aval eq . and paramn in (201);
MPRINT(JM_AVAL_COUNT):   RUN;

NOTE: There were 372 observations read from the data set WORK.ADEG_F_113.
      WHERE (avalc not = ' ') and (aval=.) and (paramn=201);
NOTE: SAS sort was used.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.ADEG_F_113 has 372 observations and 91 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LOCAL  JM_VAR_TYPE
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is JM_VAR_TYPE)
MPRINT(JM_AVAL_COUNT):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_VAR resolves to AVALC
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
MPRINT(JM_AVAL_COUNT):   select upcase((type)) into : JM_VAR_type from sashelp.vcolumn where libname = "WORK" and upcase(name) = 
upcase("AVALC") and upcase(memname) = "ADEG_F" ;
MPRINT(JM_AVAL_COUNT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_COUNT):  %PUT JM_VAR_type=&JM_VAR_type
SYMBOLGEN:  Macro variable JM_VAR_TYPE resolves to CHAR
JM_VAR_type=CHAR
MPRINT(JM_AVAL_COUNT):   *** Capture the number of observations from the dataset ***;
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is DSID)
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_COUNT):  %IF condition &DSID > 0 is TRUE
MLOGIC(JM_AVAL_COUNT):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
MPRINT(JM_AVAL_COUNT):   *** Only perform summary statistics if dataset has values ***;
SYMBOLGEN:  Macro variable NOBS resolves to 372
MLOGIC(JM_AVAL_COUNT):  %IF condition &NOBS > 0 is TRUE
MPRINT(JM_AVAL_COUNT):   *** Apply the format if specified ***;
SYMBOLGEN:  Macro variable JM_FMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition %length(&JM_FMT)>0 is FALSE
MPRINT(JM_AVAL_COUNT):   *** Subset by condition &JM_BIGN_WHERE. ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   data ADEG_F_113 ;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   set ADEG_F_113 ;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_bign_where" ne "" and "&jm_bign_where" ne "." is FALSE
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 372 observations read from the data set WORK.ADEG_F_113.
NOTE: The data set WORK.ADEG_F_113 has 372 observations and 91 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   proc sort data = ADEG_F_113 ;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   BY paramn param avisitn avisit AVALN GRPLABEL;
MPRINT(JM_AVAL_COUNT):   run;

                                                           The SAS System

NOTE: There were 372 observations read from the data set WORK.ADEG_F_113.
NOTE: SAS sort was used.
NOTE: The data set WORK.ADEG_F_113 has 372 observations and 91 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Identify if variable has format ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   proc contents data = ADEG_F_113 out=v_hasfmt noprint;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: The data set WORK.V_HASFMT has 91 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_AVAL_COUNT):  %LET (variable name is HASFMT)
MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_hasfmt;
MPRINT(JM_AVAL_COUNT):   where upcase(name) = "GRPVAR";
MPRINT(JM_AVAL_COUNT):   if format ne '' then call symputx('hasfmt','yes');
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 1 observations read from the data set WORK.V_HASFMT.
      WHERE UPCASE(name)='GRPVAR';
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Process case with formated JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to ADEG_F
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MPRINT(JM_AVAL_COUNT):   PROC MEANS DATA = ADEG_F_113 (where = ( avalc ne '' and aval eq . and paramn in (201) ) ) completetypes 
                                                           The SAS System

nway NOPRINT;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   BY paramn param avisitn avisit AVALN GRPLABEL;
SYMBOLGEN:  Macro variable HASFMT resolves to no
MLOGIC(JM_AVAL_COUNT):  %IF condition "&hasfmt" = "yes" is FALSE
MPRINT(JM_AVAL_COUNT):   CLASS TRTVAR GRPVAR/MLF ;
MPRINT(JM_AVAL_COUNT):   VAR _count;
MPRINT(JM_AVAL_COUNT):   OUTPUT OUT = count_prep4 (drop=_freq_ ) N=JM_AVAL_COUNT;
MPRINT(JM_AVAL_COUNT):   RUN;

NOTE: There were 372 observations read from the data set WORK.ADEG_F_113.
      WHERE (avalc not = ' ') and (aval=.) and (paramn=201);
NOTE: The data set WORK.COUNT_PREP4 has 41 observations and 10 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Impute the significant ditit ***;
MPRINT(JM_AVAL_COUNT):   data _null_;
SYMBOLGEN:  Macro variable JM_SIGD resolves to 1
MPRINT(JM_AVAL_COUNT):   JM_SIGD = 1;
MPRINT(JM_AVAL_COUNT):   part1 = 3+jm_sigd;
MPRINT(JM_AVAL_COUNT):   part2 =jm_sigd;
MPRINT(JM_AVAL_COUNT):   sigfmt = strip(put(part1,best.)) || "." || strip(put(part2,best.));
MPRINT(JM_AVAL_COUNT):   call symputx('sigfmt',sigfmt);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_aval_label" = "" is FALSE
MPRINT(JM_AVAL_COUNT):   proc format library=work cntlout=rfmt;
MPRINT(JM_AVAL_COUNT):   run;

                                                           The SAS System

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
NOTE: The data set WORK.RFMT has 387 observations and 21 variables.

SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" and "&jm_byvarfmt" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   data count_prep4a;
MPRINT(JM_AVAL_COUNT):   set count_prep4;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP4.
NOTE: The data set WORK.COUNT_PREP4A has 41 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Calculate total count if JM_BYVAR is specified ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   data count_prep4b;
MPRINT(JM_AVAL_COUNT):   set count_prep4;
MPRINT(JM_AVAL_COUNT):   where _type_ in(2,3);
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP4.
      WHERE _type_ in (2, 3);
NOTE: The data set WORK.COUNT_PREP4B has 41 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep4b;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   by paramn param avisitn avisit AVALN _type_ trtvar grpvar jm_aval_count;
MPRINT(JM_AVAL_COUNT):   run;

                                                           The SAS System

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP4B.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP4B has 41 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data count_prep4c;
MPRINT(JM_AVAL_COUNT):   set count_prep4b;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MPRINT(JM_AVAL_COUNT):   by paramn param avisitn avisit AVALN _type_ trtvar grpvar jm_aval_count;
MPRINT(JM_AVAL_COUNT):   retain order 0;
MPRINT(JM_AVAL_COUNT):   if _type_ = 2 then JM_AVAL_NAMEN = -99;
MPRINT(JM_AVAL_COUNT):   if _type_ = 3 then do;
MPRINT(JM_AVAL_COUNT):   *** if first.&jm_trtvarn. then do;
MPRINT(JM_AVAL_COUNT):   *** order = 1;
MPRINT(JM_AVAL_COUNT):   *** end;
MPRINT(JM_AVAL_COUNT):   *** else do;
MPRINT(JM_AVAL_COUNT):   *** order = order + 1;
MPRINT(JM_AVAL_COUNT):   *** end;
MPRINT(JM_AVAL_COUNT):   order = order + 1;
MPRINT(JM_AVAL_COUNT):   JM_AVAL_NAMEN = order;
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_trtvar" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   drop order _type_;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP4B.
NOTE: The data set WORK.COUNT_PREP4C has 41 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data count_prep4;
MPRINT(JM_AVAL_COUNT):   set count_prep4c;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP4C.
                                                           The SAS System

NOTE: The data set WORK.COUNT_PREP4 has 41 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Capture the format order for JM_AVAL_NAMEN ***;
MPRINT(JM_AVAL_COUNT):   proc format library=work cntlout=v_fmt3;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
NOTE: The data set WORK.V_FMT3 has 387 observations and 21 variables.

MPRINT(JM_AVAL_COUNT):   proc sort data = v_fmt3;
MPRINT(JM_AVAL_COUNT):   by fmtname start label;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 387 observations read from the data set WORK.V_FMT3.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_FMT3 has 387 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   data _null_;
MPRINT(JM_AVAL_COUNT):   set v_fmt3;
MPRINT(JM_AVAL_COUNT):   by fmtname start label;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MPRINT(JM_AVAL_COUNT):   curfmt = upcase("");
MPRINT(JM_AVAL_COUNT):   curfmt = tranwrd(curfmt,'.','');
MPRINT(JM_AVAL_COUNT):   *** Handle case when no JM_BYFARFMT was specified ***;
SYMBOLGEN:  Macro variable JM_AVAL_LABEL resolves to INTP
SYMBOLGEN:  Some characters in the above value which were subject to macro quoting have been unquoted for printing.
MPRINT(JM_AVAL_COUNT):   if compress(curfmt) = '' then call symputx('namen',"INTP");
MPRINT(JM_AVAL_COUNT):   if curfmt = fmtname and first.fmtname then call symputx('namen',label);
MPRINT(JM_AVAL_COUNT):   run;

                                                           The SAS System

NOTE: There were 387 observations read from the data set WORK.V_FMT3.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Sort data in order to have group totals appear first for total counts ***;
MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep4;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   by trtvar grpvar ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP4.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP4 has 41 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_COUNT):   proc sort data = cur_jm_bign1;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   by trtvar;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN1.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_JM_BIGN1 has 4 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Calculate JM_AVAL_COUNTC ***;
MPRINT(JM_AVAL_COUNT):   data count_prep5;
MPRINT(JM_AVAL_COUNT):   length JM_AVAL_LABEL JM_AVAL_COUNTC JM_AVAL_NAMEC $2000 JM_BLOCK $10 JM_BIGN_WHERE $200;
SYMBOLGEN:  Macro variable JM_BIGN resolves to jm_bign1
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
                                                           The SAS System

MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   merge count_prep4 (in=A) cur_jm_bign1 (keep= trtvar jm_aval_bign );
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   by trtvar;
MPRINT(JM_AVAL_COUNT):   retain namen 0;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MPRINT(JM_AVAL_COUNT):   JM_BIGN_WHERE = "";
MPRINT(JM_AVAL_COUNT):   JM_TRTVARN = input(put(trtvar,$trtc.),best.);
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   JM_BLOCK = strip("113");
MPRINT(JM_AVAL_COUNT):   jm_aval_label = strip(symget('jm_aval_label'));
MPRINT(JM_AVAL_COUNT):   if jm_aval_label = '' then jm_aval_label = grplabel;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   if jm_aval_count = 0 then percent = 0;
MPRINT(JM_AVAL_COUNT):   else do;
MPRINT(JM_AVAL_COUNT):   if jm_aval_bign = 0 then percent = 0;
MPRINT(JM_AVAL_COUNT):   else percent = (jm_aval_count/jm_aval_bign)*100;
MPRINT(JM_AVAL_COUNT):   end;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   if upcase("Y") = "N" then JM_AVAL_COUNTC = strip(put(jm_aval_count,best.));
SYMBOLGEN:  Macro variable SIGFMT resolves to 4.1
MPRINT(JM_AVAL_COUNT):   else JM_AVAL_COUNTC = strip(put(jm_aval_count,best.)) || " (" || strip(put(percent,4.1)) || ')';
MPRINT(JM_AVAL_COUNT):   if jm_aval_count = 0 then do;
SYMBOLGEN:  Macro variable JM_SHOW_PERCENT resolves to Y
MPRINT(JM_AVAL_COUNT):   if upcase("Y") = "N" then jm_aval_countc = "0";
MPRINT(JM_AVAL_COUNT):   else jm_aval_countc = "0 (0)";
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   drop percent;
MPRINT(JM_AVAL_COUNT):   *** Assign format if specified ***;
SYMBOLGEN:  Macro variable JM_BYVARFMT resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_BYVARFMT" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Handle multiple JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_BYVAR1 resolves to PARAMN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar1" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   *** Assign label with proper BY variable ***;
SYMBOLGEN:  Macro variable JM_BYVAR1 resolves to PARAMN
MPRINT(JM_AVAL_COUNT):   if JM_AVAL_NAMEN = -99 then JM_AVAL_NAMEC = strip(PARAMN);
SYMBOLGEN:  Macro variable JM_BYVAR1 resolves to PARAMN
MPRINT(JM_AVAL_COUNT):   else JM_AVAL_NAMEC = "   " || strip(PARAMN);
                                                           The SAS System

MPRINT(JM_AVAL_COUNT):   *** Assign JM_BIGN_WHERE (=&JM_BIGN_WHERE) ***;
SYMBOLGEN:  Macro variable JM_BIGN_WHERE resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_BIGN_WHERE" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Assign JM_SECONDARY_WHERE (=&JM_SECONDARY_WHERE ) ***;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_SECONDARY_WHERE" ne "" is TRUE
MPRINT(JM_AVAL_COUNT):   length JM_SECONDARY_WHERE $200;
SYMBOLGEN:  Macro variable JM_SECONDARY_WHERE resolves to avalc ne '' and aval eq . and  paramn  in (201)
MPRINT(JM_AVAL_COUNT):   JM_SECONDARY_WHERE = "avalc ne '' and aval eq . and  paramn  in (201)";
MPRINT(JM_AVAL_COUNT):   *** Assign JM_TRTVAR (=&JM_TRTVAR ) ***;
SYMBOLGEN:  Macro variable JM_TRTVAR resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&JM_TRTVAR" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   if (A);
SYMBOLGEN:  Macro variable JM_BYVAR resolves to paramn param avisitn avisit AVALN
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_byvar" = "" is FALSE
MPRINT(JM_AVAL_COUNT):   drop grplabel namen percent ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      186:1   186:1   
NOTE: There were 41 observations read from the data set WORK.COUNT_PREP4.
NOTE: There were 4 observations read from the data set WORK.CUR_JM_BIGN1.
NOTE: The data set WORK.COUNT_PREP5 has 41 observations and 17 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Sort the data by treament and then JMAVAL_NAMEN ***;
MPRINT(JM_AVAL_COUNT):   proc sort data = count_prep5;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   by JM_AVAL_NAMEN JM_AVAL_NAMEC JM_TRTVARN ;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP5.
NOTE: SAS sort was used.
NOTE: The data set WORK.COUNT_PREP5 has 41 observations and 17 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_COUNT):   *** Generate the final output dataset ***;
SYMBOLGEN:  Macro variable JM_BLOCK resolves to 113
MPRINT(JM_AVAL_COUNT):   data JM_AVAL_COUNT113;
MPRINT(JM_AVAL_COUNT):   length JM_TYPE $20;
MPRINT(JM_AVAL_COUNT):   set count_prep5;
MPRINT(JM_AVAL_COUNT):   JM_TYPE = 'COUNT';
MPRINT(JM_AVAL_COUNT):   *** Handle case of empty of missing BIGN ***;
SYMBOLGEN:  Macro variable CHECKBIG resolves to 76
MPRINT(JM_AVAL_COUNT):   if 76=0 then do;
MPRINT(JM_AVAL_COUNT):   jm_aval_countc = tranwrd(jm_aval_countc,'(.)','(No Data)');
MPRINT(JM_AVAL_COUNT):   jm_aval_countc = tranwrd(jm_aval_countc,'(0.0)','(No Data)');
MPRINT(JM_AVAL_COUNT):   end;
MPRINT(JM_AVAL_COUNT):   run;

NOTE: There were 41 observations read from the data set WORK.COUNT_PREP5.
NOTE: The data set WORK.JM_AVAL_COUNT113 has 41 observations and 18 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_COUNT):   *** Update counts if JM_SMALLN is specified ***;
SYMBOLGEN:  Macro variable JM_SMALLN resolves to 
MLOGIC(JM_AVAL_COUNT):  %IF condition "&jm_smalln" ne "" is FALSE
MPRINT(JM_AVAL_COUNT):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_COUNT):  Ending execution.
187        
188        *------------------------------------------------------------------------------------------------------------------------
188      ! ----------;
189        
190        *  SET THE DATASETS
191        *------------------------------------------------------------------------------------------------------------------------
191      ! ----------;
192        
193        %JM_AVAL_ALLDATA (JM_OUTDSN=JM_AVAL_ALLDATA1);
MLOGIC:  Beginning compilation of JM_AVAL_ALLDATA using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_alldata.sas.
MLOGIC:  Ending compilation of JM_AVAL_ALLDATA.
MLOGIC(JM_AVAL_ALLDATA):  Beginning execution.
                                                           The SAS System

MLOGIC(JM_AVAL_ALLDATA):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_alldata.sas
MLOGIC(JM_AVAL_ALLDATA):  Parameter JM_OUTDSN has value JM_AVAL_ALLDATA1
MLOGIC(JM_AVAL_ALLDATA):  Parameter JM_BIGN has value 
MLOGIC(JM_AVAL_ALLDATA):  Parameter JM_GRPVAR has value grpvar
MLOGIC(JM_AVAL_ALLDATA):  Parameter JM_DEBUG has value N
MLOGIC(JM_AVAL_ALLDATA):  Parameter JM_VERSION has value 1
MPRINT(JM_AVAL_ALLDATA):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_ALLDATA):   data _null_;
MPRINT(JM_AVAL_ALLDATA):   put ' ';
MPRINT(JM_AVAL_ALLDATA):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   PUT "ALERT:I: JM_OUTDSN PROCESSED - JM_AVAL_ALLDATA1";
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_ALLDATA):   PUT "ALERT:I: JM_BIGN PROCESSED - ";
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MPRINT(JM_AVAL_ALLDATA):   PUT "ALERT:I: JM_GRPVAR PROCESSED - grpvar";
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_ALLDATA):   PUT "ALERT:I: JM_DEBUG PROCESSED - N";
SYMBOLGEN:  Macro variable JM_VERSION resolves to 1
MPRINT(JM_AVAL_ALLDATA):   PUT "ALERT:I: JM_VERSION PROCESSED - 1";
MPRINT(JM_AVAL_ALLDATA):   put "********************************************************";
MPRINT(JM_AVAL_ALLDATA):   put " ";
MPRINT(JM_AVAL_ALLDATA):   put 'NOTE: [JM_AVAL_ALLDATA] is currently running macro %jm_aval_alldata version 1.0.';
MPRINT(JM_AVAL_ALLDATA):   put " ";
MPRINT(JM_AVAL_ALLDATA):   run;


******************* Parameter Values *******************
ALERT:I: JM_OUTDSN PROCESSED - JM_AVAL_ALLDATA1
ALERT:I: JM_BIGN PROCESSED - 
ALERT:I: JM_GRPVAR PROCESSED - grpvar
ALERT:I: JM_DEBUG PROCESSED - N
ALERT:I: JM_VERSION PROCESSED - 1
********************************************************

NOTE: [JM_AVAL_ALLDATA] is currently running macro %jm_aval_alldata version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_ALLDATA):   *** Keep Count of er ror messages ***;
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is _ERR)
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is _ERRCNT)
MPRINT(JM_AVAL_ALLDATA):   data _null_;
MPRINT(JM_AVAL_ALLDATA):   length jm_debug $20;
MPRINT(JM_AVAL_ALLDATA):   *** 3)If JM_Debug is neither 'Y' or 'N' then issue information log message ***;
SYMBOLGEN:  Macro variable JM_DEBUG resolves to N
MPRINT(JM_AVAL_ALLDATA):   jm_debug=compress(upcase(strip("N")));
MPRINT(JM_AVAL_ALLDATA):   if jm_debug not in("Y","N") then do;
MPRINT(JM_AVAL_ALLDATA):   put ' ';
MPRINT(JM_AVAL_ALLDATA):   put "WAR" "NING:[jm_aval_alldata] Parameter JM_DEBUG value can be either 'N' or 'Y'. " "Since entered 
value is neither 'Y' or 'N' default value has been assigned to the " "parameter JM_DEBUG=N.";
MPRINT(JM_AVAL_ALLDATA):   put " ";
MPRINT(JM_AVAL_ALLDATA):   call symputx('jm_debug','N');
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   *** Default JM_BIGN if not specified ***;
SYMBOLGEN:  Macro variable JM_BIGN resolves to 
MPRINT(JM_AVAL_ALLDATA):   if strip("") = "" then call symputx('jm_bign','JM_BIGN1');
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_ALLDATA):   *** 1) If parameter JM_OUTDSN is not provided issue Information log message ***;
MPRINT(JM_AVAL_ALLDATA):   data _null_;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   JM_OUTDSN=strip("JM_AVAL_ALLDATA1");
MPRINT(JM_AVAL_ALLDATA):   if JM_OUTDSN = '' then do;
MPRINT(JM_AVAL_ALLDATA):   put ' ';
MPRINT(JM_AVAL_ALLDATA):   put "NOTE:[JM_AVALALL] Parameter JM_OUTDSN is missing and default value has " "been assigned to the 
parameter JM_OUTDSN=JM_AVAL_ALLDATA.";
MPRINT(JM_AVAL_ALLDATA):   put " ";
MPRINT(JM_AVAL_ALLDATA):   call symputx('JM_OUTDSN',"JM_AVAL_ALLDATA");
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   *** 6) If parameter JM_OUTDSN is user provided and it does not follow given convention ***;
MPRINT(JM_AVAL_ALLDATA):   if index(upcase(jm_outdsn),'JM_AVAL_ALLDATA') = 0 and compress(jm_outdsn) ne '' then do;
                                                           The SAS System

MPRINT(JM_AVAL_ALLDATA):   put ' ';
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   put "ER" "ROR:[jm_aval_alldata] Output Data set 'JM_AVAL_ALLDATA1' does not follow the JM_AVAL_ALLDATA " 
"Macro conventions, the output dataset name should use prefix " "'JM_AVAL_ALLDATA'.";
MPRINT(JM_AVAL_ALLDATA):   put " ";
MPRINT(JM_AVAL_ALLDATA):   call symput('_err','yes');
SYMBOLGEN:  Macro variable _ERRCNT resolves to 0
MPRINT(JM_AVAL_ALLDATA):   _errcnt=0;
MPRINT(JM_AVAL_ALLDATA):   _errcnt = _errcnt + 1;
MPRINT(JM_AVAL_ALLDATA):   call symputx('_errcnt',_errcnt);
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_ALLDATA):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_ALLDATA):   data _null_;
MPRINT(JM_AVAL_ALLDATA):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_ALLDATA):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_ALLDATA):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_ALLDATA):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_ALLDATA):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_ALLDATA):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&v_bign" ne "none" is TRUE
                                                           The SAS System

MPRINT(JM_AVAL_ALLDATA):   data _null_;
MPRINT(JM_AVAL_ALLDATA):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_ALLDATA):   set jm_bign1;
MPRINT(JM_AVAL_ALLDATA):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_ALLDATA):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_AVAL_ALLDATA):   *** Get the list of datasets with prefix , either “JM_AVAL_SUM” or “JM_AVAL_COUNT” (i.e. 
JM_AVAL_COUNTxx, JM_AVAL_SUMxx) ***;
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DATCNT)
MPRINT(JM_AVAL_ALLDATA):   data datalist;
MPRINT(JM_AVAL_ALLDATA):   set sashelp.vstable;
MPRINT(JM_AVAL_ALLDATA):   where libname = "WORK" and ( index(upcase(memname),"JM_AVAL_SUM") or 
index(upcase(memname),"JM_AVAL_COUNT") and memname ne 'JM_AVAL+_SUM_PRE' );
MPRINT(JM_AVAL_ALLDATA):   retain datcnt 0;
MPRINT(JM_AVAL_ALLDATA):   datcnt = datcnt +1;
MPRINT(JM_AVAL_ALLDATA):   length datvar $40;
MPRINT(JM_AVAL_ALLDATA):   *** Create macro variable list of the datasets ***;
MPRINT(JM_AVAL_ALLDATA):   datvar = compress("dat" || put(datcnt,best.));
MPRINT(JM_AVAL_ALLDATA):   call symputx(datvar,memname);
MPRINT(JM_AVAL_ALLDATA):   call symput('datcnt',datcnt);
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      193:228   
NOTE: SAS threaded sort was used.
NOTE: There were 11 observations read from the data set SASHELP.VSTABLE.
      WHERE (libname='WORK') and (INDEX(UPCASE(memname), 'JM_AVAL_SUM') or (INDEX(UPCASE(memname), 'JM_AVAL_COUNT') and (memname 
      not = 'JM_AVAL+_SUM_PRE')));
NOTE: The data set WORK.DATALIST has 11 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.05 seconds
                                                           The SAS System

      cpu time            0.06 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Identify the Prefix based on dataset name for data list ***;
MPRINT(JM_AVAL_ALLDATA):   data datalist;
MPRINT(JM_AVAL_ALLDATA):   set datalist;
MPRINT(JM_AVAL_ALLDATA):   length prefix $40;
MPRINT(JM_AVAL_ALLDATA):   prefix = memname;
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'1',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'2',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'3',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'4',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'5',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'6',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'7',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'8',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'9',''));
MPRINT(JM_AVAL_ALLDATA):   prefix = compress(tranwrd(prefix,'0',''));
MPRINT(JM_AVAL_ALLDATA):   drop datvar;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 11 observations read from the data set WORK.DATALIST.
NOTE: The data set WORK.DATALIST has 11 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Verify any empty datasets and remove them ***;
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is ANY_EMPTY)
SYMBOLGEN:  Macro variable DATCNT resolves to           11
MLOGIC(JM_AVAL_ALLDATA):  %DO loop beginning; index variable I; start value is 1; stop value is 11; by value is 1.  
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable DAT1 resolves to JM_AVAL_COUNT112
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 48
                                                           The SAS System

MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 2; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable DAT2 resolves to JM_AVAL_COUNT113
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 41
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 3; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable DAT3 resolves to JM_AVAL_SUM101
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 28
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 4; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable DAT4 resolves to JM_AVAL_SUM102
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 5; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable DAT5 resolves to JM_AVAL_SUM103
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
                                                           The SAS System

MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 6; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable DAT6 resolves to JM_AVAL_SUM104
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 7; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable DAT7 resolves to JM_AVAL_SUM105
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 8; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable DAT8 resolves to JM_AVAL_SUM106
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 9; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
                                                           The SAS System

SYMBOLGEN:  Macro variable DAT9 resolves to JM_AVAL_SUM107
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 10; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable DAT10 resolves to JM_AVAL_SUM108
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 11; loop will iterate again.
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DSID)
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 11
SYMBOLGEN:  Macro variable DAT11 resolves to JM_AVAL_SUM109
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is NOBS)
SYMBOLGEN:  Macro variable DSID resolves to 1
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is RC)
SYMBOLGEN:  Macro variable DSID resolves to 1
SYMBOLGEN:  Macro variable NOBS resolves to 36
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &nobs = 0 is FALSE
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 12; loop will not iterate again.
MPRINT(JM_AVAL_ALLDATA):   *** Renumber data count for sorting ***;
MPRINT(JM_AVAL_ALLDATA):   data datalist2;
MPRINT(JM_AVAL_ALLDATA):   set datalist;
MPRINT(JM_AVAL_ALLDATA):   curblock = tranwrd(lowcase(memname),"jm_aval_count","");
MPRINT(JM_AVAL_ALLDATA):   curblock = compress(tranwrd(curblock,"jm_aval_sum",""));
MPRINT(JM_AVAL_ALLDATA):   jm_block = input(compress(curblock),best.);
MPRINT(JM_AVAL_ALLDATA):   drop curblock;
MPRINT(JM_AVAL_ALLDATA):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      193:92   curblock
                                                           The SAS System

NOTE: There were 11 observations read from the data set WORK.DATALIST.
NOTE: The data set WORK.DATALIST2 has 11 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_ALLDATA):   proc sort data = datalist2;
MPRINT(JM_AVAL_ALLDATA):   by jm_block;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 11 observations read from the data set WORK.DATALIST2.
NOTE: SAS sort was used.
NOTE: The data set WORK.DATALIST2 has 11 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   data datalist;
MPRINT(JM_AVAL_ALLDATA):   set datalist2;
MPRINT(JM_AVAL_ALLDATA):   datcnt = jm_block;
MPRINT(JM_AVAL_ALLDATA):   drop jm_block;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 11 observations read from the data set WORK.DATALIST2.
NOTE: The data set WORK.DATALIST has 11 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Re-create data list macro variables ***;
SYMBOLGEN:  Macro variable ANY_EMPTY resolves to no
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&any_empty" = "yes" is FALSE
MPRINT(JM_AVAL_ALLDATA):   *** 2) If list of datasets to be set is empty then issue ER ROR message ***;
MPRINT(JM_AVAL_ALLDATA):   data _null_;
SYMBOLGEN:  Macro variable DATCNT resolves to           11
MPRINT(JM_AVAL_ALLDATA):   if 11 = 0 then do;
MPRINT(JM_AVAL_ALLDATA):   put ' ';
MPRINT(JM_AVAL_ALLDATA):   put "ER" "ROR:[jm_aval_alldata] Input Data sets with prefix JM_AVAL_SUM or JM_AVAL_COUNT " "does not 
                                                           The SAS System

exist.";
MPRINT(JM_AVAL_ALLDATA):   put " ";
MPRINT(JM_AVAL_ALLDATA):   call symput('_err','yes');
SYMBOLGEN:  Macro variable _ERRCNT resolves to 0
MPRINT(JM_AVAL_ALLDATA):   _errcnt=0;
MPRINT(JM_AVAL_ALLDATA):   _errcnt = _errcnt + 1;
MPRINT(JM_AVAL_ALLDATA):   call symputx('_errcnt',_errcnt);
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_ALLDATA):   *** Set all datasets from the List ***;
SYMBOLGEN:  Macro variable DATCNT resolves to           11
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &datcnt > 0 is TRUE
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   data JM_AVAL_ALLDATA1;
MPRINT(JM_AVAL_ALLDATA):   length grpvar $200;
MPRINT(JM_AVAL_ALLDATA):   grpvar = " ";
SYMBOLGEN:  Macro variable DATCNT resolves to           11
MLOGIC(JM_AVAL_ALLDATA):  %DO loop beginning; index variable I; start value is 1; stop value is 11; by value is 1.  
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable DAT1 resolves to JM_AVAL_COUNT112
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 2; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable DAT2 resolves to JM_AVAL_COUNT113
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 3; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable DAT3 resolves to JM_AVAL_SUM101
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 4; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable DAT4 resolves to JM_AVAL_SUM102
                                                           The SAS System

MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 5; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable DAT5 resolves to JM_AVAL_SUM103
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 6; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable DAT6 resolves to JM_AVAL_SUM104
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 7; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable DAT7 resolves to JM_AVAL_SUM105
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 8; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable DAT8 resolves to JM_AVAL_SUM106
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 9; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable DAT9 resolves to JM_AVAL_SUM107
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 10; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable DAT10 resolves to JM_AVAL_SUM108
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 11; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 11
SYMBOLGEN:  Macro variable DAT11 resolves to JM_AVAL_SUM109
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 12; loop will not iterate again.
MPRINT(JM_AVAL_ALLDATA):   set JM_AVAL_COUNT112 JM_AVAL_COUNT113 JM_AVAL_SUM101 JM_AVAL_SUM102 JM_AVAL_SUM103 JM_AVAL_SUM104 
JM_AVAL_SUM105 JM_AVAL_SUM106 JM_AVAL_SUM107 JM_AVAL_SUM108 JM_AVAL_SUM109 ;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 48 observations read from the data set WORK.JM_AVAL_COUNT112.
NOTE: There were 41 observations read from the data set WORK.JM_AVAL_COUNT113.
NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
                                                           The SAS System

NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM108.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM109.
NOTE: The data set WORK.JM_AVAL_ALLDATA1 has 405 observations and 50 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Verify if input dataset has GRPVAR ***;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   proc contents data = JM_AVAL_ALLDATA1 out=v_grpvar noprint;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: The data set WORK.V_GRPVAR has 50 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is ANY_GRPVAR)
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is V_NAMEC)
MPRINT(JM_AVAL_ALLDATA):   data _null_;
MPRINT(JM_AVAL_ALLDATA):   set v_grpvar;
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MPRINT(JM_AVAL_ALLDATA):   if upcase(name) = upcase("grpvar") then call symputx('any_grpvar','yes');
MPRINT(JM_AVAL_ALLDATA):   *** Handle case of numeric JM_AVAL_NAMEC **;
MPRINT(JM_AVAL_ALLDATA):   if upcase(strip(name)) = 'JM_AVAL_NAMEC' and type = 1 then call symputx('v_namec','num');
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 50 observations read from the data set WORK.V_GRPVAR.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Update JM_AVAL_NAMEC to be character if numeric ***;
SYMBOLGEN:  Macro variable V_NAMEC resolves to char
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&v_namec" = "num" is FALSE
MPRINT(JM_AVAL_ALLDATA):   *** Remove JM_GRPVAR if it does not exist ***;
MPRINT(JM_AVAL_ALLDATA):   data _null_;
                                                           The SAS System

SYMBOLGEN:  Macro variable ANY_GRPVAR resolves to yes
MPRINT(JM_AVAL_ALLDATA):   if "yes" ="no" then call symputx('JM_GRPVAR', '');
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** 4) If variable JM_AVAL_LABEL and JM_Block from JM_AVAL_SUMXX or JM_AVAL_COUNTXX are not unique ***;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   proc sort data = JM_AVAL_ALLDATA1 out=v_label_block1;
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MPRINT(JM_AVAL_ALLDATA):   by grpvar jm_aval_label jm_block;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.JM_AVAL_ALLDATA1.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_LABEL_BLOCK1 has 405 observations and 50 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_ALLDATA):   data v_label_block3;
MPRINT(JM_AVAL_ALLDATA):   length JM_AVAL_NAMEC $2000;
MPRINT(JM_AVAL_ALLDATA):   set v_label_block1;
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MPRINT(JM_AVAL_ALLDATA):   by grpvar jm_aval_label jm_block;
MPRINT(JM_AVAL_ALLDATA):   length lagblock laglabel lagnamec $400;
MPRINT(JM_AVAL_ALLDATA):   laglabel=lag(jm_aval_label);
MPRINT(JM_AVAL_ALLDATA):   lagblock=lag(jm_block);
MPRINT(JM_AVAL_ALLDATA):   lagnamec = strip(lag(jm_aval_namec));
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &jm_grpvar. ne  is TRUE
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MPRINT(JM_AVAL_ALLDATA):  laggrpvar = lag(grpvar);
MPRINT(JM_AVAL_ALLDATA):   if _n_ > 1 then do;
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &jm_grpvar. ne  is TRUE
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
                                                           The SAS System

MPRINT(JM_AVAL_ALLDATA):   if (strip(laglabel) = strip(jm_aval_label)) and (lagblock ne jm_block) and (jm_aval_label ne lagnamec) 
and (jm_aval_label ne '') and grpvar=laggrpvar then do;
MPRINT(JM_AVAL_ALLDATA):   blocks = "'" || trim(jm_block) || "' and '" || trim(lagblock) || "'";
MPRINT(JM_AVAL_ALLDATA):   put ' ';
MPRINT(JM_AVAL_ALLDATA):   put "ER" "ROR:[jm_aval_alldata] Following list of JM_BLOCK are associated " "with more than one 
JM_AVAL_LABEL values:                                              " "   JM_AVAL_LABEL='" jm_aval_label +(-1) "' JM_BLOCK=" blocks 
+(-1) "." ;
MPRINT(JM_AVAL_ALLDATA):   put " " ;
MPRINT(JM_AVAL_ALLDATA):   call symput('_err','yes');
SYMBOLGEN:  Macro variable _ERRCNT resolves to 0
MPRINT(JM_AVAL_ALLDATA):   _errcnt=0;
MPRINT(JM_AVAL_ALLDATA):   _errcnt = _errcnt + 1;
MPRINT(JM_AVAL_ALLDATA):   call symputx('_errcnt',_errcnt);
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.V_LABEL_BLOCK1.
NOTE: The data set WORK.V_LABEL_BLOCK3 has 405 observations and 56 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   proc sort data = JM_AVAL_ALLDATA1 out=v_label_block2;
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
MPRINT(JM_AVAL_ALLDATA):   by grpvar jm_aval_label jm_aval_namec jm_block ;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.JM_AVAL_ALLDATA1.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_LABEL_BLOCK2 has 405 observations and 50 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   data v_label_block3;
MPRINT(JM_AVAL_ALLDATA):   set v_label_block2;
SYMBOLGEN:  Macro variable JM_GRPVAR resolves to grpvar
                                                           The SAS System

MPRINT(JM_AVAL_ALLDATA):   by grpvar jm_aval_label jm_aval_namec jm_block ;
MPRINT(JM_AVAL_ALLDATA):   length lagblock laglabel lagnamec $200;
MPRINT(JM_AVAL_ALLDATA):   laglabel=lag(jm_aval_label);
MPRINT(JM_AVAL_ALLDATA):   lagnamec=lag(jm_aval_namec);
MPRINT(JM_AVAL_ALLDATA):   lagblock=lag(jm_block);
MPRINT(JM_AVAL_ALLDATA):   if _n_ > 1 then do;
MPRINT(JM_AVAL_ALLDATA):   if (laglabel = jm_aval_label) and (lagnamec = jm_aval_namec) and (lagblock ne jm_block) and 
(jm_aval_label ne '') then do;
MPRINT(JM_AVAL_ALLDATA):   blocks = "'" || trim(lagblock) || "' and '" || trim(jm_block) || "'";
MPRINT(JM_AVAL_ALLDATA):   put ' ';
MPRINT(JM_AVAL_ALLDATA):   put "ER" "ROR:[jm_aval_alldata] Following JM_AVAL_LABEL are associated " "with more than one JM_BLOCK 
values: " "JM_BLOCK=" blocks +(-1) ", JM_AVAL_LABEL=" jm_aval_label;
MPRINT(JM_AVAL_ALLDATA):   call symput('_err','yes');
SYMBOLGEN:  Macro variable _ERRCNT resolves to 0
MPRINT(JM_AVAL_ALLDATA):   _errcnt=0;
MPRINT(JM_AVAL_ALLDATA):   _errcnt = _errcnt + 1;
MPRINT(JM_AVAL_ALLDATA):   call symputx('_errcnt',_errcnt);
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.V_LABEL_BLOCK2.
NOTE: The data set WORK.V_LABEL_BLOCK3 has 405 observations and 55 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_ALLDATA):   *** 5) Local macro variable _err is used to count the number ***;
MPRINT(JM_AVAL_ALLDATA):   *** Get the list of datasets with prefix , either “JM_AVAL_SUM” or “JM_AVAL_COUNT” ***;
MPRINT(JM_AVAL_ALLDATA):   PROC SQL;
MPRINT(JM_AVAL_ALLDATA):   CREATE TABLE SETDSET AS SELECT DISTINCT MEMNAME FROM DICTIONARY.TABLES WHERE UPCASE(LIBNAME)="WORK" and 
( (index(memname,'JM_AVAL_SUM') > 0 or index(memname,'JM_AVAL_COUNT') > 0 ) and index(memname,'JM_AVAL_SUM_PRE') = 0 );
NOTE: Table WORK.SETDSET created, with 11 rows and 1 columns.

MPRINT(JM_AVAL_ALLDATA):   QUIT;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
                                                           The SAS System

      

MPRINT(JM_AVAL_ALLDATA):   *** Remove output dataset form input dataset list ***;
MPRINT(JM_AVAL_ALLDATA):   DATA SETDSET;
MPRINT(JM_AVAL_ALLDATA):   SET SETDSET;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   IF UPCASE(MEMNAME)="JM_AVAL_ALLDATA1" THEN DELETE;
MPRINT(JM_AVAL_ALLDATA):   RUN;

NOTE: There were 11 observations read from the data set WORK.SETDSET.
NOTE: The data set WORK.SETDSET has 11 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Create macro variables based upon the list of input datasets ***;
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is TSDSET)
MPRINT(JM_AVAL_ALLDATA):   DATA _NULL_;
MPRINT(JM_AVAL_ALLDATA):   SET SETDSET END=EOF;
MPRINT(JM_AVAL_ALLDATA):   CALL SYMPUTX(CATT("SDSET",_N_),MEMNAME);
MPRINT(JM_AVAL_ALLDATA):   IF EOF THEN CALL SYMPUTX("TSDSET",_N_);
MPRINT(JM_AVAL_ALLDATA):   RUN;

NOTE: There were 11 observations read from the data set WORK.SETDSET.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_ALLDATA):  %LOCAL  I
MPRINT(JM_AVAL_ALLDATA):   *** Set all datasets from the List and Output the dataset with provided parameter value or default value 
of &JM_OUTDSN ***;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   DATA JM_AVAL_ALLDATA1;
MPRINT(JM_AVAL_ALLDATA):   *** LENGTH GRPVAR GRPLABEL $200.;
MPRINT(JM_AVAL_ALLDATA):   length grpvar $200;
MPRINT(JM_AVAL_ALLDATA):   grpvar = " ";
SYMBOLGEN:  Macro variable TSDSET resolves to 11
MLOGIC(JM_AVAL_ALLDATA):  %DO loop beginning; index variable I; start value is 1; stop value is 11; by value is 1.  
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable SDSET1 resolves to JM_AVAL_COUNT112
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 2; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable SDSET2 resolves to JM_AVAL_COUNT113
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 3; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable SDSET3 resolves to JM_AVAL_SUM101
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 4; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable SDSET4 resolves to JM_AVAL_SUM102
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 5; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable SDSET5 resolves to JM_AVAL_SUM103
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 6; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable SDSET6 resolves to JM_AVAL_SUM104
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 7; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable SDSET7 resolves to JM_AVAL_SUM105
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 8; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable SDSET8 resolves to JM_AVAL_SUM106
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 9; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable SDSET9 resolves to JM_AVAL_SUM107
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 10; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable SDSET10 resolves to JM_AVAL_SUM108
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 11; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 11
                                                           The SAS System

SYMBOLGEN:  Macro variable SDSET11 resolves to JM_AVAL_SUM109
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 12; loop will not iterate again.
MPRINT(JM_AVAL_ALLDATA):   SET JM_AVAL_COUNT112 JM_AVAL_COUNT113 JM_AVAL_SUM101 JM_AVAL_SUM102 JM_AVAL_SUM103 JM_AVAL_SUM104 
JM_AVAL_SUM105 JM_AVAL_SUM106 JM_AVAL_SUM107 JM_AVAL_SUM108 JM_AVAL_SUM109 ;
MPRINT(JM_AVAL_ALLDATA):   RUN;

NOTE: There were 48 observations read from the data set WORK.JM_AVAL_COUNT112.
NOTE: There were 41 observations read from the data set WORK.JM_AVAL_COUNT113.
NOTE: There were 28 observations read from the data set WORK.JM_AVAL_SUM101.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM102.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM103.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM104.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM105.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM106.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM107.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM108.
NOTE: There were 36 observations read from the data set WORK.JM_AVAL_SUM109.
NOTE: The data set WORK.JM_AVAL_ALLDATA1 has 405 observations and 50 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Continue with logic of output dataset after JM_AVAL_SUMxx and JM_AVAL_COUNTxx ***;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&jm_outdsn" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   PROC SORT DATA=JM_AVAL_ALLDATA1;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_ALLDATA):   BY JM_TRTVARN;
MPRINT(JM_AVAL_ALLDATA):   RUN;

NOTE: There were 405 observations read from the data set WORK.JM_AVAL_ALLDATA1.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_AVAL_ALLDATA1 has 405 observations and 50 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BIGN resolves to JM_BIGN1
MPRINT(JM_AVAL_ALLDATA):   PROC SORT DATA=JM_BIGN1;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_ALLDATA):   BY JM_TRTVARN;
MPRINT(JM_AVAL_ALLDATA):   RUN;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_BIGN1 has 4 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Verify if Summary Type of COUNT exists ***;
MLOGIC(JM_AVAL_ALLDATA):  %LET (variable name is DOCOUNT)
MPRINT(JM_AVAL_ALLDATA):   data _null_;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   set JM_AVAL_ALLDATA1 ;
MPRINT(JM_AVAL_ALLDATA):   if jm_type = 'COUNT' then call symputx('docount','yes');
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.JM_AVAL_ALLDATA1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   DATA JM_AVAL_ALLDATA1;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
SYMBOLGEN:  Macro variable JM_BIGN resolves to JM_BIGN1
MPRINT(JM_AVAL_ALLDATA):   MERGE JM_AVAL_ALLDATA1 JM_BIGN1;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_ALLDATA):   BY JM_TRTVARN;
SYMBOLGEN:  Macro variable DOCOUNT resolves to yes
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&docount" = "yes" is TRUE
MPRINT(JM_AVAL_ALLDATA):   length colval $40;
MPRINT(JM_AVAL_ALLDATA):   IF JM_TYPE="COUNT" THEN DO;
                                                           The SAS System

MPRINT(JM_AVAL_ALLDATA):   *** Old logic ***;
MPRINT(JM_AVAL_ALLDATA):   *** IF JM_AVAL_COUNT ^ IN (.,0) THEN DO;
MPRINT(JM_AVAL_ALLDATA):   *** COLVAL=strip(put(JM_AVAL_COUNT,8.0))||" ("||strip(put((JM_AVAL_COUNT/JM_AVAL_BIGN)*100,5.1))||')';
MPRINT(JM_AVAL_ALLDATA):   *** END;
MPRINT(JM_AVAL_ALLDATA):   *** ELSE IF JM_AVAL_COUNT IN (.,0) THEN DO;
MPRINT(JM_AVAL_ALLDATA):   *** COLVAL="0";
MPRINT(JM_AVAL_ALLDATA):   *** END;
MPRINT(JM_AVAL_ALLDATA):   colval=jm_aval_countc;
MPRINT(JM_AVAL_ALLDATA):   END;
MPRINT(JM_AVAL_ALLDATA):   run;

INFO: The variable trtVAR on data set WORK.JM_AVAL_ALLDATA1 will be overwritten by data set WORK.JM_BIGN1.
INFO: The variable JM_AVAL_BIGN on data set WORK.JM_AVAL_ALLDATA1 will be overwritten by data set WORK.JM_BIGN1.
NOTE: There were 405 observations read from the data set WORK.JM_AVAL_ALLDATA1.
NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: The data set WORK.JM_AVAL_ALLDATA1 has 405 observations and 55 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Delete temporary datasets ***;
MPRINT(JM_AVAL_ALLDATA):   PROC DATASETS LIBRARY=WORK;
                                                             Directory

                                Libref             WORK                                             
                                Engine             V9                                               
                                Physical Name      E:\SAS Temporary Files\npatil1\_TD75112_JAZZPROD_
                                Filename           E:\SAS Temporary Files\npatil1\_TD75112_JAZZPROD_
                                Owner Name         JAZZPROD\npatil1                                 
                                File Size          24KB                                             
                                File Size (bytes)  24576                                            


                                                    Member
                               #  Name              Type        File Size  Last Modified

                               1  ADAE              DATA            512KB  02/20/2023 15:43:53        
                               2  ADCM              DATA              2MB  02/20/2023 15:43:53        
                               3  ADEG              DATA             18MB  02/20/2023 15:43:53        
                               4  ADEG_F            DATA             11MB  02/20/2023 15:43:53        
                                                           The SAS System

                                                    Member
                               #  Name              Type        File Size  Last Modified

                               5  ADEG_F_112        DATA              2MB  02/20/2023 15:44:00        
                               6  ADEG_F_113        DATA              2MB  02/20/2023 15:44:00        
                               7  ADEG_S            DATA             18MB  02/20/2023 15:43:55        
                               8  ADSL              DATA            416KB  02/20/2023 15:43:53        
                               9  COLUMNS           DATA            128KB  02/20/2023 15:43:44        
                              10  COUNT_PREP1       DATA             11MB  02/20/2023 15:44:00        
                              11  COUNT_PREP2       DATA              2MB  02/20/2023 15:44:00        
                              12  COUNT_PREP4       DATA            128KB  02/20/2023 15:44:00        
                              13  COUNT_PREP4A      DATA            128KB  02/20/2023 15:44:00        
                              14  COUNT_PREP4B      DATA            128KB  02/20/2023 15:44:00        
                              15  COUNT_PREP4C      DATA            128KB  02/20/2023 15:44:00        
                              16  COUNT_PREP5       DATA            768KB  02/20/2023 15:44:00        
                              17  CUR_ADEG_F        DATA             11MB  02/20/2023 15:44:00        
                              18  CUR_ADEG_S        DATA              2MB  02/20/2023 15:44:00        
                              19  CUR_JM_BIGN1      DATA            128KB  02/20/2023 15:44:00        
                              20  CUR_JM_BIGN2      DATA            128KB  02/20/2023 15:44:00        
                              21  DATA1             DATA              1MB  02/20/2023 15:43:53        
                              22  DATA2             DATA             37MB  02/20/2023 15:43:54        
                              23  DATA3             DATA             56MB  02/20/2023 15:43:54        
                              24  DATA4             DATA             74MB  02/20/2023 15:43:55        
                              25  DATA5             DATA             93MB  02/20/2023 15:43:56        
                              26  DATA6             DATA            111MB  02/20/2023 15:43:57        
                              27  DATA7             DATA            130MB  02/20/2023 15:43:57        
                              28  DATA8             DATA            148MB  02/20/2023 15:43:58        
                              29  DATA9             DATA            167MB  02/20/2023 15:43:59        
                              30  DATALIST          DATA            128KB  02/20/2023 15:44:01        
                              31  DATALIST2         DATA            128KB  02/20/2023 15:44:01        
                              32  DUMMYADSL         DATA              9MB  02/20/2023 15:43:53        
                              33  DUMMYPARM         DATA            128KB  02/20/2023 15:43:53        
                              34  E_BYVAR           DATA            167MB  02/20/2023 15:43:59        
                              35  FMTCATLOG         DATA            192KB  02/20/2023 15:43:53        
                              36  FORMATS           CATALOG          97KB  02/20/2023 15:43:53        
                              37  FORMATS           DATA            192KB  02/20/2023 15:43:53        
                              38  INFOOTS           DATA            256KB  02/20/2023 15:43:44        
                              39  INHEADERS         DATA            128KB  02/20/2023 15:43:44        
                              40  INTITLES          DATA            128KB  02/20/2023 15:43:44        
                              41  JM_AVAL_ALLDATA1  DATA              3MB  02/20/2023 15:44:01        
                              42  JM_AVAL_COUNT112  DATA            768KB  02/20/2023 15:44:00        
                                                           The SAS System

                                                    Member
                               #  Name              Type        File Size  Last Modified

                              43  JM_AVAL_COUNT113  DATA            768KB  02/20/2023 15:44:00        
                              44  JM_AVAL_SUM101    DATA            448KB  02/20/2023 15:43:53        
                              45  JM_AVAL_SUM102    DATA            448KB  02/20/2023 15:43:54        
                              46  JM_AVAL_SUM103    DATA            448KB  02/20/2023 15:43:55        
                              47  JM_AVAL_SUM104    DATA            448KB  02/20/2023 15:43:55        
                              48  JM_AVAL_SUM105    DATA            448KB  02/20/2023 15:43:56        
                              49  JM_AVAL_SUM106    DATA            448KB  02/20/2023 15:43:57        
                              50  JM_AVAL_SUM107    DATA            448KB  02/20/2023 15:43:58        
                              51  JM_AVAL_SUM108    DATA            448KB  02/20/2023 15:43:59        
                              52  JM_AVAL_SUM109    DATA            448KB  02/20/2023 15:44:00        
                              53  JM_BIGN1          DATA            128KB  02/20/2023 15:44:01        
                              54  JM_TF_TITFT       DATA              1MB  02/20/2023 15:43:43        
                              55  MAXGRPT           DATA            128KB  02/20/2023 15:43:53        
                              56  MAXGRPT_PER       DATA            128KB  02/20/2023 15:43:53        
                              57  MAXGR_REL         DATA            128KB  02/20/2023 15:43:53        
                              58  MAXGR_REL_PER     DATA            128KB  02/20/2023 15:43:53        
                              59  PARAMN_FR         DATA            128KB  02/20/2023 15:43:53        
                              60  RAWDATA           DATA            168KB  02/20/2023 15:43:44        
                              61  RFMT              DATA            192KB  02/20/2023 15:44:00        
                              62  SASMAC2           CATALOG          13KB  02/20/2023 15:43:53        
                              63  SASMACR           CATALOG           5KB  02/20/2023 15:43:39        
                              64  SETDSET           DATA            128KB  02/20/2023 15:44:01        
                              65  TEST              DATA              1MB  02/20/2023 15:43:43        
                              66  TF                DATA            512KB  02/20/2023 15:43:43        
                              67  TF_FOOT           DATA            128KB  02/20/2023 15:43:43        
                              68  TRTFMT            DATA            128KB  02/20/2023 15:43:53        
                              69  TRTFMTEXIST       DATA            128KB  02/20/2023 15:43:53        
                              70  TRTLIST           DATA            128KB  02/20/2023 15:43:53        
                              71  V_AMPER           DATA            504KB  02/20/2023 15:43:43        
                              72  V_BIGN            DATA            144KB  02/20/2023 15:44:00        
                              73  V_BIGN_WHERE      DATA            216KB  02/20/2023 15:44:00        
                              74  V_BYVAR           DATA             18MB  02/20/2023 15:43:59        
                              75  V_EMPTY           DATA              3MB  02/20/2023 15:43:59        
                              76  V_FMT3            DATA            192KB  02/20/2023 15:44:00        
                              77  V_FORMATS         DATA            144KB  02/20/2023 15:43:53        
                              78  V_GRPVAR          DATA            144KB  02/20/2023 15:44:01        
                              79  V_HASFMT          DATA            216KB  02/20/2023 15:44:00        
                              80  V_JM_BIGN         DATA            128KB  02/20/2023 15:44:00        
                                                           The SAS System

                                                    Member
                               #  Name              Type        File Size  Last Modified

                              81  V_JM_BIGN1        DATA            128KB  02/20/2023 15:44:00        
                              82  V_JM_INDSN        DATA            128KB  02/20/2023 15:44:00        
                              83  V_JM_TRTVARN      DATA            128KB  02/20/2023 15:44:00        
                              84  V_LABEL_BLOCK1    DATA              3MB  02/20/2023 15:44:01        
                              85  V_LABEL_BLOCK2    DATA              3MB  02/20/2023 15:44:01        
                              86  V_LABEL_BLOCK3    DATA              4MB  02/20/2023 15:44:01        
                              87  V_TRTFMT2         DATA            192KB  02/20/2023 15:43:53        
                              88  V_TRTFMT3         DATA            128KB  02/20/2023 15:43:53        
                              89  V_TRTFMT4         DATA            128KB  02/20/2023 15:43:53        
SYMBOLGEN:  Macro variable TSDSET resolves to 11
MLOGIC(JM_AVAL_ALLDATA):  %DO loop beginning; index variable I; start value is 1; stop value is 11; by value is 1.  
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable SDSET1 resolves to JM_AVAL_COUNT112
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 2; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable SDSET2 resolves to JM_AVAL_COUNT113
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 3; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable SDSET3 resolves to JM_AVAL_SUM101
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 4; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable SDSET4 resolves to JM_AVAL_SUM102
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 5; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 5
SYMBOLGEN:  Macro variable SDSET5 resolves to JM_AVAL_SUM103
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 6; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 6
SYMBOLGEN:  Macro variable SDSET6 resolves to JM_AVAL_SUM104
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 7; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 7
SYMBOLGEN:  Macro variable SDSET7 resolves to JM_AVAL_SUM105
                                                           The SAS System

MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 8; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 8
SYMBOLGEN:  Macro variable SDSET8 resolves to JM_AVAL_SUM106
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 9; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 9
SYMBOLGEN:  Macro variable SDSET9 resolves to JM_AVAL_SUM107
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 10; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 10
SYMBOLGEN:  Macro variable SDSET10 resolves to JM_AVAL_SUM108
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 11; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 11
SYMBOLGEN:  Macro variable SDSET11 resolves to JM_AVAL_SUM109
MLOGIC(JM_AVAL_ALLDATA):  %DO loop index variable I is now 12; loop will not iterate again.
MPRINT(JM_AVAL_ALLDATA):   DELETE JM_AVAL_COUNT112 JM_AVAL_COUNT113 JM_AVAL_SUM101 JM_AVAL_SUM102 JM_AVAL_SUM103 JM_AVAL_SUM104 
JM_AVAL_SUM105 JM_AVAL_SUM106 JM_AVAL_SUM107 JM_AVAL_SUM108 JM_AVAL_SUM109 ;
MPRINT(JM_AVAL_ALLDATA):   QUIT;

NOTE: Deleting WORK.JM_AVAL_COUNT112 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_COUNT113 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM101 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM102 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM103 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM104 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM105 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM106 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM107 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM108 (memtype=DATA).
NOTE: Deleting WORK.JM_AVAL_SUM109 (memtype=DATA).
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Remove empty rows in the event of empty datasets **;
SYMBOLGEN:  Macro variable ANY_EMPTY resolves to no
MLOGIC(JM_AVAL_ALLDATA):  %IF condition "&any_empty" = "yes" is FALSE
MPRINT(JM_AVAL_ALLDATA):   *** Sort if more than nine blocks ***;
                                                           The SAS System

SYMBOLGEN:  Macro variable DATCNT resolves to           11
MLOGIC(JM_AVAL_ALLDATA):  %IF condition &datcnt > 9 is TRUE
MPRINT(JM_AVAL_ALLDATA):   data alldata1;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   set JM_AVAL_ALLDATA1;
MPRINT(JM_AVAL_ALLDATA):   block=input(jm_block,best.);
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.JM_AVAL_ALLDATA1.
NOTE: The data set WORK.ALLDATA1 has 405 observations and 56 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_ALLDATA):   proc sort data = alldata1;
MPRINT(JM_AVAL_ALLDATA):   by block jm_trtvarn;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.ALLDATA1.
NOTE: SAS sort was used.
NOTE: The data set WORK.ALLDATA1 has 405 observations and 56 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLDATA1
MPRINT(JM_AVAL_ALLDATA):   data JM_AVAL_ALLDATA1;
MPRINT(JM_AVAL_ALLDATA):   set alldata1;
MPRINT(JM_AVAL_ALLDATA):   drop block;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: There were 405 observations read from the data set WORK.ALLDATA1.
NOTE: The data set WORK.JM_AVAL_ALLDATA1 has 405 observations and 55 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_ALLDATA):   *** Mark the end of parameter checking ***;
                                                           The SAS System

MPRINT(JM_AVAL_ALLDATA):   data _null_;
SYMBOLGEN:  Macro variable _ERRCNT resolves to 0
MPRINT(JM_AVAL_ALLDATA):   _errcnt=0;
MPRINT(JM_AVAL_ALLDATA):   if _errcnt > 0 then do;
MPRINT(JM_AVAL_ALLDATA):   put ' ';
SYMBOLGEN:  Macro variable _ERRCNT resolves to 0
MPRINT(JM_AVAL_ALLDATA):   put "ER" "ROR:[jm_aval_alldata] Review Macro User Err messages and trace value " "increments for local 
macro variable _errcnt=0. " "JM_AVAL_ALLDATA Macro will exit now.";
MPRINT(JM_AVAL_ALLDATA):   put " ";
MPRINT(JM_AVAL_ALLDATA):   end;
MPRINT(JM_AVAL_ALLDATA):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_ALLDATA):  Ending execution.
194        
195        *------------------------------------------------------------------------------------------------------------------------
195      ! ----------;
196        
197        *  TRANSPOSE THE DATASETS
198        *------------------------------------------------------------------------------------------------------------------------
198      ! ----------;
199        
200        
201        data JM_AVAL_ALLDATA2;
202        set JM_AVAL_ALLDATA1;
203        where JM_TYPE="SUMMARY";
204        
205        if paramn in (106,201) then delete;
206        
207        
208        run;

NOTE: There were 316 observations read from the data set WORK.JM_AVAL_ALLDATA1.
      WHERE JM_TYPE='SUMMARY';
NOTE: The data set WORK.JM_AVAL_ALLDATA2 has 252 observations and 55 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

209        
210        %JM_AVAL_SUM_TRANS(JM_AVAL_INPUT=JM_AVAL_ALLDATA2,
MLOGIC:  Beginning compilation of JM_AVAL_SUM_TRANS using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_sum_trans.sas.
MLOGIC:  Ending compilation of JM_AVAL_SUM_TRANS.
MLOGIC(JM_AVAL_SUM_TRANS):  Beginning execution.
MLOGIC(JM_AVAL_SUM_TRANS):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_sum_trans.sas
211           JM_AVAL_OUTPUT=JM_AVAL_TRANS1, JM_TRANS_BY=   paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC,
212           JM_TRANS_VAR=JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC ,
213           JM_TRANS_ID=JM_TRTVARN);
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_AVAL_INPUT has value JM_AVAL_ALLDATA2
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_AVAL_OUTPUT has value JM_AVAL_TRANS1
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_TRANS_BY has value paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_TRANS_VAR has value JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_TRANS_ID has value JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   aval_input = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   put ' ';
MPRINT(JM_AVAL_SUM_TRANS):   put "******************* Parameter Values *******************";
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_AVAL_INPUT PROCESSED - " aval_input;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_AVAL_OUTPUT PROCESSED - JM_AVAL_TRANS1";
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_TRANS_BY PROCESSED - paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL 
JM_AVAL_NAMEC";
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_TRANS_VAR PROCESSED - JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC";
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_TRANS_ID PROCESSED - JM_TRTVARN";
MPRINT(JM_AVAL_SUM_TRANS):   put "********************************************************";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put 'NOTE: [JM_AVAL_SUM_TRANS] is currently running macro %jm_aval_sum_trans version 1.0.';
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
                                                           The SAS System

      213:81   aval_input

******************* Parameter Values *******************
ALERT:I: JM_AVAL_INPUT PROCESSED - JM_AVAL_ALLDATA2
ALERT:I: JM_AVAL_OUTPUT PROCESSED - JM_AVAL_TRANS1
ALERT:I: JM_TRANS_BY PROCESSED - paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
ALERT:I: JM_TRANS_VAR PROCESSED - JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
ALERT:I: JM_TRANS_ID PROCESSED - JM_TRTVARN
********************************************************

NOTE: [JM_AVAL_SUM_TRANS] is currently running macro %jm_aval_sum_trans version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Initialize er ror checking condition ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   aval_input = strip(symget('JM_AVAL_INPUT'));
MPRINT(JM_AVAL_SUM_TRANS):   if aval_input = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] is missing required parameter JM_AVAL_INPUT. " "This specifies the 
name of the dataset used as input to be transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
MPRINT(JM_AVAL_SUM_TRANS):   if "JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC" = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] is missing required parameter JM_TRANS_VAR. " "This specifies the 
variable name which contains values to be transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   if "JM_TRTVARN" = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] is missing required parameter JM_TRANS_ID. " "This specifies the 
name of the ID variable used to transpose the dataset.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      213:25   aval_input
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Check for invalid parameter JM_AVAL_INPUT ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   jm_aval_input = strip(symget('JM_AVAL_INPUT'));
MPRINT(JM_AVAL_SUM_TRANS):   parens = index(jm_aval_input,'(') ;
MPRINT(JM_AVAL_SUM_TRANS):   if parens > 0 then jm_aval_input = substr(jm_aval_input,1,parens-1);
MPRINT(JM_AVAL_SUM_TRANS):   if exist(jm_aval_input) = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   curvar = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid value for parameter JM_AVAL_INPUT '" curvar 
+(-1) "'. " "This specifies the name of the dataset used as input to be transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      213:80   jm_aval_input
      213:45   curvar
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Check for invalid parameter JM_TRANS_BY ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   length curvar $100;
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   jm_aval_input = strip(symget('JM_AVAL_INPUT'));
MPRINT(JM_AVAL_SUM_TRANS):   parens = index(jm_aval_input,'(') ;
MPRINT(JM_AVAL_SUM_TRANS):   if parens > 0 then jm_aval_input = substr(jm_aval_input,1,parens-1);
MPRINT(JM_AVAL_SUM_TRANS):   dsid=open(JM_AVAL_INPUT, "i");
MPRINT(JM_AVAL_SUM_TRANS):   *** Handle multiple JM_TRANS_BY variables ***;
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   JM_TRANS_BY = strip("paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC");
MPRINT(JM_AVAL_SUM_TRANS):   count=countw(jm_trans_by,' ');
MPRINT(JM_AVAL_SUM_TRANS):   do i = 1 to count;
MPRINT(JM_AVAL_SUM_TRANS):   curvar=scan(jm_trans_by,i,' ');
MPRINT(JM_AVAL_SUM_TRANS):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_SUM_TRANS):   if varpos = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid variable: " curvar "for parameter JM_TRANS_BY 
'paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC'. " "This specifies the name of the BY variables to be 
transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   *** Handle multiple JM_TRANS_VAR variables ***;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
MPRINT(JM_AVAL_SUM_TRANS):   JM_TRANS_VAR = strip("JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC");
MPRINT(JM_AVAL_SUM_TRANS):   count=countw(JM_TRANS_VAR,' ');
MPRINT(JM_AVAL_SUM_TRANS):   do i = 1 to count;
MPRINT(JM_AVAL_SUM_TRANS):   curvar=scan(JM_TRANS_VAR,i,' ');
MPRINT(JM_AVAL_SUM_TRANS):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_SUM_TRANS):   if varpos = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid variable: " curvar "for parameter JM_TRANS_VAR 
'JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC'. " "This specifies the name of the transpose variables.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   *** Handle multiple JM_TRANS_ID variables ***;
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   JM_TRANS_ID = strip("JM_TRTVARN");
MPRINT(JM_AVAL_SUM_TRANS):   count=countw(JM_TRANS_ID,' ');
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   do i = 1 to count;
MPRINT(JM_AVAL_SUM_TRANS):   curvar=scan(JM_TRANS_ID,i,' ');
MPRINT(JM_AVAL_SUM_TRANS):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_SUM_TRANS):   if varpos = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid variable: " curvar "for parameter JM_TRANS_ID 
'JM_TRTVARN'. " "This specifies the name of the ID variable for transpose.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   rc=close(dsid);
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      213:107  jm_aval_input
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM_TRANS):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
                                                           The SAS System

SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM_TRANS):   set jm_bign1;
MPRINT(JM_AVAL_SUM_TRANS):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM_TRANS):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
SYMBOLGEN:  Macro variable JM_AVAL_INPUT resolves to JM_AVAL_ALLDATA2
MPRINT(JM_AVAL_SUM_TRANS):   proc contents data = JM_AVAL_ALLDATA2 out = vsort noprint;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: The data set WORK.VSORT has 55 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   proc sort data = vsort;
MPRINT(JM_AVAL_SUM_TRANS):   by sortedby;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 55 observations read from the data set WORK.VSORT.
NOTE: SAS sort was used.
NOTE: The data set WORK.VSORT has 55 observations and 41 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if there are any labels ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is VLABEL)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   set vsort;
MPRINT(JM_AVAL_SUM_TRANS):   if compress(label) ne '' then call symputx('vlabel','_label_');
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 55 observations read from the data set WORK.VSORT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Identify the treatment variable to be used for Prefix ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is JM_TRT_VAR)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   set vsort;
MPRINT(JM_AVAL_SUM_TRANS):   if index(lowcase(name),'trt') > 0 or index(lowcase(label),'treat') > 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('jm_trt_var',name);
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 55 observations read from the data set WORK.VSORT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   ** Verify if there are sort variables ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is SORTVARS)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   length sortvars $200;
MPRINT(JM_AVAL_SUM_TRANS):   set vsort;
MPRINT(JM_AVAL_SUM_TRANS):   retain sortvars;
MPRINT(JM_AVAL_SUM_TRANS):   if sortedby = 1 then sortvars = trim(name);
MPRINT(JM_AVAL_SUM_TRANS):   if sortedby > 1 then sortvars = trim(sortvars) || " " || trim(name);
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('sortvars',sortvars);
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 55 observations read from the data set WORK.VSORT.
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is _SORTED)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
SYMBOLGEN:  Macro variable SORTVARS resolves to 
SYMBOLGEN:  Macro variable SORTVARS resolves to 
MPRINT(JM_AVAL_SUM_TRANS):   if "" = "_none_" or "" = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_sorted','no');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Identify the suffix of the input dataset ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   jm_aval_input = upcase(trim(symget('JM_AVAL_INPUT')));
MPRINT(JM_AVAL_SUM_TRANS):   suffix = tranwrd(jm_aval_input,'JM_AVAL_SUM','');
MPRINT(JM_AVAL_SUM_TRANS):   suffix = tranwrd(suffix,'JM_AVAL_COUNT','');
MPRINT(JM_AVAL_SUM_TRANS):   suffix = tranwrd(suffix,'JM_AVAL_ALLDATA','');
MPRINT(JM_AVAL_SUM_TRANS):   *** Remove any where clauses ***;
MPRINT(JM_AVAL_SUM_TRANS):   if index(suffix,'(') then do;
MPRINT(JM_AVAL_SUM_TRANS):   suffix = substr(suffix,1,index(suffix,'(')-1);
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if the suffix is numeric ***;
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = suffix;
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'0','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'1','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'2','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'3','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'4','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'5','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'6','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'7','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'8','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'9','');
MPRINT(JM_AVAL_SUM_TRANS):   if compress(v_suffix) ne '' then do;
MPRINT(JM_AVAL_SUM_TRANS):   length aval_input $200;
MPRINT(JM_AVAL_SUM_TRANS):   aval_input = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] input dataset: " aval_input "is invalid or " "contains an invalid 
suffix number.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   else call symputx('suffix',suffix);
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      213:79   jm_aval_input
      213:140  suffix
      213:244  v_suffix
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Create a copy of the input dataset so not change it ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   curin = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   if index(curin,'(') > 0 then curin = substr(curin,1,index(curin,'(')-1);
MPRINT(JM_AVAL_SUM_TRANS):   curin = "cur_" || strip(curin);
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('CUR_INPUT', curin);
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      213:90   curin
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable CUR_INPUT resolves to cur_JM_AVAL_ALLDATA2
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   data cur_JM_AVAL_ALLDATA2;
SYMBOLGEN:  Macro variable JM_AVAL_INPUT resolves to JM_AVAL_ALLDATA2
MPRINT(JM_AVAL_SUM_TRANS):   set JM_AVAL_ALLDATA2;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_ALLDATA2.
NOTE: The data set WORK.CUR_JM_AVAL_ALLDATA2 has 252 observations and 55 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Derive the output dataset based upon the input dataset ***;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&JM_AVAL_OUTPUT" = "" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Sort the dataset if it is not done so ***;
SYMBOLGEN:  Macro variable _SORTED resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_sorted" = "no" is TRUE
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
MPRINT(JM_AVAL_SUM_TRANS):   sortvars = strip("JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC");
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('sortvars',sortvars);
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   if compress("paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC") = '' then do;
MPRINT(JM_AVAL_SUM_TRANS):   put "WA" "RNING: [jm_aval_sum_trans] is missing required parameter JM_TRANS_BY. " "This specifies the 
by variable names to be transposed. " "The following variables will be used: '" sortvars +(-1) "'.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('jm_trans_by',sortvars);
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable CUR_INPUT resolves to cur_JM_AVAL_ALLDATA2
MPRINT(JM_AVAL_SUM_TRANS):   proc sort data = cur_JM_AVAL_ALLDATA2;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   by paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 252 observations read from the data set WORK.CUR_JM_AVAL_ALLDATA2.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_JM_AVAL_ALLDATA2 has 252 observations and 55 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Apply the transpose ***;
SYMBOLGEN:  Macro variable CUR_INPUT resolves to cur_JM_AVAL_ALLDATA2
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
SYMBOLGEN:  Macro variable JM_TRT_VAR resolves to trtn
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&jm_trt_var" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_TRT_VAR resolves to trtn
MPRINT(JM_AVAL_SUM_TRANS):   proc transpose data=cur_JM_AVAL_ALLDATA2 out=JM_AVAL_TRANS1 prefix=trtn ;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   by paramn param avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC
MPRINT(JM_AVAL_SUM_TRANS):   var JM_NC JM_MEANSTDC JM_MEDIANC JM_RANGEC;
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   id JM_TRTVARN;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 252 observations read from the data set WORK.CUR_JM_AVAL_ALLDATA2.
NOTE: The data set WORK.JM_AVAL_TRANS1 has 252 observations and 13 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if _label_ is created ***;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MPRINT(JM_AVAL_SUM_TRANS):   proc contents data= JM_AVAL_TRANS1 out=vlabel noprint;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: The data set WORK.VLABEL has 13 observations and 41 variables.
                                                           The SAS System

NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is VLABEL)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   set vlabel;
MPRINT(JM_AVAL_SUM_TRANS):   if upcase(name) = '_LABEL_' then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 13 observations read from the data set WORK.VLABEL.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable VLABEL resolves to yes
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&vlabel" = "yes" is TRUE
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MPRINT(JM_AVAL_SUM_TRANS):   data JM_AVAL_TRANS1;
MPRINT(JM_AVAL_SUM_TRANS):   length JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MPRINT(JM_AVAL_SUM_TRANS):   set JM_AVAL_TRANS1;
MPRINT(JM_AVAL_SUM_TRANS):   *** Assign JM_AVAL_NAMEC to _Label_ is missing ***;
MPRINT(JM_AVAL_SUM_TRANS):   jm_aval_namec = _label_;
MPRINT(JM_AVAL_SUM_TRANS):   *** drop _label_;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: The data set WORK.JM_AVAL_TRANS1 has 252 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Sort if more than nine blocks ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MPRINT(JM_AVAL_SUM_TRANS):   set JM_AVAL_TRANS1;
MPRINT(JM_AVAL_SUM_TRANS):   retain datcnt 0;
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   if datcnt <= jm_block then datcnt = jm_block;
MPRINT(JM_AVAL_SUM_TRANS):   call symput('datcnt',datcnt);
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      213:130   213:153   
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      213:190   
NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable DATCNT resolves to          109
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition &datcnt > 9 is TRUE
MPRINT(JM_AVAL_SUM_TRANS):   data aval_output;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MPRINT(JM_AVAL_SUM_TRANS):   set JM_AVAL_TRANS1;
MPRINT(JM_AVAL_SUM_TRANS):   block=input(jm_block,best.);
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: The data set WORK.AVAL_OUTPUT has 252 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   proc sort data = aval_output;
MPRINT(JM_AVAL_SUM_TRANS):   by block ;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 252 observations read from the data set WORK.AVAL_OUTPUT.
NOTE: SAS sort was used.
NOTE: The data set WORK.AVAL_OUTPUT has 252 observations and 14 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS1
MPRINT(JM_AVAL_SUM_TRANS):   data JM_AVAL_TRANS1;
MPRINT(JM_AVAL_SUM_TRANS):   set aval_output;
MPRINT(JM_AVAL_SUM_TRANS):   drop block;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 252 observations read from the data set WORK.AVAL_OUTPUT.
NOTE: The data set WORK.JM_AVAL_TRANS1 has 252 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_SUM_TRANS):  Ending execution.
214        
215        
216           data jm_aval_trans1 ;
217            set jm_aval_trans1;
218           run ;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: The data set WORK.JM_AVAL_TRANS1 has 252 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

219        
220        
221        data JM_AVAL_ALLDATA3;
222        set JM_AVAL_ALLDATA1;
223        where JM_TYPE="COUNT";
224        jm_aval_namec = strip(put(AVALN,ECGAVAL.));
225        
226        if avisitn=0 then  JM_AVAL_LABEL=avisit;
227        else JM_AVAL_LABEL="End of "||strip(avisit);;
228        
229        run;

NOTE: There were 89 observations read from the data set WORK.JM_AVAL_ALLDATA1.
                                                           The SAS System

      WHERE JM_TYPE='COUNT';
NOTE: The data set WORK.JM_AVAL_ALLDATA3 has 89 observations and 55 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

230        
231        %JM_AVAL_SUM_TRANS(JM_AVAL_INPUT=Jm_aval_alldata3,
MLOGIC(JM_AVAL_SUM_TRANS):  Beginning execution.
MLOGIC(JM_AVAL_SUM_TRANS):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_sum_trans.sas
232           JM_AVAL_OUTPUT=JM_AVAL_TRANS2, JM_TRANS_BY=   avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL
232      ! JM_AVAL_NAMEC,
233           JM_TRANS_VAR=COLVAL , JM_TRANS_ID=JM_TRTVARN);
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_AVAL_INPUT has value Jm_aval_alldata3
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_AVAL_OUTPUT has value JM_AVAL_TRANS2
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_TRANS_BY has value avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL 
      JM_AVAL_NAMEC
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_TRANS_VAR has value COLVAL
MLOGIC(JM_AVAL_SUM_TRANS):  Parameter JM_TRANS_ID has value JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   aval_input = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   put ' ';
MPRINT(JM_AVAL_SUM_TRANS):   put "******************* Parameter Values *******************";
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_AVAL_INPUT PROCESSED - " aval_input;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS2
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_AVAL_OUTPUT PROCESSED - JM_AVAL_TRANS2";
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_TRANS_BY PROCESSED - avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL 
JM_AVAL_NAMEC";
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to COLVAL
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_TRANS_VAR PROCESSED - COLVAL";
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   PUT "ALERT:I: JM_TRANS_ID PROCESSED - JM_TRTVARN";
MPRINT(JM_AVAL_SUM_TRANS):   put "********************************************************";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put 'NOTE: [JM_AVAL_SUM_TRANS] is currently running macro %jm_aval_sum_trans version 1.0.';
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   run;
                                                           The SAS System


INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      233:81   aval_input

******************* Parameter Values *******************
ALERT:I: JM_AVAL_INPUT PROCESSED - Jm_aval_alldata3
ALERT:I: JM_AVAL_OUTPUT PROCESSED - JM_AVAL_TRANS2
ALERT:I: JM_TRANS_BY PROCESSED - avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
ALERT:I: JM_TRANS_VAR PROCESSED - COLVAL
ALERT:I: JM_TRANS_ID PROCESSED - JM_TRTVARN
********************************************************

NOTE: [JM_AVAL_SUM_TRANS] is currently running macro %jm_aval_sum_trans version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Initialize er ror checking condition ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   aval_input = strip(symget('JM_AVAL_INPUT'));
MPRINT(JM_AVAL_SUM_TRANS):   if aval_input = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] is missing required parameter JM_AVAL_INPUT. " "This specifies the 
name of the dataset used as input to be transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to COLVAL
MPRINT(JM_AVAL_SUM_TRANS):   if "COLVAL" = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] is missing required parameter JM_TRANS_VAR. " "This specifies the 
variable name which contains values to be transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   if "JM_TRTVARN" = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] is missing required parameter JM_TRANS_ID. " "This specifies the 
                                                           The SAS System

name of the ID variable used to transpose the dataset.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      233:25   aval_input
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Check for invalid parameter JM_AVAL_INPUT ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   jm_aval_input = strip(symget('JM_AVAL_INPUT'));
MPRINT(JM_AVAL_SUM_TRANS):   parens = index(jm_aval_input,'(') ;
MPRINT(JM_AVAL_SUM_TRANS):   if parens > 0 then jm_aval_input = substr(jm_aval_input,1,parens-1);
MPRINT(JM_AVAL_SUM_TRANS):   if exist(jm_aval_input) = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   curvar = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid value for parameter JM_AVAL_INPUT '" curvar 
+(-1) "'. " "This specifies the name of the dataset used as input to be transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      233:80   jm_aval_input
      233:45   curvar
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Check for invalid parameter JM_TRANS_BY ***;
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   length curvar $100;
MPRINT(JM_AVAL_SUM_TRANS):   jm_aval_input = strip(symget('JM_AVAL_INPUT'));
MPRINT(JM_AVAL_SUM_TRANS):   parens = index(jm_aval_input,'(') ;
MPRINT(JM_AVAL_SUM_TRANS):   if parens > 0 then jm_aval_input = substr(jm_aval_input,1,parens-1);
MPRINT(JM_AVAL_SUM_TRANS):   dsid=open(JM_AVAL_INPUT, "i");
MPRINT(JM_AVAL_SUM_TRANS):   *** Handle multiple JM_TRANS_BY variables ***;
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   JM_TRANS_BY = strip("avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC");
MPRINT(JM_AVAL_SUM_TRANS):   count=countw(jm_trans_by,' ');
MPRINT(JM_AVAL_SUM_TRANS):   do i = 1 to count;
MPRINT(JM_AVAL_SUM_TRANS):   curvar=scan(jm_trans_by,i,' ');
MPRINT(JM_AVAL_SUM_TRANS):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_SUM_TRANS):   if varpos = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid variable: " curvar "for parameter JM_TRANS_BY 
'avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC'. " "This specifies the name of the BY variables to 
be transposed.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   *** Handle multiple JM_TRANS_VAR variables ***;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to COLVAL
MPRINT(JM_AVAL_SUM_TRANS):   JM_TRANS_VAR = strip("COLVAL");
MPRINT(JM_AVAL_SUM_TRANS):   count=countw(JM_TRANS_VAR,' ');
MPRINT(JM_AVAL_SUM_TRANS):   do i = 1 to count;
MPRINT(JM_AVAL_SUM_TRANS):   curvar=scan(JM_TRANS_VAR,i,' ');
MPRINT(JM_AVAL_SUM_TRANS):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_SUM_TRANS):   if varpos = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to COLVAL
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid variable: " curvar "for parameter JM_TRANS_VAR 
'COLVAL'. " "This specifies the name of the transpose variables.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   *** Handle multiple JM_TRANS_ID variables ***;
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   JM_TRANS_ID = strip("JM_TRTVARN");
MPRINT(JM_AVAL_SUM_TRANS):   count=countw(JM_TRANS_ID,' ');
MPRINT(JM_AVAL_SUM_TRANS):   do i = 1 to count;
MPRINT(JM_AVAL_SUM_TRANS):   curvar=scan(JM_TRANS_ID,i,' ');
MPRINT(JM_AVAL_SUM_TRANS):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_SUM_TRANS):   if varpos = 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] contains an invalid variable: " curvar "for parameter JM_TRANS_ID 
'JM_TRTVARN'. " "This specifies the name of the ID variable for transpose.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   rc=close(dsid);
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      233:107  jm_aval_input
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_SUM_TRANS):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_SUM_TRANS):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_SUM_TRANS):   set jm_bign1;
MPRINT(JM_AVAL_SUM_TRANS):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM_TRANS):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
SYMBOLGEN:  Macro variable JM_AVAL_INPUT resolves to Jm_aval_alldata3
MPRINT(JM_AVAL_SUM_TRANS):   proc contents data = Jm_aval_alldata3 out = vsort noprint;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: The data set WORK.VSORT has 55 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   proc sort data = vsort;
MPRINT(JM_AVAL_SUM_TRANS):   by sortedby;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 55 observations read from the data set WORK.VSORT.
NOTE: SAS sort was used.
NOTE: The data set WORK.VSORT has 55 observations and 41 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
                                                           The SAS System

      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if there are any labels ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is VLABEL)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   set vsort;
MPRINT(JM_AVAL_SUM_TRANS):   if compress(label) ne '' then call symputx('vlabel','_label_');
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 55 observations read from the data set WORK.VSORT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Identify the treatment variable to be used for Prefix ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is JM_TRT_VAR)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   set vsort;
MPRINT(JM_AVAL_SUM_TRANS):   if index(lowcase(name),'trt') > 0 or index(lowcase(label),'treat') > 0 then do;
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('jm_trt_var',name);
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 55 observations read from the data set WORK.VSORT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   ** Verify if there are sort variables ***;
MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is SORTVARS)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   length sortvars $200;
MPRINT(JM_AVAL_SUM_TRANS):   set vsort;
MPRINT(JM_AVAL_SUM_TRANS):   retain sortvars;
MPRINT(JM_AVAL_SUM_TRANS):   if sortedby = 1 then sortvars = trim(name);
MPRINT(JM_AVAL_SUM_TRANS):   if sortedby > 1 then sortvars = trim(sortvars) || " " || trim(name);
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('sortvars',sortvars);
MPRINT(JM_AVAL_SUM_TRANS):   run;
                                                           The SAS System


NOTE: There were 55 observations read from the data set WORK.VSORT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is _SORTED)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
SYMBOLGEN:  Macro variable SORTVARS resolves to 
SYMBOLGEN:  Macro variable SORTVARS resolves to 
MPRINT(JM_AVAL_SUM_TRANS):   if "" = "_none_" or "" = "" then do;
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_sorted','no');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Identify the suffix of the input dataset ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   jm_aval_input = upcase(trim(symget('JM_AVAL_INPUT')));
MPRINT(JM_AVAL_SUM_TRANS):   suffix = tranwrd(jm_aval_input,'JM_AVAL_SUM','');
MPRINT(JM_AVAL_SUM_TRANS):   suffix = tranwrd(suffix,'JM_AVAL_COUNT','');
MPRINT(JM_AVAL_SUM_TRANS):   suffix = tranwrd(suffix,'JM_AVAL_ALLDATA','');
MPRINT(JM_AVAL_SUM_TRANS):   *** Remove any where clauses ***;
MPRINT(JM_AVAL_SUM_TRANS):   if index(suffix,'(') then do;
MPRINT(JM_AVAL_SUM_TRANS):   suffix = substr(suffix,1,index(suffix,'(')-1);
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if the suffix is numeric ***;
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = suffix;
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'0','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'1','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'2','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'3','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'4','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'5','');
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'6','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'7','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'8','');
MPRINT(JM_AVAL_SUM_TRANS):   v_suffix = tranwrd(v_suffix,'9','');
MPRINT(JM_AVAL_SUM_TRANS):   if compress(v_suffix) ne '' then do;
MPRINT(JM_AVAL_SUM_TRANS):   length aval_input $200;
MPRINT(JM_AVAL_SUM_TRANS):   aval_input = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   put "ER" "ROR: [jm_aval_sum_trans] input dataset: " aval_input "is invalid or " "contains an invalid 
suffix number.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symput('_err','yes');
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   else call symputx('suffix',suffix);
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      233:79   jm_aval_input
      233:140  suffix
      233:244  v_suffix
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Create a copy of the input dataset so not change it ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   curin = symget('JM_AVAL_INPUT');
MPRINT(JM_AVAL_SUM_TRANS):   if index(curin,'(') > 0 then curin = substr(curin,1,index(curin,'(')-1);
MPRINT(JM_AVAL_SUM_TRANS):   curin = "cur_" || strip(curin);
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('CUR_INPUT', curin);
MPRINT(JM_AVAL_SUM_TRANS):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      233:90   curin
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


SYMBOLGEN:  Macro variable CUR_INPUT resolves to cur_Jm_aval_alldata3
MPRINT(JM_AVAL_SUM_TRANS):   data cur_Jm_aval_alldata3;
SYMBOLGEN:  Macro variable JM_AVAL_INPUT resolves to Jm_aval_alldata3
MPRINT(JM_AVAL_SUM_TRANS):   set Jm_aval_alldata3;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 89 observations read from the data set WORK.JM_AVAL_ALLDATA3.
NOTE: The data set WORK.CUR_JM_AVAL_ALLDATA3 has 89 observations and 55 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Derive the output dataset based upon the input dataset ***;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS2
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&JM_AVAL_OUTPUT" = "" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Sort the dataset if it is not done so ***;
SYMBOLGEN:  Macro variable _SORTED resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&_sorted" = "no" is TRUE
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to COLVAL
MPRINT(JM_AVAL_SUM_TRANS):   sortvars = strip("COLVAL");
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('sortvars',sortvars);
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   if compress("avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC") = '' then 
do;
MPRINT(JM_AVAL_SUM_TRANS):   put "WA" "RNING: [jm_aval_sum_trans] is missing required parameter JM_TRANS_BY. " "This specifies the 
by variable names to be transposed. " "The following variables will be used: '" sortvars +(-1) "'.";
MPRINT(JM_AVAL_SUM_TRANS):   put " ";
MPRINT(JM_AVAL_SUM_TRANS):   call symputx('jm_trans_by',sortvars);
MPRINT(JM_AVAL_SUM_TRANS):   end;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable CUR_INPUT resolves to cur_Jm_aval_alldata3
MPRINT(JM_AVAL_SUM_TRANS):   proc sort data = cur_Jm_aval_alldata3;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   by avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 89 observations read from the data set WORK.CUR_JM_AVAL_ALLDATA3.
NOTE: SAS sort was used.
NOTE: The data set WORK.CUR_JM_AVAL_ALLDATA3 has 89 observations and 55 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Apply the transpose ***;
SYMBOLGEN:  Macro variable CUR_INPUT resolves to cur_Jm_aval_alldata3
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS2
SYMBOLGEN:  Macro variable JM_TRT_VAR resolves to trtn
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&jm_trt_var" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_TRT_VAR resolves to trtn
MPRINT(JM_AVAL_SUM_TRANS):   proc transpose data=cur_Jm_aval_alldata3 out=JM_AVAL_TRANS2 prefix=trtn ;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_TRANS_BY resolves to avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC
MPRINT(JM_AVAL_SUM_TRANS):   by avisitn avisit paramn param avaln grpvar JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEC;
SYMBOLGEN:  Macro variable JM_TRANS_VAR resolves to COLVAL
MPRINT(JM_AVAL_SUM_TRANS):   var COLVAL;
SYMBOLGEN:  Macro variable JM_TRANS_ID resolves to JM_TRTVARN
MPRINT(JM_AVAL_SUM_TRANS):   id JM_TRTVARN;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 89 observations read from the data set WORK.CUR_JM_AVAL_ALLDATA3.
NOTE: The data set WORK.JM_AVAL_TRANS2 has 26 observations and 14 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Verify if _label_ is created ***;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS2
MPRINT(JM_AVAL_SUM_TRANS):   proc contents data= JM_AVAL_TRANS2 out=vlabel noprint;
                                                           The SAS System

MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: The data set WORK.VLABEL has 14 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_SUM_TRANS):  %LET (variable name is VLABEL)
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
MPRINT(JM_AVAL_SUM_TRANS):   set vlabel;
MPRINT(JM_AVAL_SUM_TRANS):   if upcase(name) = '_LABEL_' then call symput('vlabel','yes');
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 14 observations read from the data set WORK.VLABEL.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable VLABEL resolves to no
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition "&vlabel" = "yes" is FALSE
MPRINT(JM_AVAL_SUM_TRANS):   *** Sort if more than nine blocks ***;
MPRINT(JM_AVAL_SUM_TRANS):   data _null_;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS2
MPRINT(JM_AVAL_SUM_TRANS):   set JM_AVAL_TRANS2;
MPRINT(JM_AVAL_SUM_TRANS):   retain datcnt 0;
MPRINT(JM_AVAL_SUM_TRANS):   if datcnt <= jm_block then datcnt = jm_block;
MPRINT(JM_AVAL_SUM_TRANS):   call symput('datcnt',datcnt);
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      233:130   233:153   
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      233:190   
NOTE: There were 26 observations read from the data set WORK.JM_AVAL_TRANS2.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

                                                           The SAS System

SYMBOLGEN:  Macro variable DATCNT resolves to          113
MLOGIC(JM_AVAL_SUM_TRANS):  %IF condition &datcnt > 9 is TRUE
MPRINT(JM_AVAL_SUM_TRANS):   data aval_output;
SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS2
MPRINT(JM_AVAL_SUM_TRANS):   set JM_AVAL_TRANS2;
MPRINT(JM_AVAL_SUM_TRANS):   block=input(jm_block,best.);
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 26 observations read from the data set WORK.JM_AVAL_TRANS2.
NOTE: The data set WORK.AVAL_OUTPUT has 26 observations and 15 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   proc sort data = aval_output;
MPRINT(JM_AVAL_SUM_TRANS):   by block ;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 26 observations read from the data set WORK.AVAL_OUTPUT.
NOTE: SAS sort was used.
NOTE: The data set WORK.AVAL_OUTPUT has 26 observations and 15 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_AVAL_OUTPUT resolves to JM_AVAL_TRANS2
MPRINT(JM_AVAL_SUM_TRANS):   data JM_AVAL_TRANS2;
MPRINT(JM_AVAL_SUM_TRANS):   set aval_output;
MPRINT(JM_AVAL_SUM_TRANS):   drop block;
MPRINT(JM_AVAL_SUM_TRANS):   run;

NOTE: There were 26 observations read from the data set WORK.AVAL_OUTPUT.
NOTE: The data set WORK.JM_AVAL_TRANS2 has 26 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_SUM_TRANS):   *** Mark the end of parameter checking ***;
                                                           The SAS System

MLOGIC(JM_AVAL_SUM_TRANS):  Ending execution.
234        
235           data jm_aval_trans2 ;
236            set jm_aval_trans2;
237        
238        
239         run ;

NOTE: There were 26 observations read from the data set WORK.JM_AVAL_TRANS2.
NOTE: The data set WORK.JM_AVAL_TRANS2 has 26 observations and 14 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

240        
241        data JM_AVAL_TRANS3;
242        set JM_AVAL_TRANS1(in=a) JM_AVAL_TRANS2(in=b) ;
243        
244        run;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: There were 26 observations read from the data set WORK.JM_AVAL_TRANS2.
NOTE: The data set WORK.JM_AVAL_TRANS3 has 278 observations and 15 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

245        
246        proc sort data=JM_AVAL_TRANS3;
247        by paramn avisitn avisit JM_BLOCK ;
248        run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_TRANS3.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_AVAL_TRANS3 has 278 observations and 15 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


249        
250        *------------------------------------------------------------------------------------------------------------------------
250      ! ----------;
251        
252        *  APPLY PAGEBREAK
253        *------------------------------------------------------------------------------------------------------------------------
253      ! ----------;
254        
255        %JM_PGBRK (JM_INDSN1=JM_AVAL_TRANS1, JM_INDSN2=JM_AVAL_TRANS2, JM_BREAKCNT=12, JM_CONTOPT=N, JM_GROUPOPT=N,
255      ! JM_OUTDSN=JM_AVAL_ALLREPORT1);
MLOGIC:  Beginning compilation of JM_PGBRK using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_pgbrk.sas.
MLOGIC:  Ending compilation of JM_PGBRK.
MLOGIC(JM_PGBRK):  Beginning execution.
MLOGIC(JM_PGBRK):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_pgbrk.sas
MLOGIC(JM_PGBRK):  Parameter JM_INDSN1 has value JM_AVAL_TRANS1
MLOGIC(JM_PGBRK):  Parameter JM_INDSN2 has value JM_AVAL_TRANS2
MLOGIC(JM_PGBRK):  Parameter JM_BREAKCNT has value 12
MLOGIC(JM_PGBRK):  Parameter JM_CONTOPT has value N
MLOGIC(JM_PGBRK):  Parameter JM_GROUPOPT has value N
MLOGIC(JM_PGBRK):  Parameter JM_OUTDSN has value JM_AVAL_ALLREPORT1
MLOGIC(JM_PGBRK):  Parameter JM_REPTYPE has value Table
MLOGIC(JM_PGBRK):  Parameter JM_FCOL_WIDTH has value 55
MPRINT(JM_PGBRK):   *** Document in log what parameter value specified ***;
MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   put ' ';
MPRINT(JM_PGBRK):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_INDSN1 PROCESSED - JM_AVAL_TRANS1";
SYMBOLGEN:  Macro variable JM_INDSN2 resolves to JM_AVAL_TRANS2
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_INDSN2 PROCESSED - JM_AVAL_TRANS2";
SYMBOLGEN:  Macro variable JM_BREAKCNT resolves to 12
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_BREAKCNT PROCESSED - 12";
SYMBOLGEN:  Macro variable JM_CONTOPT resolves to N
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_CONTOPT PROCESSED - N";
SYMBOLGEN:  Macro variable JM_GROUPOPT resolves to N
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_GROUPOPT PROCESSED - N";
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_OUTDSN PROCESSED - JM_AVAL_ALLREPORT1";
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_REPTYPE PROCESSED - Table";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_FCOL_WIDTH resolves to 55
MPRINT(JM_PGBRK):   PUT "ALERT:I: JM_FCOL_WIDTH PROCESSED - 55";
MPRINT(JM_PGBRK):   put "********************************************************";
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   put 'NOTE: [JM_PGBRK] is currently running macro %jm_pgbrk version 1.1.';
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN1 PROCESSED - JM_AVAL_TRANS1
ALERT:I: JM_INDSN2 PROCESSED - JM_AVAL_TRANS2
ALERT:I: JM_BREAKCNT PROCESSED - 12
ALERT:I: JM_CONTOPT PROCESSED - N
ALERT:I: JM_GROUPOPT PROCESSED - N
ALERT:I: JM_OUTDSN PROCESSED - JM_AVAL_ALLREPORT1
ALERT:I: JM_REPTYPE PROCESSED - Table
ALERT:I: JM_FCOL_WIDTH PROCESSED - 55
********************************************************

NOTE: [JM_PGBRK] is currently running macro %jm_pgbrk version 1.1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PGBRK):   *** Initialize er ror checking condition ***;
MLOGIC(JM_PGBRK):  %LET (variable name is _ERR)
MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   *** Apply default if not specified ***;
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
SYMBOLGEN:  Macro variable JM_INDSN2 resolves to JM_AVAL_TRANS2
MPRINT(JM_PGBRK):   if "JM_AVAL_TRANS1" = "" and "JM_AVAL_TRANS2" = "" then do;
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   put "ER" "ROR: [JM_PGBRK] is missing required parameter JM_INDSN1 and JM_INDSN2. " "They can not both be 
missing. This specifies the input " "SAS dataset name (i.e. JM_AVAL_SUM1, JM_AVAL_COUNT1).";
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   call symput('_err','yes');
MPRINT(JM_PGBRK):   end;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   if "JM_AVAL_ALLREPORT1" = "" then do;
                                                           The SAS System

MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   put "ER" "ROR: [JM_PGBRK] is missing required parameter JM_OUTDSN. " "This specifies the output SAS dataset 
name (i.e. JM_COUNTTFL).";
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   call symput('_err','yes');
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PGBRK):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PGBRK):   *** Verify invalid values ***;
MPRINT(JM_PGBRK):   data _null_;
SYMBOLGEN:  Macro variable JM_BREAKCNT resolves to 12
MPRINT(JM_PGBRK):   breakcnt = strip("12");
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'0','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'1','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'2','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'3','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'4','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'5','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'6','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'7','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'8','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'9','');
MPRINT(JM_PGBRK):   breakcnt = tranwrd(breakcnt,'.','');
MPRINT(JM_PGBRK):   if breakcnt ne '' then do;
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   put "ER" "ROR: [JM_PGBRK] contain invalid characters (" breakcnt +(-1) ") for JM_BREAKCNT parameter. " "This 
specifies the position count used to break page (i.e. 14).";
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   call symput('_err','yes');
MPRINT(JM_PGBRK):   end;
SYMBOLGEN:  Macro variable JM_CONTOPT resolves to N
MPRINT(JM_PGBRK):   CONTOPT=upcase(strip("N"));
MPRINT(JM_PGBRK):   if CONTOPT ne '' and CONTOPT not in("Y","YES", "N","NO") then do;
MPRINT(JM_PGBRK):   put " ";
                                                           The SAS System

MPRINT(JM_PGBRK):   put "ER" "ROR: [JM_PGBRK] contain invalid value for JM_CONTOPT parameter. " "This specifies the option to apply 
the continue portion of the report (i.e. Y).";
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   call symput('_err','yes');
MPRINT(JM_PGBRK):   end;
SYMBOLGEN:  Macro variable JM_GROUPOPT resolves to N
MPRINT(JM_PGBRK):   GROUPOPT=upcase(strip("N"));
MPRINT(JM_PGBRK):   if GROUPOPT ne '' and GROUPOPT not in("Y","YES", "N","NO") then do;
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   put "ER" "ROR: [JM_PGBRK] contain invalid value for JM_GROUPOPT parameter. " "This specifies the option to sort 
and report by default grouping variables (i.e. Y).";
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   call symput('_err','yes');
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PGBRK):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PGBRK):   *** Verify if $STATSF format exists ***;
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MLOGIC(JM_PGBRK):  Beginning compilation of LOWCASE using the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas.
MLOGIC(JM_PGBRK):  Ending compilation of LOWCASE.
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_PGBRK):  %IF condition "&jm_indsn1" ne "" and %lowcase("&jm_reptype")="table" is TRUE
MPRINT(JM_PGBRK):   proc sql noprint;
MPRINT(JM_PGBRK):   create table v_formats as select libname, fmtname, source from dictionary.formats where upcase(fmtname) = 
"$STATSF";
NOTE: Table WORK.V_FORMATS created, with 1 rows and 3 columns.

MPRINT(JM_PGBRK):   quit;
NOTE: PROCEDURE SQL used (Total process time):
                                                           The SAS System

      real time           0.05 seconds
      cpu time            0.06 seconds
      

MLOGIC(JM_PGBRK):  %LET (variable name is FMTEXIST)
MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   set v_formats;
MPRINT(JM_PGBRK):   if fmtname = "$STATSF" then call symputx('fmtexist','yes');
MPRINT(JM_PGBRK):   run;

NOTE: There were 1 observations read from the data set WORK.V_FORMATS.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PGBRK):   data _null_;
SYMBOLGEN:  Macro variable FMTEXIST resolves to yes
MPRINT(JM_PGBRK):   if "yes" = "no" then do;
MPRINT(JM_PGBRK):   put " ";
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MPRINT(JM_PGBRK):   put "ER" "ROR: [JM_PGBRK] is missing format $STATSF which used with input dataset: JM_AVAL_TRANS1.";
MPRINT(JM_PGBRK):   put " ";
MPRINT(JM_PGBRK):   call symput('_err','yes');
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PGBRK):  %IF condition "&_err" = "yes" is FALSE
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_PGBRK):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
                                                           The SAS System

MPRINT(JM_PGBRK):   *** Verify missing _DEFAULT_BYVARS ***;
SYMBOLGEN:  Macro variable JM_GROUPOPT resolves to N
SYMBOLGEN:  Macro variable JM_GROUPOPT resolves to N
SYMBOLGEN:  Macro variable JM_CONTOPT resolves to N
SYMBOLGEN:  Macro variable JM_CONTOPT resolves to N
MLOGIC(JM_PGBRK):  %IF condition "&jm_groupopt"="Y" or "&jm_groupopt"="YES" or "&jm_contopt"="Y" or "&jm_contopt"="YES" is FALSE
SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_PGBRK):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_PGBRK):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_PGBRK):  %LET (variable name is V_BIGN)
MLOGIC(JM_PGBRK):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_PGBRK):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_PGBRK):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_PGBRK):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_PGBRK):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_PGBRK):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_PGBRK):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_PGBRK):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_PGBRK):   set jm_bign1;
MPRINT(JM_PGBRK):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_PGBRK):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MLOGIC(JM_PGBRK):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MPRINT(JM_PGBRK):   *** Identify the optional keyword 'descending' for _DEFAULT_BYVARS ***;
MLOGIC(JM_PGBRK):  %LET (variable name is _DEFAULT_BYVAR2)
MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   byvars = symget('_default_byvars');
MPRINT(JM_PGBRK):   call symputx('_default_byvars2',byvars);
MPRINT(JM_PGBRK):   byvars = upcase(byvars);
MPRINT(JM_PGBRK):   if index(byvars,'DESCENDING') then do;
MPRINT(JM_PGBRK):   byvars2 = tranwrd(byvars,'DESCENDING','');
MPRINT(JM_PGBRK):   call symputx('_default_byvars2',byvars2);
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      255:24   byvars
      255:192  byvars2
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MLOGIC(JM_PGBRK):  %IF condition "&jm_indsn1" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MPRINT(JM_PGBRK):   proc contents data = JM_AVAL_TRANS1 noprint out = v_indata;
MPRINT(JM_PGBRK):   run;

NOTE: The data set WORK.V_INDATA has 13 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(JM_PGBRK):  %LET (variable name is V_NAME)
MLOGIC(JM_PGBRK):  %LET (variable name is V_NAMEC)
MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   set v_indata;
MPRINT(JM_PGBRK):   if lowcase(name) = '_name_' then call symputx('v_name','yes');
                                                           The SAS System

MPRINT(JM_PGBRK):   *** Handle case of numeric JM_AVAL_NAMEC **;
MPRINT(JM_PGBRK):   if upcase(strip(name)) = 'JM_AVAL_NAMEC' and type = 1 then call symputx('v_namec','num');
MPRINT(JM_PGBRK):   run;

NOTE: There were 13 observations read from the data set WORK.V_INDATA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PGBRK):   *** Update JM_AVAL_NAMEC to be character if numeric ***;
SYMBOLGEN:  Macro variable V_NAMEC resolves to char
MLOGIC(JM_PGBRK):  %IF condition "&v_namec" = "num" is FALSE
SYMBOLGEN:  Macro variable V_NAME resolves to yes
MLOGIC(JM_PGBRK):  %IF condition "&v_name" = "yes" is TRUE
MPRINT(JM_PGBRK):   *** Verify if formats for STATSF are valid ***;
MPRINT(JM_PGBRK):   PROC FORMAT library=work.formats cntlout=v_trtfmt2 ;
MPRINT(JM_PGBRK):   RUN;

NOTE: PROCEDURE FORMAT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: The data set WORK.V_TRTFMT2 has 387 observations and 21 variables.

MPRINT(JM_PGBRK):   data v_trtfmt3 (keep = _name_);
MPRINT(JM_PGBRK):   set v_trtfmt2;
MPRINT(JM_PGBRK):   where upcase(fmtname)='STATSF';
MPRINT(JM_PGBRK):   length _name_ $40;
MPRINT(JM_PGBRK):   _name_ = start;
MPRINT(JM_PGBRK):   run;

NOTE: There were 5 observations read from the data set WORK.V_TRTFMT2.
      WHERE UPCASE(fmtname)='STATSF';
NOTE: The data set WORK.V_TRTFMT3 has 5 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
                                                           The SAS System

MPRINT(JM_PGBRK):   proc sort data = JM_AVAL_TRANS1 out= v_trtfmt4;
MPRINT(JM_PGBRK):   by _name_;
MPRINT(JM_PGBRK):   run;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: SAS sort was used.
NOTE: The data set WORK.V_TRTFMT4 has 252 observations and 13 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PGBRK):   data _null_;
MPRINT(JM_PGBRK):   length _name_ $40;
MPRINT(JM_PGBRK):   merge v_trtfmt4 (in=A) v_trtfmt3 (in=B);
MPRINT(JM_PGBRK):   by _name_;
MPRINT(JM_PGBRK):   if (A) and not(B) then do;
MPRINT(JM_PGBRK):   put ' ';
MPRINT(JM_PGBRK):   put "WAR" "NING:[jm_pgbrk] contains a value '" _name_ +(-1) "' as a the statistic in _NAME_ " "variable but is 
not found in $STATSF format. ";
MPRINT(JM_PGBRK):   put ' ';
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   run;

NOTE: There were 252 observations read from the data set WORK.V_TRTFMT4.
NOTE: There were 5 observations read from the data set WORK.V_TRTFMT3.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_PGBRK):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
MPRINT(JM_PGBRK):   *** Define group variable for Summary dataset ***;
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MPRINT(JM_PGBRK):   DATA JM_AVAL_TRANS1;
                                                           The SAS System

MPRINT(JM_PGBRK):   LENGTH GROUPVAR GROUPLABEL JM_AVAL_NAMEC $2000;
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MPRINT(JM_PGBRK):   SET JM_AVAL_TRANS1;
MPRINT(JM_PGBRK):   GROUPVAR=jm_aval_namec;
MPRINT(JM_PGBRK):   GROUPLABEL=JM_AVAL_LABEL;
MPRINT(JM_PGBRK):   *** Assign the statistics format order only for JM_AVAL_SUM ***;
MPRINT(JM_PGBRK):   if upcase(_name_) = 'JM_AVAL_COUNTC' then GROUPVARN = 0;
MPRINT(JM_PGBRK):   else if upcase(_name_) = 'COLVAL' then GROUPVARN = .5;
MPRINT(JM_PGBRK):   else GROUPVARN=INPUT(PUT(_name_,$STATSF.),BEST.);
MPRINT(JM_PGBRK):   jm_aval_namen=GROUPVARN;
MPRINT(JM_PGBRK):   _TYPE_="SUMM";
MPRINT(JM_PGBRK):   RUN;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: The data set WORK.JM_AVAL_TRANS1 has 252 observations and 18 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN2 resolves to JM_AVAL_TRANS2
MLOGIC(JM_PGBRK):  %IF condition "&jm_indsn2" ne "" is TRUE
MPRINT(JM_PGBRK):   *** Define group variable for Count dataset ***;
SYMBOLGEN:  Macro variable JM_INDSN2 resolves to JM_AVAL_TRANS2
MPRINT(JM_PGBRK):   data JM_AVAL_TRANS2;
SYMBOLGEN:  Macro variable JM_INDSN2 resolves to JM_AVAL_TRANS2
MPRINT(JM_PGBRK):   set JM_AVAL_TRANS2;
MPRINT(JM_PGBRK):   if missing(GROUPvarn) then GROUPVARN=1;
MPRINT(JM_PGBRK):   _TYPE_="FREQ";
MPRINT(JM_PGBRK):   run;

NOTE: There were 26 observations read from the data set WORK.JM_AVAL_TRANS2.
NOTE: The data set WORK.JM_AVAL_TRANS2 has 26 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_PGBRK):   *** Combine the input datasets ***;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   data JM_AVAL_ALLREPORT1;
                                                           The SAS System

MPRINT(JM_PGBRK):   length trt: $50.;
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
MLOGIC(JM_PGBRK):  %IF condition "&jm_indsn1" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN1 resolves to JM_AVAL_TRANS1
SYMBOLGEN:  Macro variable JM_INDSN2 resolves to JM_AVAL_TRANS2
MLOGIC(JM_PGBRK):  %IF condition "&jm_indsn2" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN2 resolves to JM_AVAL_TRANS2
MPRINT(JM_PGBRK):   set JM_AVAL_TRANS1 JM_AVAL_TRANS2 ;
MPRINT(JM_PGBRK):   orig_rec_num=_n_;
MPRINT(JM_PGBRK):   run;

NOTE: There were 252 observations read from the data set WORK.JM_AVAL_TRANS1.
NOTE: There were 26 observations read from the data set WORK.JM_AVAL_TRANS2.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 278 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   data JM_AVAL_ALLREPORT1__;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   set JM_AVAL_ALLREPORT1 end=eos;
MPRINT(JM_PGBRK):   if _n_=1 then first_len=length(strip(jm_aval_namec));
MPRINT(JM_PGBRK):  retain first_len;
SYMBOLGEN:  Macro variable JM_FCOL_WIDTH resolves to 55
MPRINT(JM_PGBRK):   pref_len=max(first_len,55);
MPRINT(JM_PGBRK):   if eos then call symputx("split_lenxx",strip(put(pref_len,best.)));
MPRINT(JM_PGBRK):   run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1__ has 278 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   data JM_AVAL_ALLREPORT1__x;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   set JM_AVAL_ALLREPORT1__;
                                                           The SAS System

SYMBOLGEN:  Macro variable SPLIT_LENXX resolves to 55
MPRINT(JM_PGBRK):   length nystr $55;
MPRINT(JM_PGBRK):   *** Identify leading space ***;
MPRINT(JM_PGBRK):   length lspace $40;
MPRINT(JM_PGBRK):   lspace = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
MPRINT(JM_PGBRK):   do i = 1 to length(jm_aval_namec);
MPRINT(JM_PGBRK):   if substr(jm_aval_namec,i,1) ne ' ' then do;
MPRINT(JM_PGBRK):   if i = 1 then lspace = '';
MPRINT(JM_PGBRK):   else lspace = substr(lspace,1,i);
MPRINT(JM_PGBRK):   i = length(jm_aval_namec);
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   str = compbl(jm_aval_namec);
MPRINT(JM_PGBRK):   do i = 1 to countw(str,' ');
MPRINT(JM_PGBRK):   word = scan(str,i,' ');
SYMBOLGEN:  Macro variable SPLIT_LENXX resolves to 55
MPRINT(JM_PGBRK):   if length(nystr) + length(word) + 1 > 55 then do;
MPRINT(JM_PGBRK):   output;
MPRINT(JM_PGBRK):   nystr = word;
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   else nystr = catx(' ',nystr,scan(str,i,' '));
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   if nystr ne '' then do;
MPRINT(JM_PGBRK):   *** Insert back leading space ***;
MPRINT(JM_PGBRK):   if lspace ne '' then nystr = tranwrd(trim(lspace) || nystr,'~',' ') ;
MPRINT(JM_PGBRK):   output;
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   keep orig_rec_num nystr;
MPRINT(JM_PGBRK):   run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1__.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1__X has 278 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   proc transpose data=JM_AVAL_ALLREPORT1__x out=JM_AVAL_ALLREPORT1__x1 (drop=_name_) prefix=new_splitvar;
MPRINT(JM_PGBRK):   by orig_rec_num;
                                                           The SAS System

MPRINT(JM_PGBRK):   var nystr;
MPRINT(JM_PGBRK):   run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1__X.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1__X1 has 278 observations and 2 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   data JM_AVAL_ALLREPORT1__x2;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   set JM_AVAL_ALLREPORT1__x1;
MPRINT(JM_PGBRK):   by orig_rec_num;
MPRINT(JM_PGBRK):   *** Identify leading space ***;
MPRINT(JM_PGBRK):   length lspace $40;
MPRINT(JM_PGBRK):   lspace = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
MPRINT(JM_PGBRK):   do i = 1 to length(new_splitvar1);
MPRINT(JM_PGBRK):   if substr(new_splitvar1,i,1) ne ' ' then do;
MPRINT(JM_PGBRK):   if i = 1 then lspace = '';
MPRINT(JM_PGBRK):   else lspace = substr(lspace,1,i);
MPRINT(JM_PGBRK):   i = length(new_splitvar1);
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   length new_jm_aval_namec_txt $2000;
MPRINT(JM_PGBRK):   new_jm_aval_namec_txt=catx('^n^{nbspace 4}', of new_splitvar:);
MPRINT(JM_PGBRK):   *** Insert back leading space ***;
MPRINT(JM_PGBRK):   if lspace ne '' then new_jm_aval_namec_txt = tranwrd(trim(lspace) || new_jm_aval_namec_txt,'~',' ') ;
MPRINT(JM_PGBRK):   keep orig_rec_num new_jm_aval_namec_txt;
MPRINT(JM_PGBRK):   run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1__X1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1__X2 has 278 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   data JM_AVAL_ALLREPORT1__;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   merge JM_AVAL_ALLREPORT1__ JM_AVAL_ALLREPORT1__x2;
MPRINT(JM_PGBRK):   by orig_rec_num;
MPRINT(JM_PGBRK):   drop jm_aval_namec;
MPRINT(JM_PGBRK):   rename new_jm_aval_namec_txt=jm_aval_namec;
MPRINT(JM_PGBRK):   run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1__.
NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1__X2.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1__ has 278 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   data JM_AVAL_ALLREPORT1__;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   set JM_AVAL_ALLREPORT1__;
MPRINT(JM_PGBRK):   n_strings=ceil(length(strip(jm_aval_namec))/pref_len);
MPRINT(JM_PGBRK):   string_num=1;
MPRINT(JM_PGBRK):   output;
MPRINT(JM_PGBRK):   if n_strings gt 1 then do;
MPRINT(JM_PGBRK):   do i=2 to n_strings;
MPRINT(JM_PGBRK):   to_be_deleted='Y';
MPRINT(JM_PGBRK):   string_num=i;
MPRINT(JM_PGBRK):   output;
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   end;
MPRINT(JM_PGBRK):   run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1__.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1__ has 278 observations and 27 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_PGBRK):   proc sql;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   create table JM_AVAL_ALLREPORT1 as select a.*,max(string_num) as max_str_num from JM_AVAL_ALLREPORT1__ as a 
group by jm_aval_namec order by orig_rec_num,string_num;
NOTE: The query requires remerging summary statistics back with the original data.
NOTE: SAS threaded sort was used.
NOTE: Table WORK.JM_AVAL_ALLREPORT1 created, with 278 rows and 28 columns.

MPRINT(JM_PGBRK):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable JM_GROUPOPT resolves to N
SYMBOLGEN:  Macro variable JM_GROUPOPT resolves to N
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_PGBRK):  %IF condition ("&jm_groupopt"="Y" or "&jm_groupopt"="YES") and %lowcase("&jm_reptype")="table" is FALSE
SYMBOLGEN:  Macro variable JM_CONTOPT resolves to N
SYMBOLGEN:  Macro variable JM_CONTOPT resolves to N
MLOGIC(JM_PGBRK):  %IF condition "&jm_contopt"="Y" or "&jm_contopt"="YES" is FALSE
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_PGBRK):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   data JM_AVAL_ALLREPORT1;
SYMBOLGEN:  Macro variable JM_OUTDSN resolves to JM_AVAL_ALLREPORT1
MPRINT(JM_PGBRK):   set JM_AVAL_ALLREPORT1;
MPRINT(JM_PGBRK):   where to_be_deleted ne 'Y';
MPRINT(JM_PGBRK):   run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
      WHERE to_be_deleted not = 'Y';
                                                           The SAS System

NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 278 observations and 28 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_PGBRK):  %IF condition %lowcase("&jm_reptype")="listing" is FALSE
MPRINT(JM_PGBRK):   *** Mark the end of parameter checking ***;
MLOGIC(JM_PGBRK):  Ending execution.
256        
257        proc sort data=jm_aval_allreport1;
258        by paramn avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEN JM_AVAL_NAMEC;
259        run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 278 observations and 28 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

260        
261        
262        
263        
264        data jm_aval_allreport1;
265        set jm_aval_allreport1;
266        by paramn avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEN JM_AVAL_NAMEC;
267        
268         block=jm_block;
269        
270         if avaln ne . then do;
271            JM_AVAL_NAMEN=AVALN;
272             GROUPVARN=AVALN;
                                                           The SAS System

273            _LABEL_=grpvar;
274           end;
275        
276           if avisitn=0 then  GROUPLABEL=avisit;
277        else GROUPLABEL="End of "||strip(avisit);
278        
279        if paramn in (106,201) then do;
280        
281           if avisitn in (-1,0) then  GROUPLABEL=avisit;
282        else GROUPLABEL="End of "||strip(avisit);
283        GROUPVAR=grpvar;
284        end;
285        run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 278 observations and 29 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

286        
287        
288        data dummy ;
289        set jm_aval_allreport1;
290        by paramn avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEN JM_AVAL_NAMEC;
291        if first.JM_BLOCK;
292        *JM_AVAL_LABEL=GROUPLABEL;
293        
294        
295        if avisitn=0 then jm_aval_namec=strip(PARAM)||'^n^{nbspace 2}'||strip(JM_AVAL_LABEL);
296        else jm_aval_namec=strip(JM_AVAL_LABEL);
297        
298        jm_aval_namen=0;
299        
300        drop trtn:;
301        run;

NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.DUMMY has 73 observations and 25 variables.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

302        
303        
304        
305        
306        data jm_aval_allreport1;
307        length  JM_BLOCK $200.;
308         set dummy jm_aval_allreport1;
309         by paramn avisitn JM_BLOCK;
310        run;

NOTE: There were 73 observations read from the data set WORK.DUMMY.
NOTE: There were 278 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 29 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

311        
312        proc sort data=jm_aval_allreport1;
313        by paramn JM_BLOCK avisitn  avisit  JM_AVAL_LABEL JM_AVAL_NAMEN JM_AVAL_NAMEC;
314        run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 29 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

315        
316        
317        data jm_aval_allreport1;
318        set jm_aval_allreport1;
319        by paramn JM_BLOCK avisitn  avisit  JM_AVAL_LABEL JM_AVAL_NAMEN JM_AVAL_NAMEC;
320        
                                                           The SAS System

321        if paramn in (106,201) and jm_aval_namen ne 0  then  jm_aval_namec=strip(scan(strip(jm_aval_namec),2,':'));
322        else jm_aval_namec=jm_aval_namec;
323        
324        if last.avisitn then jm_aval_namec=strip(jm_aval_namec)||"^n";
325        
326        if jm_aval_namec ne "" and jm_aval_namen ne 0 then jm_aval_namec='^{nbspace 5}'||strip(jm_aval_namec);
327        if paramn in (106) and last.avisitn and avisitn=12 then jm_aval_namec=tranwrd(jm_aval_namec,"^n","");
328        run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 29 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

329        
330        
331        
332        
333        data jm_aval_allreport1;
334        set jm_aval_allreport1;
335        by paramn avisitn avisit JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEN JM_AVAL_NAMEC;
336        
337         orig_rec_num=_n_;
338        
339           if jm_block in ("101","102","103") then pageno=1;
340           if jm_block in ("104","105","106","107") then pageno=2;
341           *if jm_block in ("106","107") then pageno=3;
342           if jm_block in ("108","109") then pageno=4;
343           if jm_block in ("110","111") then pageno=5;
344           if jm_block in ("112","113") then pageno=6;
345        
346           if paramn=106 then pageno=100+pageno;
347           if paramn=201 then pageno=200+pageno;
348           if paramn=301 then pageno=300+pageno;
349           if paramn=302 then pageno=400+pageno;
350           if paramn=303 then pageno=500+pageno;
351           if paramn=304 then pageno=600+pageno;
352           if paramn=305 then pageno=700+pageno;
353           if paramn=306 then pageno=800+pageno;
                                                           The SAS System

354           if paramn=401 then pageno=900+pageno;
355        
356        
357        
358        run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 30 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

359        
360        
361        proc sort data=jm_aval_allreport1;
362        by pageno paramn avisitn JM_BLOCK jm_aval_label jm_aval_namen;
363        run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 30 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

364        
365        data jm_aval_allreport1;
366        set jm_aval_allreport1;
367        by pageno paramn avisitn JM_BLOCK jm_aval_label jm_aval_namen;
368            array myarr{*} $ trtn:;
369                   do i=1 to dim(myarr);
370                  if paramn  in (106,201) and jm_aval_namen ne 0 and   myarr(i)=''  then myarr(i)='0(0)' ;
371                   end;
372        
373             groupvarn=orig_rec_num;
374             jm_aval_namen=orig_rec_num;
375        
376        run;

                                                           The SAS System

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 30 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

377        
378         proc freq data=jm_aval_allreport1 noprint;
379            table PARAMN*param/out=freq nocol nopct;
380         run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.FREQ has 9 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

381        
382        
383        
384        
385        %LET _default_box=Timepoint;
386        
387        *------------------------------------------------------------------------------------------------------------------------
387      ! ----------;
388        *ODS OPEN- OPENS RTF DESTINATION;
389        *------------------------------------------------------------------------------------------------------------------------
389      ! ----------;
390        %JM_ODSOPEN (JM_OUTREPORT=, JM_BODYTITLEOPT=0, JM_STYLE=OXYSTYLE);
MLOGIC:  Beginning compilation of JM_ODSOPEN using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_odsopen.sas.
MLOGIC:  Ending compilation of JM_ODSOPEN.
MLOGIC(JM_ODSOPEN):  Beginning execution.
MLOGIC(JM_ODSOPEN):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_odsopen.sas
MLOGIC(JM_ODSOPEN):  Parameter JM_OUTREPORT has value 
MLOGIC(JM_ODSOPEN):  Parameter JM_BODYTITLEOPT has value 0
MLOGIC(JM_ODSOPEN):  Parameter JM_STYLE has value OXYSTYLE
MLOGIC(JM_ODSOPEN):  Parameter JM_POINTSIZE has value 
MLOGIC(JM_ODSOPEN):  Parameter JM_ODSTYPE has value rtf
MPRINT(JM_ODSOPEN):   *** Document in log what parameter value specified ***;
                                                           The SAS System

MPRINT(JM_ODSOPEN):   data _null_;
MPRINT(JM_ODSOPEN):   put ' ';
MPRINT(JM_ODSOPEN):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_OUTREPORT resolves to 
MPRINT(JM_ODSOPEN):   PUT "ALERT:I: JM_OUTREPORT PROCESSED - ";
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 
MPRINT(JM_ODSOPEN):   PUT "ALERT:I: JM_POINTSIZE PROCESSED - ";
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSOPEN):   PUT "ALERT:I: JM_ODSTYPE PROCESSED - rtf";
SYMBOLGEN:  Macro variable JM_STYLE resolves to OXYSTYLE
MPRINT(JM_ODSOPEN):   PUT "ALERT:I: JM_STYLE PROCESSED - OXYSTYLE";
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
MPRINT(JM_ODSOPEN):   PUT "ALERT:I: JM_BODYTITLEOPT PROCESSED - 0";
MPRINT(JM_ODSOPEN):   put "********************************************************";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   put 'NOTE: [JM_ODSOPEN] is currently running macro %jm_odsopen version 1.0.';
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   run;


******************* Parameter Values *******************
ALERT:I: JM_OUTREPORT PROCESSED - 
ALERT:I: JM_POINTSIZE PROCESSED - 
ALERT:I: JM_ODSTYPE PROCESSED - rtf
ALERT:I: JM_STYLE PROCESSED - OXYSTYLE
ALERT:I: JM_BODYTITLEOPT PROCESSED - 0
********************************************************

NOTE: [JM_ODSOPEN] is currently running macro %jm_odsopen version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_ODSOPEN):   *** Default if OUTPUTNM is not defined ***;
MLOGIC(JM_ODSOPEN):  %IF condition %symexist(outputnm)=0 is FALSE
MPRINT(JM_ODSOPEN):   *** Initialize er ror checking condition ***;
MLOGIC(JM_ODSOPEN):  %LET (variable name is _ERR)
MPRINT(JM_ODSOPEN):   data _null_;
MPRINT(JM_ODSOPEN):   *** Apply default if not specified ***;
SYMBOLGEN:  Macro variable JM_OUTREPORT resolves to 
                                                           The SAS System

MPRINT(JM_ODSOPEN):   if "" = "" then do;
MLOGIC(JM_ODSOPEN):  %IF condition %symexist(rsltpath)=0 and %symexist(outputnm)=0 is FALSE
SYMBOLGEN:  Macro variable RSLTPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results
SYMBOLGEN:  Macro variable OUTPUTNM resolves to t-9-03-03-01-01
MPRINT(JM_ODSOPEN):   outreport = strip("C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf");
SYMBOLGEN:  Macro variable RSLTPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results
SYMBOLGEN:  Macro variable OUTPUTNM resolves to t-9-03-03-01-01
MPRINT(JM_ODSOPEN):   call symputx('JM_OUTREPORT',"C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf");
SYMBOLGEN:  Macro variable RSLTPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results
SYMBOLGEN:  Macro variable OUTPUTNM resolves to t-9-03-03-01-01
MPRINT(JM_ODSOPEN):   put "NOTE: [JM_ODSOPEN] is missing required parameter JM_OUTREPORT. " "However, the output report path and 
file name is default to: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf.";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   *** Verify if result path exists ***;
SYMBOLGEN:  Macro variable RSLTPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results
MPRINT(JM_ODSOPEN):   if fileexist("C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results") = 0 then do;
MPRINT(JM_ODSOPEN):   put " ";
SYMBOLGEN:  Macro variable RSLTPATH resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results
MPRINT(JM_ODSOPEN):   put "ER" "ROR: [JM_ODSOPEN] contains in invalid path (C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results) 
value used for parameter JM_OUTREPORT. " 'This specifies the output report path and file name (i.e. &rsltpath.\&outputnm..rtf).';
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   call symput('_err','yes');
MPRINT(JM_ODSOPEN):   end;
MPRINT(JM_ODSOPEN):   end;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 
MPRINT(JM_ODSOPEN):   if "" = "" then do;
MPRINT(JM_ODSOPEN):   *** Apply the default fontsize if that is specified ***;
MLOGIC(JM_ODSOPEN):  %IF condition %symexist(default_fontsize)=0 is FALSE
SYMBOLGEN:  Macro variable DEFAULT_FONTSIZE resolves to 9
MPRINT(JM_ODSOPEN):   if "9" ne "" then do;
SYMBOLGEN:  Macro variable DEFAULT_FONTSIZE resolves to 9
MPRINT(JM_ODSOPEN):   call symputx('JM_POINTSIZE',"9");
SYMBOLGEN:  Macro variable DEFAULT_FONTSIZE resolves to 9
MPRINT(JM_ODSOPEN):   put "NOTE: [JM_ODSOPEN] is missing required parameter JM_POINTSIZE. " "However, the default was set to: 9.";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   end;
MPRINT(JM_ODSOPEN):   else do;
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   put "ER" "ROR: [JM_ODSOPEN] is missing required parameter JM_POINTSIZE. " "This specifies the point size for 
font in report (i.e. 8).";
MPRINT(JM_ODSOPEN):   put " ";
                                                           The SAS System

MPRINT(JM_ODSOPEN):   call symput('_err','yes');
MPRINT(JM_ODSOPEN):   end;
MPRINT(JM_ODSOPEN):   end;
MPRINT(JM_ODSOPEN):   else do;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 
MPRINT(JM_ODSOPEN):   jm_pointsize=input("",best.);
MPRINT(JM_ODSOPEN):   if jm_pointsize < 1 or jm_pointsize > 7200 then do;
MPRINT(JM_ODSOPEN):   put " ";
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 
MPRINT(JM_ODSOPEN):   put "ER" "ROR: [JM_ODSOPEN] contains an invalid value '' for parameter JM_POINTSIZE. " "This specifies the 
point size for font in report (i.e. 8).";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   call symput('_err','yes');
MPRINT(JM_ODSOPEN):   end;
MPRINT(JM_ODSOPEN):   end;
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSOPEN):   if "rtf" = "" then do;
MPRINT(JM_ODSOPEN):   call symputx('JM_ODSTYPE',"rtf");
MPRINT(JM_ODSOPEN):   put "NOTE: [JM_ODSOPEN] is missing parameter JM_ODSTYPE. " "However, the default was set to: RTF.";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   end;
SYMBOLGEN:  Macro variable JM_STYLE resolves to OXYSTYLE
MPRINT(JM_ODSOPEN):   if "OXYSTYLE" = "" then do;
MPRINT(JM_ODSOPEN):   call symputx('JM_STYLE',"OXYStyle");
MPRINT(JM_ODSOPEN):   put "NOTE: [JM_ODSOPEN] is missing parameter JM_STYLE. " "However, the default was set to: OXYStyle.";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   end;
MPRINT(JM_ODSOPEN):   run;

NOTE: [JM_ODSOPEN] is missing required parameter JM_OUTREPORT. 
However, the output report path and file name is default to: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf
.

NOTE: [JM_ODSOPEN] is missing required parameter JM_POINTSIZE. However, the default was set to: 9.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_ODSOPEN):  %IF condition "&_err" = "yes" is FALSE
                                                           The SAS System

MPRINT(JM_ODSOPEN):   *** Verify invalid values ***;
MPRINT(JM_ODSOPEN):   data _null_;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MPRINT(JM_ODSOPEN):   pointsize = strip("9");
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'0','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'1','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'2','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'3','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'4','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'5','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'6','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'7','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'8','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'9','');
MPRINT(JM_ODSOPEN):   pointsize = tranwrd(pointsize,'.','');
MPRINT(JM_ODSOPEN):   if pointsize ne '' then do;
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   put "ER" "ROR: [JM_ODSOPEN] contain invalid characters (" pointsize +(-1) ") for JM_POINTSIZE parameter. " 
"This specifies the point size for font in report (i.e. 8).";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   call symput('_err','yes');
MPRINT(JM_ODSOPEN):   end;
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSOPEN):   odstype=upcase(strip("rtf"));
MPRINT(JM_ODSOPEN):   if odstype ne '' and odstype not in("RTF","PDF") then do;
MPRINT(JM_ODSOPEN):   put " ";
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSOPEN):   put "ER" "ROR: [JM_ODSOPEN] contain invalid value 'rtf' for JM_ODSTYPE parameter. " "This specifies the ODS 
Report output file type (i.e. RTF).";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   call symput('_err','yes');
MPRINT(JM_ODSOPEN):   end;
SYMBOLGEN:  Macro variable JM_STYLE resolves to OXYSTYLE
MPRINT(JM_ODSOPEN):   STYLE=upcase(strip("OXYSTYLE"));
MPRINT(JM_ODSOPEN):   if STYLE ne '' and STYLE not in("OXYSTYLE","JZPSTYLE") then do;
MPRINT(JM_ODSOPEN):   put " ";
SYMBOLGEN:  Macro variable JM_STYLE resolves to OXYSTYLE
MPRINT(JM_ODSOPEN):   put "ER" "ROR: [JM_ODSOPEN] contain invalid value 'OXYSTYLE' for JM_STYLE parameter. " 'This specifies the 
ODS template style as defined in %JM_TEMPLATE (i.e. OXYSTYLE, JZPSTYLE).';
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_ODSOPEN):   end;
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
MPRINT(JM_ODSOPEN):   titleopt = upcase(strip("0"));
MPRINT(JM_ODSOPEN):   if titleopt not in("1","YES","Y","0") then do;
MPRINT(JM_ODSOPEN):   put " ";
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
MPRINT(JM_ODSOPEN):   put "ER" "ROR: [JM_ODSOPEN] contain invalid value '0' for JM_BODYTITLEOPT parameter. " "This specifies the 
report body title option (i.e. 1).";
MPRINT(JM_ODSOPEN):   put " ";
MPRINT(JM_ODSOPEN):   call symput('_err','yes');
MPRINT(JM_ODSOPEN):   end;
MPRINT(JM_ODSOPEN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_ODSOPEN):  %IF condition "&_err" = "yes" is FALSE
MLOGIC(JM_ODSOPEN):  Beginning compilation of JM_TEMPLATES using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_templates.sas.
MLOGIC(JM_ODSOPEN):  Ending compilation of JM_TEMPLATES.
MLOGIC(JM_TEMPLATES):  Beginning execution.
MLOGIC(JM_TEMPLATES):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_templates.sas
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MLOGIC(JM_TEMPLATES):  Parameter JM_POINTSIZE has value 9
MPRINT(JM_TEMPLATES):   *** Document in log what parameter value specified ***;
MPRINT(JM_TEMPLATES):   data _null_;
MPRINT(JM_TEMPLATES):   put ' ';
MPRINT(JM_TEMPLATES):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   PUT "ALERT:I: JM_POINTSIZE PROCESSED - 9";
MPRINT(JM_TEMPLATES):   put "********************************************************";
MPRINT(JM_TEMPLATES):   put " ";
MPRINT(JM_TEMPLATES):   put 'NOTE: [JM_TEMPLATES] is currently running macro %jm_templates version 1.0.';
MPRINT(JM_TEMPLATES):   put " ";
MPRINT(JM_TEMPLATES):   run;


******************* Parameter Values *******************
                                                           The SAS System

ALERT:I: JM_POINTSIZE PROCESSED - 9
********************************************************

NOTE: [JM_TEMPLATES] is currently running macro %jm_templates version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TEMPLATES):   *** Initialize er ror checking condition ***;
MLOGIC(JM_TEMPLATES):  %LET (variable name is _ERR)
MPRINT(JM_TEMPLATES):   data _null_;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   if "9" = "" then do;
MPRINT(JM_TEMPLATES):   *** Apply the default fontsize if that is specified ***;
MLOGIC(JM_TEMPLATES):  %IF condition %symexist(default_fontsize)=0 is FALSE
SYMBOLGEN:  Macro variable DEFAULT_FONTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   call symputx('JM_POINTSIZE',"9");
SYMBOLGEN:  Macro variable DEFAULT_FONTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   put "NOTE: [JM_TEMPLATES] is missing required parameter JM_POINTSIZE. " "However, the default was set to: 
9.";
MPRINT(JM_TEMPLATES):   put " ";
MPRINT(JM_TEMPLATES):   end;
MPRINT(JM_TEMPLATES):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_TEMPLATES):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TEMPLATES):   *** Verify if the pointsize is a valid numeric value ***;
MPRINT(JM_TEMPLATES):   data _null_;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   pointsize = strip("9");
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'0','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'1','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'2','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'3','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'4','');
                                                           The SAS System

MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'5','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'6','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'7','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'8','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'9','');
MPRINT(JM_TEMPLATES):   pointsize = tranwrd(pointsize,'.','');
MPRINT(JM_TEMPLATES):   if pointsize ne '' then do;
MPRINT(JM_TEMPLATES):   put " ";
MPRINT(JM_TEMPLATES):   put "ER" "ROR: [JM_TEMPLATES] contain invalid characters (" pointsize +(-1) ") for JM_POINTSIZE parameter. 
" "This specifies the point size for font in report (i.e. 8).";
MPRINT(JM_TEMPLATES):   put " ";
MPRINT(JM_TEMPLATES):   call symput('_err','yes');
MPRINT(JM_TEMPLATES):   end;
MPRINT(JM_TEMPLATES):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_TEMPLATES):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_TEMPLATES):   ods path(prepend) work.templat(update);
MPRINT(JM_TEMPLATES):   *** Define the ODS style for Jazz Reports with Time Roman fonts ***;
MPRINT(JM_TEMPLATES):   proc template;
MPRINT(JM_TEMPLATES):   define style JZPStyle;
MPRINT(JM_TEMPLATES):   parent=styles.rtf;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   replace fonts / 'titlefont2'=("Times New Roman, Times New Roman",9pt,bold) 'titlefont'=("Times New Roman, 
Times New Roman",9pt,bold) 'Strongfont'=("Times New Roman, Times New Roman",9pt) 'EmphasisFont'=("Times New Roman, Times New 
Roman",9pt) 'FixedEmphasisFont'=("Times New Roman, Times New Roman",2) 'FixedStrongFont'=("Times New Roman, Times New Roman",2) 
'FixedHeadingFont'=("Times New Roman, Times New Roman",2) 'BatchFixedFont'=("SAS Monospace,Times New Roman, Times New Roman",2) 
'FixedFont'=("Times New Roman, Times New Roman",2) 'headingEmphasisFont'=("Times New Roman, Times New Roman",9pt,bold) 
'headingFont'=("Times New Roman, Times New Roman",9pt,bold) 'docFont'=("Times New Roman, Times New Roman",9pt) 'footFont'=("Times 
New Roman, Times New Roman",8pt);
                                                           The SAS System

MPRINT(JM_TEMPLATES):   style pageno from pageno / font=fonts("strongfont") pretext="Page " posttext=" of ^{lastpage} ";
MPRINT(JM_TEMPLATES):   style header from table /rules=groups frame=above frameborder=on frameborderwidth=0.5 font_weight=light 
cellspacing=.25 cellpadding=1.0 borderwidth=1.5pt;
MPRINT(JM_TEMPLATES):   style table from table /rules=groups frame=above cellspacing=0.25 cellpadding=1.0;
MPRINT(JM_TEMPLATES):   style systemtitle from systemtitle / asis=on;
MPRINT(JM_TEMPLATES):   style systemfooter from systemfooter / asis=on;
MPRINT(JM_TEMPLATES):   replace headersAndFooters from cell/ font=fonts('TitleFont') foreground=black background=white;
MPRINT(JM_TEMPLATES):   replace SystemFooter from TitlesAndFooters / font = Fonts('footFont');
MPRINT(JM_TEMPLATES):   replace SystemTitles from TitlesAndFooters / font = Fonts('TitleFont');
MPRINT(JM_TEMPLATES):   replace Body from Document "Controls the Body file. " / bottommargin = 1.01in topmargin = 1.18in 
rightmargin = 0.79in leftmargin = 0.81in;
MPRINT(JM_TEMPLATES):   end;
NOTE: STYLE 'JZPStyle' has been saved to: WORK.TEMPLAT
NOTE: PROCEDURE TEMPLATE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TEMPLATES):   run;
MPRINT(JM_TEMPLATES):   *** Define the ODS style for Tables or Listing Reports with Courier fonts ***;
MPRINT(JM_TEMPLATES):   proc template;
MPRINT(JM_TEMPLATES):   define style OXYSTYLE;
MPRINT(JM_TEMPLATES):   parent=styles.rtf;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   replace fonts / 'titlefont2'=("Courier New, Courier New",9pt,bold) 'titlefont'=("Courier New, Courier 
New",9pt,bold) 'Strongfont'=("Courier New, Courier New",9pt) 'EmphasisFont'=("Courier New, Courier New",9pt) 
'FixedEmphasisFont'=("Courier New, Courier New",2) 'FixedStrongFont'=("Courier New, Courier New",2) 'FixedHeadingFont'=("Courier 
New, Courier New",2) 'BatchFixedFont'=("SAS Monospace,Courier New, Courier New",2) 'FixedFont'=("Courier New, Courier New",2) 
'headingEmphasisFont'=("Courier New, Courier New",9pt,bold) 'headingFont'=("Courier New, Courier New",9pt,bold) 'docFont'=("Courier 
New, Courier New",9pt) 'footFont'=("Courier New, Courier New",8pt);
MPRINT(JM_TEMPLATES):   style pageno from pageno / font=fonts("strongfont") pretext="Page " posttext=" of ^{lastpage} ";
MPRINT(JM_TEMPLATES):   style header from table /rules=groups frame=above frameborder=on frameborderwidth=0.5 font_weight=light 
cellspacing=.25 cellpadding=1.0 borderwidth=1.5pt;
MPRINT(JM_TEMPLATES):   style table from table /rules=groups frame=above cellspacing=0.25 cellpadding=1.0;
MPRINT(JM_TEMPLATES):   style systemtitle from systemtitle / asis=on;
                                                           The SAS System

MPRINT(JM_TEMPLATES):   style systemfooter from systemfooter / asis=on;
MPRINT(JM_TEMPLATES):   replace headersAndFooters from cell/ font=fonts('TitleFont') foreground=black background=white;
MPRINT(JM_TEMPLATES):   replace SystemFooter from TitlesAndFooters / font = Fonts('footFont');
MPRINT(JM_TEMPLATES):   replace SystemTitles from TitlesAndFooters / font = Fonts('TitleFont');
MPRINT(JM_TEMPLATES):   replace Body from Document "Controls the Body file. " / bottommargin = 1.01in topmargin = 1.18in 
rightmargin = 0.79in leftmargin = 0.81in;
MPRINT(JM_TEMPLATES):   end;
NOTE: STYLE 'Oxystyle' has been saved to: WORK.TEMPLAT
NOTE: PROCEDURE TEMPLATE used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_TEMPLATES):   run;
MPRINT(JM_TEMPLATES):   *** Define the ODS style for Intext Tables with Time Roman fonts ***;
MPRINT(JM_TEMPLATES):   proc template;
MPRINT(JM_TEMPLATES):   define style InTXTStyle;
MPRINT(JM_TEMPLATES):   parent=styles.rtf;
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
SYMBOLGEN:  Macro variable JM_POINTSIZE resolves to 9
MPRINT(JM_TEMPLATES):   replace fonts / 'titlefont2'=("Times New Roman, Times New Roman",9pt,bold) 'titlefont'=("Times New Roman, 
Times New Roman",9pt,bold) 'Strongfont'=("Times New Roman, Times New Roman",9pt) 'EmphasisFont'=("Times New Roman, Times New 
Roman",9pt) 'FixedEmphasisFont'=("Times New Roman, Times New Roman",2) 'FixedStrongFont'=("Times New Roman, Times New Roman",2) 
'FixedHeadingFont'=("Times New Roman, Times New Roman",2) 'BatchFixedFont'=("SAS Monospace,Times New Roman, Times New Roman",2) 
'FixedFont'=("Times New Roman, Times New Roman",2) 'headingEmphasisFont'=("Times New Roman, Times New Roman",9pt,bold) 
'headingFont'=("Times New Roman, Times New Roman",9pt,bold) 'docFont'=("Times New Roman, Times New Roman",9pt) 'footFont'=("Times 
New Roman, Times New Roman",8pt);
MPRINT(JM_TEMPLATES):   style pageno from pageno / font=fonts("strongfont") pretext="Page " posttext=" of ^{lastpage} ";
MPRINT(JM_TEMPLATES):   style header from table /rules=groups frame=above frameborder=on frameborderwidth=0.5 font_weight=light 
cellspacing=.25 cellpadding=1.0 borderwidth=1.5pt;
MPRINT(JM_TEMPLATES):   style table from table /rules=groups frame=above cellspacing=0.25 cellpadding=1.0;
MPRINT(JM_TEMPLATES):   style systemtitle from systemtitle / asis=on;
MPRINT(JM_TEMPLATES):   style systemfooter from systemfooter / asis=on;
MPRINT(JM_TEMPLATES):   replace headersAndFooters from cell/ font=fonts('TitleFont') foreground=black background=white;
MPRINT(JM_TEMPLATES):   replace SystemFooter from TitlesAndFooters / font = Fonts('footFont');
MPRINT(JM_TEMPLATES):   replace SystemTitles from TitlesAndFooters / font = Fonts('TitleFont');
                                                           The SAS System

MPRINT(JM_TEMPLATES):   replace Body from Document "Controls the Body file. " / bottommargin = 1.01in topmargin = 1.18in 
rightmargin = 1.00in leftmargin = 1.00in;
MPRINT(JM_TEMPLATES):   end;
NOTE: STYLE 'InTXTStyle' has been saved to: WORK.TEMPLAT
NOTE: PROCEDURE TEMPLATE used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_TEMPLATES):   run;
MPRINT(JM_TEMPLATES):   *** Mark the end of parameter checking ***;
MLOGIC(JM_TEMPLATES):  Ending execution.
MPRINT(JM_ODSOPEN):  ;
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
MLOGIC(JM_ODSOPEN):  %IF condition "&jm_bodytitleopt" = "1" or "&jm_bodytitleopt" = "Y" or "&jm_bodytitleopt" = "YES" is FALSE
MPRINT(JM_ODSOPEN):   options orientation=landscape nodate nonumber;
MPRINT(JM_ODSOPEN):   ods escapechar="^";
MPRINT(JM_ODSOPEN):   ods listing close;
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
SYMBOLGEN:  Macro variable JM_OUTREPORT resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf
SYMBOLGEN:  Macro variable JM_STYLE resolves to OXYSTYLE
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
SYMBOLGEN:  Macro variable JM_BODYTITLEOPT resolves to 0
MLOGIC(JM_ODSOPEN):  %IF condition "&jm_bodytitleopt" = "1" or "&jm_bodytitleopt" = "Y" or "&jm_bodytitleopt" = "YES" is FALSE
MPRINT(JM_ODSOPEN):   ods rtf file="C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf" style=OXYSTYLE ;
NOTE: Writing RTF Body file: C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf
MPRINT(JM_ODSOPEN):   *** Create the filename to be used later to remove page break in JM_ODSCLOSE ***;
SYMBOLGEN:  Macro variable JM_OUTREPORT resolves to C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf
MPRINT(JM_ODSOPEN):   filename _fixrtf "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf";
MPRINT(JM_ODSOPEN):   *** Mark the end of parameter checking ***;
MLOGIC(JM_ODSOPEN):  Ending execution.
391        
392        *------------------------------------------------------------------------------------------------------------------------
392      ! ----------;
393        *REPORT- PROC REPORT MODULE;
394        *------------------------------------------------------------------------------------------------------------------------
394      ! ----------;
395        
                                                           The SAS System

396        %JM_AVAL_REPORT (JM_INDSN=Jm_aval_allreport1, JM_BIGNDSN=Jm_bign1, jm_spanheadopt=Y , JM_INDENTOPT=N, jm_breakopt=N,
396      ! jm_breakvar=jm_aval_label);
MLOGIC:  Beginning compilation of JM_AVAL_REPORT using the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_report.sas.
MLOGIC:  Ending compilation of JM_AVAL_REPORT.
MLOGIC(JM_AVAL_REPORT):  Beginning execution.
MLOGIC(JM_AVAL_REPORT):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_aval_report.sas
MLOGIC(JM_AVAL_REPORT):  Parameter JM_INDSN has value Jm_aval_allreport1
MLOGIC(JM_AVAL_REPORT):  Parameter JM_BIGNDSN has value Jm_bign1
MLOGIC(JM_AVAL_REPORT):  Parameter JM_SPANHEADOPT has value Y
MLOGIC(JM_AVAL_REPORT):  Parameter JM_INDENTOPT has value N
MLOGIC(JM_AVAL_REPORT):  Parameter JM_BREAKOPT has value N
MLOGIC(JM_AVAL_REPORT):  Parameter JM_BREAKVAR has value jm_aval_label
MLOGIC(JM_AVAL_REPORT):  Parameter JM_COL2VAR has value 
MLOGIC(JM_AVAL_REPORT):  Parameter JM_GROUPLABEL has value 
MLOGIC(JM_AVAL_REPORT):  Parameter JM_CELLWIDTH has value 
MLOGIC(JM_AVAL_REPORT):  Parameter JM_TRTWIDTH has value 
MLOGIC(JM_AVAL_REPORT):  Parameter JM_BYVAR has value 
MLOGIC(JM_AVAL_REPORT):  Parameter JM_REPTYPE has value Table
MLOGIC(JM_AVAL_REPORT):  Parameter JM_SPANHEADBIGNOPT has value 
MPRINT(JM_AVAL_REPORT):   *** Document in log what parameter value specified ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   put ' ';
MPRINT(JM_AVAL_REPORT):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_INDSN PROCESSED - Jm_aval_allreport1";
SYMBOLGEN:  Macro variable JM_BIGNDSN resolves to Jm_bign1
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_BIGNDSN PROCESSED - Jm_bign1";
SYMBOLGEN:  Macro variable JM_COL2VAR resolves to 
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_COL2VAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_BREAKVAR resolves to jm_aval_label
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_BREAKVAR PROCESSED - jm_aval_label";
SYMBOLGEN:  Macro variable JM_BREAKOPT resolves to N
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_BREAKOPT PROCESSED - N";
SYMBOLGEN:  Macro variable JM_INDENTOPT resolves to N
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_INDENTOPT PROCESSED - N";
SYMBOLGEN:  Macro variable JM_GROUPLABEL resolves to 
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_GROUPLABEL PROCESSED - ";
SYMBOLGEN:  Macro variable JM_CELLWIDTH resolves to 
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_CELLWIDTH PROCESSED - ";
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_TRTWIDTH PROCESSED - ";
SYMBOLGEN:  Macro variable JM_SPANHEADOPT resolves to Y
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_SPANHEADOPT PROCESSED - Y";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_BYVAR PROCESSED - ";
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_REPTYPE PROCESSED - Table";
SYMBOLGEN:  Macro variable JM_SPANHEADBIGNOPT resolves to 
MPRINT(JM_AVAL_REPORT):   PUT "ALERT:I: JM_SPANHEADBIGNOPT PROCESSED - ";
MPRINT(JM_AVAL_REPORT):   put "********************************************************";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put 'NOTE: [JM_AVAL_REPORT] is currently running macro %jm_aval_report version 1.1.';
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   run;


******************* Parameter Values *******************
ALERT:I: JM_INDSN PROCESSED - Jm_aval_allreport1
ALERT:I: JM_BIGNDSN PROCESSED - Jm_bign1
ALERT:I: JM_COL2VAR PROCESSED - 
ALERT:I: JM_BREAKVAR PROCESSED - jm_aval_label
ALERT:I: JM_BREAKOPT PROCESSED - N
ALERT:I: JM_INDENTOPT PROCESSED - N
ALERT:I: JM_GROUPLABEL PROCESSED - 
ALERT:I: JM_CELLWIDTH PROCESSED - 
ALERT:I: JM_TRTWIDTH PROCESSED - 
ALERT:I: JM_SPANHEADOPT PROCESSED - Y
ALERT:I: JM_BYVAR PROCESSED - 
ALERT:I: JM_REPTYPE PROCESSED - Table
ALERT:I: JM_SPANHEADBIGNOPT PROCESSED - 
********************************************************

NOTE: [JM_AVAL_REPORT] is currently running macro %jm_aval_report version 1.1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Hold onto original dataset ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   data Jm_aval_allreport1_ori;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1_ORI has 351 observations and 30 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Define standard defaults if not defined ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   if 1 = 0 then call symputx('_default_box'," ");
MPRINT(JM_AVAL_REPORT):   if 1 = 0 then call symputx('_default_twips',"560");
MPRINT(JM_AVAL_REPORT):   if 1 = 0 then do;
MPRINT(JM_AVAL_REPORT):   *** Default to a blank spanning header ***;
MPRINT(JM_AVAL_REPORT):   *** span_head = ' ("^R' || "'\brdrb\brdrs\brdrw4 'Randomized Withdrawal Period" || '" trt0 trt1 trt2 
trt99) ';
MPRINT(JM_AVAL_REPORT):   span_head = ' ';
MPRINT(JM_AVAL_REPORT):   call symput('_DEFAULT_SPAN_HEAD',span_head);
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Initialize er ror checking condition ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is _ERR)
MPRINT(JM_AVAL_REPORT):   *** Verify if report type is valid ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   length jm_reptype $200;
MPRINT(JM_AVAL_REPORT):   jm_reptype=lowcase(strip(symget('jm_reptype')));
MPRINT(JM_AVAL_REPORT):   if jm_reptype not in('table','listing') then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] contains an invalid value 'Table' for JM_REPTYPE parameter. " "Valid 
values include Table or Listing.";
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   if "Jm_aval_allreport1" = "" then do;
MPRINT(JM_AVAL_REPORT):   if exist('ALLREPORT') then do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "NOTE: [JM_AVAL_REPORT] is missing required parameter JM_INDSN. " "However, the ALLREPORT dataset 
exist so it will be used for JM_INDSN." "This specifies the input SAS dataset name (i.e. JM_AVAL_SUM1, JM_AVAL_COUNT1).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symputx('JM_INDSN', 'ALLREPORT');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   else do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] is missing required parameter JM_INDSN. " "This is the input SAS dataset 
name (i.e. JM_AVAL_SUM1, JM_AVAL_COUNT1).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
SYMBOLGEN:  Macro variable JM_BIGNDSN resolves to Jm_bign1
MPRINT(JM_AVAL_REPORT):   if "Jm_bign1" = "" then do;
MPRINT(JM_AVAL_REPORT):   *** Apply defaults if it exists ***;
MPRINT(JM_AVAL_REPORT):   if exist('BIGN') or exist('JM_AVAL_BIGN') or exist('JM_AVAL_BIGN1') then do;
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   length BIGN $20;
MPRINT(JM_AVAL_REPORT):   if exist('BIGN') then BIGN = 'BIGN';
MPRINT(JM_AVAL_REPORT):   if exist('JM_AVAL_BIGN') then BIGN = 'JM_AVAL_BIGN';
MPRINT(JM_AVAL_REPORT):   if exist('JM_AVAL_BIGN1') then BIGN = 'JM_AVAL_BIGN1';
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "NOTE: [JM_AVAL_REPORT] is missing required parameter JM_BIGNDSN. " "However, the " BIGN "dataset 
exist so it will be used for JM_BIGNDSN." "This is the input SAS dataset containing Big N denominator (i.e. JM_AVAL_BIGN1).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symputx('JM_BIGN', BIGN);
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   else do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] is missing required parameter JM_BIGNDSN. " "This is the input SAS 
dataset containing Big N denominator (i.e. JM_AVAL_BIGN1).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Verify invalid parameter JM_COL2VAR ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   length curvar $100;
MPRINT(JM_AVAL_REPORT):   JM_INDSN = strip(symget('JM_INDSN'));
MPRINT(JM_AVAL_REPORT):   parens = index(JM_INDSN,'(') ;
MPRINT(JM_AVAL_REPORT):   if parens > 0 then JM_INDSN = substr(JM_INDSN,1,parens-1);
MPRINT(JM_AVAL_REPORT):   dsid=open(JM_INDSN, "i");
MPRINT(JM_AVAL_REPORT):   *** Handle multiple JM_COL2VAR variables ***;
SYMBOLGEN:  Macro variable JM_COL2VAR resolves to 
MPRINT(JM_AVAL_REPORT):   JM_COL2VAR = strip("");
MPRINT(JM_AVAL_REPORT):   count=countw(JM_COL2VAR,' ');
MPRINT(JM_AVAL_REPORT):   do i = 1 to count;
MPRINT(JM_AVAL_REPORT):   curvar=scan(JM_COL2VAR,i,' ');
MPRINT(JM_AVAL_REPORT):   varpos=varnum(dsid, curvar);
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   if varpos = 0 then do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [jm_aval_report] contains an invalid variable '" curvar +(-1) "' for parameter JM_COL2VAR. 
" "This specifies the column variable for the report.";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   *** Handle multiple JM_BREAKVAR variables ***;
SYMBOLGEN:  Macro variable JM_BREAKVAR resolves to jm_aval_label
MPRINT(JM_AVAL_REPORT):   JM_BREAKVAR = strip("jm_aval_label");
MPRINT(JM_AVAL_REPORT):   count=countw(JM_BREAKVAR,' ');
MPRINT(JM_AVAL_REPORT):   do i = 1 to count;
MPRINT(JM_AVAL_REPORT):   curvar=scan(JM_BREAKVAR,i,' ');
MPRINT(JM_AVAL_REPORT):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_REPORT):   if varpos = 0 then do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [jm_aval_report] contains an invalid variable '" curvar +(-1) "' for parameter 
JM_BREAKVAR. " "This specifies the variable for breaking page (i.e. JM_AVAL_LABEL).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   *** Handle multiple JM_BYVAR variables ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
MPRINT(JM_AVAL_REPORT):   JM_BYVAR = strip("");
MPRINT(JM_AVAL_REPORT):   count=countw(JM_BYVAR,' ');
MPRINT(JM_AVAL_REPORT):   do i = 1 to count;
MPRINT(JM_AVAL_REPORT):   curvar=scan(JM_BYVAR,i,' ');
MPRINT(JM_AVAL_REPORT):   varpos=varnum(dsid, curvar);
MPRINT(JM_AVAL_REPORT):   if varpos = 0 then do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [jm_aval_report] contains an invalid variable '" curvar +(-1) "' for parameter JM_BYVAR. " 
"This specifies the sort by variable used in summary.";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   rc=close(dsid);
MPRINT(JM_AVAL_REPORT):   run;

                                                           The SAS System

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      396:100  JM_INDSN
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Verify missing varaibles with defaults ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_GROUPLABEL resolves to 
MPRINT(JM_AVAL_REPORT):   if "" = "" then do;
MPRINT(JM_AVAL_REPORT):   *** Apply default macro variable if it exists ***;
MLOGIC(JM_AVAL_REPORT):  %IF condition %symexist(_default_box) ne 0 is TRUE
SYMBOLGEN:  Macro variable _DEFAULT_BOX resolves to Timepoint
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_default_box" ne "" is TRUE
SYMBOLGEN:  Macro variable _DEFAULT_BOX resolves to Timepoint
MPRINT(JM_AVAL_REPORT):   put "NOTE: [JM_AVAL_REPORT] is missing required parameter JM_GROUPLABEL. " "However, the macro variable 
_DEFAULT_BOX (Timepoint) exist so it will be used for JM_GROUPLABEL." "This is the report label for grouping variable (i.e. 
Characteristic (unit)^nCategory).";
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable _DEFAULT_BOX resolves to Timepoint
MPRINT(JM_AVAL_REPORT):   call symputx('JM_GROUPLABEL', "Timepoint");
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: [JM_AVAL_REPORT] is missing required parameter JM_GROUPLABEL. 
However, the macro variable _DEFAULT_BOX (Timepoint) exist so it will be used for JM_GROUPLABEL.
This is the report label for grouping variable (i.e. Characteristic (unit)^nCategory).
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Check missing defvault values for JM_BYVAR ***;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_BYVAR"="" is TRUE
MPRINT(JM_AVAL_REPORT):   data _null_;
                                                           The SAS System

MLOGIC(JM_AVAL_REPORT):  %IF condition %symexist(_DEFAULT_BYVARS) ne 0 is TRUE
SYMBOLGEN:  Macro variable _DEFAULT_BYVARS resolves to 
MPRINT(JM_AVAL_REPORT):   if compress("") ne "" then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable _DEFAULT_BYVARS resolves to 
MPRINT(JM_AVAL_REPORT):   put "NOTE: [JM_AVAL_REPORT] is missing parameter JM_BYVAR. " "However the macro variable _DEFAULT_BYVARS 
defined with value () will be used." "This is the report label for grouping variable (i.e. Characteristic (unit)^nCategory).";
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable _DEFAULT_BYVARS resolves to 
MPRINT(JM_AVAL_REPORT):   call symputx('JM_BYVAR',"");
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   data _null_;
MLOGIC(JM_AVAL_REPORT):  %IF condition %symexist(_DEFAULT_BYVARS) = 0 is FALSE
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Set default width if not specified ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_CELLWIDTH resolves to 
MPRINT(JM_AVAL_REPORT):   if "" = "" then do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "NOTE: [JM_AVAL_REPORT] does not have a value specified for parameter JM_CELLWIDTH. " "Thus, the 
default value (1.2in) is set for JM_CELLWIDTH. " "This specifies the cell width for reporting.";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symputx('JM_CELLWIDTH','2.5in');
MPRINT(JM_AVAL_REPORT):   end;
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 
MPRINT(JM_AVAL_REPORT):   if "" = "" then do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "NOTE: [JM_AVAL_REPORT] does not have a value specified for parameter JM_TRTWIDTH. " "Thus, the 
default value (1in) is set for JM_TRTWIDTH. " "This specifies the treatment cell width for reporting.";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symputx('JM_TRTWIDTH','1in');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;


NOTE: [JM_AVAL_REPORT] does not have a value specified for parameter JM_CELLWIDTH. 
Thus, the default value (1.2in) is set for JM_CELLWIDTH. This specifies the cell width for reporting.


NOTE: [JM_AVAL_REPORT] does not have a value specified for parameter JM_TRTWIDTH. 
Thus, the default value (1in) is set for JM_TRTWIDTH. This specifies the treatment cell width for reporting.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Verify invalid values ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   if exist("Jm_aval_allreport1") = 0 then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] specified dataset 'Jm_aval_allreport1' for parameter JM_INDSN does not 
exist. " "This is the input SAS dataset name (i.e. JM_AVAL_SUM1, JM_AVAL_COUNT1).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MPRINT(JM_AVAL_REPORT):   if lowcase("Table") = "table" then do;
SYMBOLGEN:  Macro variable JM_BIGNDSN resolves to Jm_bign1
MPRINT(JM_AVAL_REPORT):   if exist("Jm_bign1") = 0 then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_BIGNDSN resolves to Jm_bign1
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] specified dataset 'Jm_bign1' for parameter JM_BIGNDSN does not exist. " 
"This is the input SAS dataset containing Big N denominator (i.e. JM_AVAL_BIGN1).";
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Verify existince of variables JM_COL2VAR and JM_BREAKVAR ***;
SYMBOLGEN:  Macro variable JM_COL2VAR resolves to 
SYMBOLGEN:  Macro variable JM_BREAKVAR resolves to jm_aval_label
SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_COL2VAR" ne "" or "&JM_BREAKVAR" ne "" or "&JM_BYVAR" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   proc contents data = Jm_aval_allreport1 out = v_indsn noprint;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: The data set WORK.V_INDSN has 30 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_REPORT):  %LET (variable name is V_COL2VAR)
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is V_BREAKVAR)
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is V_BYVAR)
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is V_NAMEC)
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   set v_indsn;
SYMBOLGEN:  Macro variable JM_COL2VAR resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_COL2VAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_BREAKVAR resolves to jm_aval_label
MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_BREAKVAR" ne "" is TRUE
SYMBOLGEN:  Macro variable JM_BREAKVAR resolves to jm_aval_label
MPRINT(JM_AVAL_REPORT):   if upcase(name) = upcase(strip("jm_aval_label")) then call symputx('v_breakvar','yes');
SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
                                                           The SAS System

MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_BYVAR" ne "" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Handle case of numeric JM_AVAL_NAMEC **;
MPRINT(JM_AVAL_REPORT):   if upcase(strip(name)) = 'JM_AVAL_NAMEC' and type = 1 then call symputx('v_namec','num');
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 30 observations read from the data set WORK.V_INDSN.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Update JM_AVAL_NAMEC to be character if numeric ***;
SYMBOLGEN:  Macro variable V_NAMEC resolves to char
MLOGIC(JM_AVAL_REPORT):  %IF condition "&v_namec" = "num" is FALSE
MPRINT(JM_AVAL_REPORT):   data _null_;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
SYMBOLGEN:  Macro variable JM_COL2VAR resolves to 
SYMBOLGEN:  Macro variable V_COL2VAR resolves to no
MPRINT(JM_AVAL_REPORT):   if "" ne "" and "no" = "no" then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_COL2VAR resolves to 
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] specified variable for parameter JM_COL2VAR " "() does not exist. " "This 
is the optional user selected column variable for the report. ";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
SYMBOLGEN:  Macro variable JM_BREAKVAR resolves to jm_aval_label
SYMBOLGEN:  Macro variable V_BREAKVAR resolves to yes
MPRINT(JM_AVAL_REPORT):   if "jm_aval_label" ne "" and "yes" = "no" then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_BREAKVAR resolves to jm_aval_label
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] specified variable for parameter JM_BREAKVAR (jm_aval_label) does not 
exist. " "This is the variable use for breaking page (i.e. GROUPLABEL).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   end;
SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
SYMBOLGEN:  Macro variable V_BYVAR resolves to no
MPRINT(JM_AVAL_REPORT):   if "" ne "" and "no" = "no" then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] specified variable for parameter JM_BYVAR () does not exist. " "This is 
the first sort by variable used in summary.";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Verify invalid values parameters oprional Y/N ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_BREAKOPT resolves to N
SYMBOLGEN:  Macro variable JM_BREAKOPT resolves to N
MPRINT(JM_AVAL_REPORT):   if "N" ne "" and strip(upcase("N")) not in ("Y","N","YES","NO") then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_BREAKOPT resolves to N
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] Contain an invalid value 'N' for parameter JM_BREAKOPT. " "This is option 
to define compute break before variable (i.e. Y).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
SYMBOLGEN:  Macro variable JM_INDENTOPT resolves to N
SYMBOLGEN:  Macro variable JM_INDENTOPT resolves to N
MPRINT(JM_AVAL_REPORT):   if "N" ne "" and strip(upcase("N")) not in ("Y","N","YES","NO") then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_INDENTOPT resolves to N
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] Contain an invalid value 'N' for parameter JM_INDENTOPT. " "This is 
option to Left indentation option for column in report (i.e. Y).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   end;
SYMBOLGEN:  Macro variable JM_SPANHEADOPT resolves to Y
SYMBOLGEN:  Macro variable JM_SPANHEADOPT resolves to Y
MPRINT(JM_AVAL_REPORT):   if "Y" ne "" and strip(upcase("Y")) not in ("Y","N","YES","NO") then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_SPANHEADOPT resolves to Y
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] Contain an invalid value 'Y' for parameter JM_SPANHEADOPT. " "This is 
option for spanning header in report option (i.e. Y).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Verify valid numerical values ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   *** Verify the parameter JM_CELLWIDTH ***;
SYMBOLGEN:  Macro variable JM_CELLWIDTH resolves to 2.5in
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = lowcase(strip("2.5in"));
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'0','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'1','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'2','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'3','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'4','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'5','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'6','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'7','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'8','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'9','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'.','');
MPRINT(JM_AVAL_REPORT):   CELLWIDTH = tranwrd(CELLWIDTH,'in','');
MPRINT(JM_AVAL_REPORT):   if CELLWIDTH ne '' then do;
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] contain invalid characters '" CELLWIDTH +(-1) "' for JM_CELLWIDTH 
parameter. " "This specifies the cell width for reporting (i.e. 1.2in).";
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MPRINT(JM_AVAL_REPORT):   if lowcase("Table") = "table" then do;
MPRINT(JM_AVAL_REPORT):   *** Verify the parameter JM_TRTWIDTH ***;
SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 1in
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = lowcase(strip("1in"));
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'0','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'1','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'2','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'3','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'4','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'5','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'6','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'7','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'8','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'9','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'.','');
MPRINT(JM_AVAL_REPORT):   TRTWIDTH = tranwrd(TRTWIDTH,'in','');
MPRINT(JM_AVAL_REPORT):   if TRTWIDTH ne '' then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 1in
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] contain invalid characters '" TRTWIDTH +(-1) "' for JM_TRTWIDTH (1in) 
parameter. " "This specifies the treatment cell width for reporting (i.e. 1in).";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   data _null_;
MLOGIC(JM_AVAL_REPORT):  %IF condition (%sysfunc(libref(TLFDATA)) ne 0) is FALSE
MPRINT(JM_AVAL_REPORT):   run;
                                                           The SAS System


NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Verify if subgroup (JM_SUBGRP) was applied in JM_BIGN ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is V_BIGN)
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is JM_SUBGRP)
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   if exist('jm_bign3') then call symputx('v_bign','jm_bign3');
MPRINT(JM_AVAL_REPORT):   if exist('jm_bign2') then call symputx('v_bign','jm_bign2');
MPRINT(JM_AVAL_REPORT):   if exist('jm_bign1') then call symputx('v_bign','jm_bign1');
MPRINT(JM_AVAL_REPORT):   if exist('jm_bign0') then call symputx('v_bign','jm_bign0');
MPRINT(JM_AVAL_REPORT):   if exist('jm_bign') then call symputx('v_bign','jm_bign');
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_REPORT):  %PUT NOTE: The JM_BIGN dataset is: &v_bign
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
NOTE: The JM_BIGN dataset is: jm_bign1
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MLOGIC(JM_AVAL_REPORT):  %IF condition "&v_bign" ne "none" is TRUE
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   length jm_subgrp $80;
SYMBOLGEN:  Macro variable V_BIGN resolves to jm_bign1
MPRINT(JM_AVAL_REPORT):   set jm_bign1;
MPRINT(JM_AVAL_REPORT):   if jm_subgrp ne '' then call symputx('jm_subgrp',jm_subgrp);
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_BIGN1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      
                                                           The SAS System


MLOGIC(JM_AVAL_REPORT):  %PUT NOTE: The JM_SUBGRP dataset is: &JM_SUBGRP
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
NOTE: The JM_SUBGRP dataset is:
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is GRPCNT)
MPRINT(JM_AVAL_REPORT):   *** Verify if there are treatment variables in the dataset ***;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   proc contents data=Jm_aval_allreport1 noprint out=Jm_aval_allreport1repcont varnum;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: The data set WORK.JM_AVAL_ALLREPORT1REPCONT has 30 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   proc sort data=Jm_aval_allreport1repcont;
MPRINT(JM_AVAL_REPORT):   by varnum;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 30 observations read from the data set WORK.JM_AVAL_ALLREPORT1REPCONT.
NOTE: SAS sort was used.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1REPCONT has 30 observations and 41 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_REPORT):  %LET (variable name is TRTEXIST)
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1repcont;
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   if index(upcase(name),'TRT') > 0 then call symput('trtexist','yes');
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 30 observations read from the data set WORK.JM_AVAL_ALLREPORT1REPCONT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable TRTEXIST resolves to yes
MPRINT(JM_AVAL_REPORT):   if "yes" = "no" then do;
MPRINT(JM_AVAL_REPORT):   put " ";
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   put "ER" "ROR: [JM_AVAL_REPORT] No treatment variable(s) were found in dataset JM_INDSN 
(Jm_aval_allreport1). " "Treatment variables must contain 'TRT' as part of its name.";
MPRINT(JM_AVAL_REPORT):   put " ";
MPRINT(JM_AVAL_REPORT):   call symput('_err','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *************************************************************************;
MPRINT(JM_AVAL_REPORT):   * Start to Generate report since passed er ror checking. *;
MPRINT(JM_AVAL_REPORT):   *************************************************************************;
MPRINT(JM_AVAL_REPORT):   *** Create a macro variable _REPORT_TRTVARS containing all the treatments ***;
MPRINT(JM_AVAL_REPORT):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   select distinct name into: _REPORT_TRTVARS separated by " " from Jm_aval_allreport1repcont where 
(find(name,"TRT","i") and index(upcase(name),'VARN') = 0);
MPRINT(JM_AVAL_REPORT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
                                                           The SAS System


MPRINT(JM_AVAL_REPORT):   *** Merge input dataset with JM_BIGN by Treatment ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   data Jm_aval_allreport1repcont;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1repcont;
MPRINT(JM_AVAL_REPORT):   where find(name,"TRT","i");
MPRINT(JM_AVAL_REPORT):   JM_TRTVARN=input(COMPRESS(NAME,'','KD'),best.);
MPRINT(JM_AVAL_REPORT):   keep name JM_TRTVARN varnum;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 4 observations read from the data set WORK.JM_AVAL_ALLREPORT1REPCONT.
      WHERE FIND(name, 'TRT', 'i');
NOTE: The data set WORK.JM_AVAL_ALLREPORT1REPCONT has 4 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   proc sql undo_policy=none;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
SYMBOLGEN:  Macro variable JM_BIGNDSN resolves to Jm_bign1
MPRINT(JM_AVAL_REPORT):   create table Jm_aval_allreport1repcont as select a.name, a.varnum,b.* from Jm_aval_allreport1repcont as a 
left join Jm_bign1 as b on a.JM_TRTVARN=b.JM_TRTVARN;
NOTE: Table WORK.JM_AVAL_ALLREPORT1REPCONT created, with 4 rows and 9 columns.

MPRINT(JM_AVAL_REPORT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1repcont end=eof;
MPRINT(JM_AVAL_REPORT):   call symputx(catt("trtv",_n_),name);
MPRINT(JM_AVAL_REPORT):   if find(JM_AVAL_BIGN_LABEL,":") then CALL SYMPUTX(CATT("TRTLAB",_n_),scan(JM_AVAL_BIGN_LABEL,2,":"));
MPRINT(JM_AVAL_REPORT):   else CALL SYMPUTX(CATT("TRTLAB",_n_),JM_AVAL_BIGN_LABEL);
MPRINT(JM_AVAL_REPORT):   if eof then call symputx("tottrtv",_n_);
MPRINT(JM_AVAL_REPORT):   run;
                                                           The SAS System


NOTE: There were 4 observations read from the data set WORK.JM_AVAL_ALLREPORT1REPCONT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Handle sub group ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is GRPCNT)
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&jm_subgrp" ne "" is FALSE
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="listing" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Verify if pageno has been imputed ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is V_PAGENO)
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   proc contents data = Jm_aval_allreport1 out=v_pageno noprint;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: The data set WORK.V_PAGENO has 30 observations and 41 variables.
NOTE: PROCEDURE CONTENTS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   set v_pageno;
MPRINT(JM_AVAL_REPORT):   if upcase(name)='PAGENO' then call symputx('v_pageno','yes');
MPRINT(JM_AVAL_REPORT):   run;
NOTE: There were 30 observations read from the data set WORK.V_PAGENO.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   data Jm_aval_allreport1;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1;
MPRINT(JM_AVAL_REPORT):   *** Define pageno if not yet imputed ***;
SYMBOLGEN:  Macro variable V_PAGENO resolves to yes
MLOGIC(JM_AVAL_REPORT):  %IF condition "&v_pageno" = "no" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Legacy code from original TLFM.SAS within %TF Macro which is no longer used ***;
MPRINT(JM_AVAL_REPORT):   *** array temp $ &_REPORT_TRTVARS.;
MPRINT(JM_AVAL_REPORT):   *** do over temp;
MPRINT(JM_AVAL_REPORT):   *** if _TYPE_="FREQ" and strip(upcase(JM_AVAL_NAMEC)) ne "SCREEN FAILURES" and missing(temp) then *** 
temp="0";
MPRINT(JM_AVAL_REPORT):   *** end;
MPRINT(JM_AVAL_REPORT):   _page=pageno;
MPRINT(JM_AVAL_REPORT):   _bottom_line_=pageno;
MPRINT(JM_AVAL_REPORT):   _ord_=_n_;
MPRINT(JM_AVAL_REPORT):   length _temp $40;
MPRINT(JM_AVAL_REPORT):   if find(JM_AVAL_NAMEC,":") then do;
MPRINT(JM_AVAL_REPORT):   _temp = scan(JM_AVAL_NAMEC,1,":");
MPRINT(JM_AVAL_REPORT):   if NOTDIGIT(TRIM(LEFT(_temp)))=0 then do;
MPRINT(JM_AVAL_REPORT):   JM_AVAL_NAMEN=input(scan(JM_AVAL_NAMEC,1,":"),best.);
MPRINT(JM_AVAL_REPORT):   JM_AVAL_NAMEC=strip(scan(JM_AVAL_NAMEC,2,":"));
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   drop _temp;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 33 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Capture the current program name to be used as output validation dataset ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is _VALOUTNM)
MLOGIC(JM_GET_PGMNAME):  Beginning execution.
MLOGIC(JM_GET_PGMNAME):  This macro was compiled from the autocall file C:\SASData\stat\Global 
      Tools\Production\TOOLS\jm_get_pgmname.sas
MLOGIC(JM_GET_PGMNAME):  %LOCAL  JM_PGMNAME
SYMBOLGEN:  Macro variable SYSPROCESSNAME resolves to Program "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas"
MLOGIC(JM_GET_PGMNAME):  %IF condition %index(&sysprocessname,DMS) is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable SYSPROCESSNAME resolves to Program "C:\SASData\JZP-150\150-201\stat\csr_dryrun1\pgm\tlf\t_ecg_saffl.sas"
MLOGIC(JM_GET_PGMNAME):  %IF condition %index(&sysprocessname,Program) is TRUE
MLOGIC(JM_GET_PGMNAME):  %LET (variable name is JM_PGMNAME)
SYMBOLGEN:  Macro variable JM_PGMNAME resolves to t_ecg_saffl
MLOGIC(JM_GET_PGMNAME):  Ending execution.
MPRINT(JM_AVAL_REPORT):   *** Identify the validation output based on output name ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is VALOUT)
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   set jm_tf_titft;
SYMBOLGEN:  Macro variable _VALOUTNM resolves to t_ecg_saffl
MPRINT(JM_AVAL_REPORT):   pgmname = lowcase("t_ecg_saffl");
MPRINT(JM_AVAL_REPORT):   pgmname = strip(tranwrd(pgmname,'.sas',''));
MPRINT(JM_AVAL_REPORT):   valoutnm = lowcase(strip(symget('_valoutnm')));
SYMBOLGEN:  Macro variable _VALOUTNM resolves to t_ecg_saffl
MLOGIC(JM_AVAL_REPORT):  %IF condition "&_valoutnm" ne "" is TRUE
MPRINT(JM_AVAL_REPORT):   if lowcase(program) = lowcase(pgmname) then do;
MPRINT(JM_AVAL_REPORT):   valout = strip(name);
MPRINT(JM_AVAL_REPORT):   valout=prxchange('s/[^[:alnum:][:space:]]+/_/',-1,valout);
MPRINT(JM_AVAL_REPORT):   call symputx('valout',valout);
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      396:138  valoutnm
NOTE: There were 162 observations read from the data set WORK.JM_TF_TITFT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

SYMBOLGEN:  Macro variable VALOUT resolves to T_9_03_03_01_01
MLOGIC(JM_AVAL_REPORT):  %IF condition "&valout" = "" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Update dashes and other special characters to underscore for QC dataset name ***;
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   valout=strip(symget('valout'));
MPRINT(JM_AVAL_REPORT):   valout=prxchange('s/[^[:alnum:][:space:]]+/_/',-1,valout);
MPRINT(JM_AVAL_REPORT):   call symputx('valout',valout);
MPRINT(JM_AVAL_REPORT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      396:114  valout
                                                           The SAS System

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Verify if dataset exists ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is V_EXIST)
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable VALOUT resolves to T_9_03_03_01_01
MPRINT(JM_AVAL_REPORT):   if exist("TLFDATA.T_9_03_03_01_01") then call symputx('v_exist','yes');
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_REPORT):  %PUT NOTE: Verify QC dataset exist v_exist=&v_exist..
SYMBOLGEN:  Macro variable V_EXIST resolves to no
NOTE: Verify QC dataset exist v_exist=no.
SYMBOLGEN:  Macro variable V_EXIST resolves to no
MLOGIC(JM_AVAL_REPORT):  %IF condition "&v_exist" = "yes" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Create the first version of the QC dataset ***;
SYMBOLGEN:  Macro variable VALOUT resolves to T_9_03_03_01_01
MPRINT(JM_AVAL_REPORT):   data TLFDATA.T_9_03_03_01_01;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
SYMBOLGEN:  Macro variable _DEFAULT_BYVARS resolves to 
MPRINT(JM_AVAL_REPORT):   keep JM_AVAL_NAMEC JM_AVAL_LABEL tr: JM_BLOCK ;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set TLFDATA.T_9_03_03_01_01 has 351 observations and 7 variables.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Process spanning headers to decipher user defined span headers ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is SPAN_USER)
SYMBOLGEN:  Macro variable JM_SPANHEADOPT resolves to Y
MLOGIC(JM_AVAL_REPORT):  %IF condition &jm_spanheadopt=Y is TRUE
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   length spanh $200;
MPRINT(JM_AVAL_REPORT):   spanh = trim(symget('_DEFAULT_SPAN_HEAD'));
MPRINT(JM_AVAL_REPORT):   *** Check for multiple parenthsis to classify as user defined ***;
MPRINT(JM_AVAL_REPORT):   parens=0;
MPRINT(JM_AVAL_REPORT):   do i = 1 to length(spanh);
MPRINT(JM_AVAL_REPORT):   if substr(spanh,i,1) = '(' then parens = parens + 1;
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   quotes =0;
MPRINT(JM_AVAL_REPORT):   if index(spanh,'"') then quotes=quotes+1;
MPRINT(JM_AVAL_REPORT):   if index(spanh,"'") then quotes=quotes+1;
MPRINT(JM_AVAL_REPORT):   if parens > 1 and quotes>0 then call symputx('span_user','Yes');
MPRINT(JM_AVAL_REPORT):   else call symputx('span_user','No');
MPRINT(JM_AVAL_REPORT):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_REPORT):  %PUT NOTE: Macro variable SPAN_USER=&span_user
SYMBOLGEN:  Macro variable SPAN_USER resolves to Yes
NOTE: Macro variable SPAN_USER=Yes
MPRINT(JM_AVAL_REPORT):   *** Identify the total number of page counts ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is TOT_PAGE)
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1 ;
MPRINT(JM_AVAL_REPORT):   retain tot_page 0;
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   if tot_page < pageno then tot_page = pageno;
MPRINT(JM_AVAL_REPORT):   call symputx('tot_page',tot_page);
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Check for cases with No Data ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is C_ANYDATA)
MPRINT(JM_AVAL_REPORT):   data _null_;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1;
MPRINT(JM_AVAL_REPORT):   jm_aval_namec = tranwrd(jm_aval_namec,'.','');
MPRINT(JM_AVAL_REPORT):   if compress(jm_aval_label) ne '' or jm_aval_namec ne '' then call symputx('c_anydata','yes');
MPRINT(JM_AVAL_REPORT):   *** Handle data listing ***;
SYMBOLGEN:  Macro variable VALOUT resolves to T_9_03_03_01_01
MPRINT(JM_AVAL_REPORT):   if lowcase(substr("T_9_03_03_01_01",1,1)) = "l" then do;
MPRINT(JM_AVAL_REPORT):   if _n_ > 2 then call symputx('c_anydata','yes');
MPRINT(JM_AVAL_REPORT):   end;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable C_ANYDATA resolves to yes
MLOGIC(JM_AVAL_REPORT):  %IF condition "&c_anydata" = "no" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Update indentations with RTF indent control words ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   data Jm_aval_allreport1;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1;
MPRINT(JM_AVAL_REPORT):   if substr(jm_aval_namec,1,3) = '   ' then do;
MPRINT(JM_AVAL_REPORT):   *** Add indentation RTF code but retain extra spaces ***;
MPRINT(JM_AVAL_REPORT):   jm_aval_namec = '^R"\li600 "' || substr(jm_aval_namec,4);
MPRINT(JM_AVAL_REPORT):   end;
                                                           The SAS System

MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 33 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Verify if user has defined underscore to their spanning headers ***;
MLOGIC(JM_AVAL_REPORT):  %LET (variable name is HASUNDER)
MPRINT(JM_AVAL_REPORT):   data _null_;
MPRINT(JM_AVAL_REPORT):   span = symget('_DEFAULT_SPAN_HEAD');
MPRINT(JM_AVAL_REPORT):   if index(lowcase(span),'\brdr') then call symputx('hasunder','yes');
MPRINT(JM_AVAL_REPORT):   run;

INFO: Character variables have defaulted to a length of 200 at the places given by: (Line):(Column). Truncation can result.
      396:23   span
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MLOGIC(JM_AVAL_REPORT):  %LET (variable name is _ORIG_DEFAULT_SPAN_HEAD)
SYMBOLGEN:  Macro variable _DEFAULT_SPAN_HEAD resolves to (("^R'\brdrb\brdrs\brdrw4 ' Treatment Group" trtn1 trtn2 trtn3)  trtn99)
MPRINT(JM_AVAL_REPORT):   *** Loop through subgroups ***;
SYMBOLGEN:  Macro variable GRPCNT resolves to 1
MLOGIC(JM_AVAL_REPORT):  %DO loop beginning; index variable J; start value is 1; stop value is 1; by value is 1.  
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Handle the case of empty dataset or 'No data available' ***;
MPRINT(JM_AVAL_REPORT):   proc sql noprint;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   select count(*) into :obscount from Jm_aval_allreport1;
MPRINT(JM_AVAL_REPORT):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable OBSCOUNT resolves to      351
                                                           The SAS System

MLOGIC(JM_AVAL_REPORT):  %IF condition &obscount = 0 is FALSE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&jm_subgrp" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
SYMBOLGEN:  Macro variable SPAN_USER resolves to Yes
MLOGIC(JM_AVAL_REPORT):  %IF condition "&span_user" = "No" is FALSE
SYMBOLGEN:  Macro variable HASUNDER resolves to yes
MLOGIC(JM_AVAL_REPORT):  %IF condition "&hasunder" = "no" is FALSE
SYMBOLGEN:  Macro variable SPAN_USER resolves to Yes
MLOGIC(JM_AVAL_REPORT):  %IF condition "&span_user" = "Yes" is TRUE
MPRINT(JM_AVAL_REPORT):   proc report data=Jm_aval_allreport1 nowd CENTER style(header)=[just=center ] style(report)=[asis=on 
protectspecialchars=off Just=left outputwidth=9.25 in ] missing headline headskip nowd split='|' spacing=1 out=tempreport;
MPRINT(JM_AVAL_REPORT):  ;
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_REPORT):   *** Define Report of type: Table ***;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
SYMBOLGEN:  Macro variable JM_SPANHEADOPT resolves to Y
MLOGIC(JM_AVAL_REPORT):  %IF condition &jm_spanheadopt=N is FALSE
SYMBOLGEN:  Macro variable JM_SPANHEADOPT resolves to Y
MLOGIC(JM_AVAL_REPORT):  %IF condition &jm_spanheadopt=Y is TRUE
MPRINT(JM_AVAL_REPORT):   *** Option JM_SPANHEADOPT = Y ***;
SYMBOLGEN:  Macro variable SPAN_USER resolves to Yes
MLOGIC(JM_AVAL_REPORT):  %IF condition "&span_user" = "Yes" is TRUE
SYMBOLGEN:  Macro variable _DEFAULT_SPAN_HEAD resolves to (("^R'\brdrb\brdrs\brdrw4 ' Treatment Group" trtn1 trtn2 trtn3)  trtn99)
MPRINT(JM_AVAL_REPORT):   columns PAGENO _page _bottom_line_ JM_BLOCK JM_AVAL_LABEL JM_AVAL_NAMEN JM_AVAL_NAMEC 
(("^R'\brdrb\brdrs\brdrw4 ' Treatment Group" trtn1 trtn2 trtn3) trtn99);
MPRINT(JM_AVAL_REPORT):   *** Define Report of type: Listing ***;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="listing" is FALSE
                                                           The SAS System

SYMBOLGEN:  Macro variable JM_BYVAR resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_BYVAR" ne "" is FALSE
SYMBOLGEN:  Macro variable JM_SUBGRP resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&jm_subgrp" ne "" is FALSE
MPRINT(JM_AVAL_REPORT):   define pageno /order order=internal noprint;
MPRINT(JM_AVAL_REPORT):   define _page /order order=internal noprint;
MPRINT(JM_AVAL_REPORT):   define _bottom_line_/order order=internal noprint;
MPRINT(JM_AVAL_REPORT):   *** Define variables for Report Type: Table ***;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="table" is TRUE
MPRINT(JM_AVAL_REPORT):   define JM_BLOCK/order order=data NOPRINT;
MPRINT(JM_AVAL_REPORT):   define JM_AVAL_LABEL/order order=data noprint;
MPRINT(JM_AVAL_REPORT):   define JM_AVAL_NAMEN/order order=internal noprint;
SYMBOLGEN:  Macro variable JM_GROUPLABEL resolves to Timepoint
SYMBOLGEN:  Macro variable JM_CELLWIDTH resolves to 2.5in
SYMBOLGEN:  Macro variable JM_INDENTOPT resolves to N
MLOGIC(JM_AVAL_REPORT):  %IF condition &JM_INDENTOPT=Y is FALSE
MPRINT(JM_AVAL_REPORT):   define JM_AVAL_NAMEC/order order=data "Timepoint " style(header)=[just=left asis=on] flow 
style(column)=[protectspecialchars=off just=left asis=on cellwidth=2.5in ] ;
SYMBOLGEN:  Macro variable JM_COL2VAR resolves to 
MLOGIC(JM_AVAL_REPORT):  %IF condition "&JM_COL2VAR" NE "" is FALSE
SYMBOLGEN:  Macro variable TOTTRTV resolves to 4
MLOGIC(JM_AVAL_REPORT):  %DO loop beginning; index variable I; start value is 1; stop value is 4; by value is 1.  
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable TRTV1 resolves to trtn1
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 1in
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 1
SYMBOLGEN:  Macro variable TRTLAB1 resolves to JZP150 0.3 mg |(N=10)
MPRINT(JM_AVAL_REPORT):   define trtn1 / display style(header)=[just=left pretext="^R'\tqdec\tx560  '"] 
style(column)=[protectspecialchars=off just=left cellwidth=1in pretext="^R'\tqdec\tx560  '"] "JZP150 0.3 mg |(N=10)";
MLOGIC(JM_AVAL_REPORT):  %DO loop index variable I is now 2; loop will iterate again.
SYMBOLGEN:  && resolves to &.
                                                           The SAS System

SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable TRTV2 resolves to trtn2
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 1in
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 2
SYMBOLGEN:  Macro variable TRTLAB2 resolves to JZP150 4 mg |(N=18)
MPRINT(JM_AVAL_REPORT):   define trtn2 / display style(header)=[just=left pretext="^R'\tqdec\tx560  '"] 
style(column)=[protectspecialchars=off just=left cellwidth=1in pretext="^R'\tqdec\tx560  '"] "JZP150 4 mg |(N=18)";
MLOGIC(JM_AVAL_REPORT):  %DO loop index variable I is now 3; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable TRTV3 resolves to trtn3
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 1in
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 3
SYMBOLGEN:  Macro variable TRTLAB3 resolves to Placebo |(N=20)
MPRINT(JM_AVAL_REPORT):   define trtn3 / display style(header)=[just=left pretext="^R'\tqdec\tx560  '"] 
style(column)=[protectspecialchars=off just=left cellwidth=1in pretext="^R'\tqdec\tx560  '"] "Placebo |(N=20)";
MLOGIC(JM_AVAL_REPORT):  %DO loop index variable I is now 4; loop will iterate again.
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable TRTV4 resolves to trtn99
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  Macro variable JM_TRTWIDTH resolves to 1in
SYMBOLGEN:  Macro variable _DEFAULT_TWIPS resolves to 560
SYMBOLGEN:  && resolves to &.
SYMBOLGEN:  Macro variable I resolves to 4
SYMBOLGEN:  Macro variable TRTLAB4 resolves to JZP150 Total |(N=28)
MPRINT(JM_AVAL_REPORT):   define trtn99 / display style(header)=[just=left pretext="^R'\tqdec\tx560  '"] 
style(column)=[protectspecialchars=off just=left cellwidth=1in pretext="^R'\tqdec\tx560  '"] "JZP150 Total |(N=28)";
MLOGIC(JM_AVAL_REPORT):  %DO loop index variable I is now 5; loop will not iterate again.
MPRINT(JM_AVAL_REPORT):   *** Define variables for Report Type: Listing ***;
MLOGIC(LOWCASE):  Beginning execution.
MLOGIC(LOWCASE):  This macro was compiled from the autocall file C:\SASHome\SASFoundation\9.4\core\sasmacro\lowcase.sas
SYMBOLGEN:  Macro variable JM_REPTYPE resolves to Table
MLOGIC(LOWCASE):  Parameter STRING has value "Table"
SYMBOLGEN:  Macro variable STRING resolves to "Table"
                                                           The SAS System

MLOGIC(LOWCASE):  Ending execution.
MLOGIC(JM_AVAL_REPORT):  %IF condition %lowcase("&jm_reptype")="listing" is FALSE
SYMBOLGEN:  Macro variable JM_BREAKOPT resolves to N
MLOGIC(JM_AVAL_REPORT):  %IF condition &jm_breakopt=Y is FALSE
MPRINT(JM_AVAL_REPORT):   COMPUTE before pageno;
MPRINT(JM_AVAL_REPORT):   line " ";
MPRINT(JM_AVAL_REPORT):   ENDCOMP;
MPRINT(JM_AVAL_REPORT):   BREAK AFTER PAGENO/PAGE;
MPRINT(JM_AVAL_REPORT):   compute after _bottom_line_/ style=[protectspecialchars=off just=r font_size=8pt];
MPRINT(JM_AVAL_REPORT):   line "\brdrb\brdrs\brdrw1";
MPRINT(JM_AVAL_REPORT):   endcomp;
MPRINT(JM_AVAL_REPORT):   run;
NOTE: Multiple concurrent threads will be used to summarize data.
NOTE: PROCEDURE REPORT used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
      
NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set WORK.TEMPREPORT has 420 observations and 12 variables.

MLOGIC(JM_AVAL_REPORT):  %DO loop index variable J is now 2; loop will not iterate again.
MPRINT(JM_AVAL_REPORT):   *** Retain and put back original dataset ***;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   data Jm_aval_allreport1;
SYMBOLGEN:  Macro variable JM_INDSN resolves to Jm_aval_allreport1
MPRINT(JM_AVAL_REPORT):   set Jm_aval_allreport1_ori;
MPRINT(JM_AVAL_REPORT):   run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1_ORI.
NOTE: The data set WORK.JM_AVAL_ALLREPORT1 has 351 observations and 30 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

MPRINT(JM_AVAL_REPORT):   *** Mark the end of parameter checking ***;
MLOGIC(JM_AVAL_REPORT):  Ending execution.
397        
398        *------------------------------------------------------------------------------------------------------------------------
398      ! ----------;
399        *ODS CLOSE- CLOSES RTF DESTINATION;
                                                           The SAS System

400        *------------------------------------------------------------------------------------------------------------------------
400      ! ----------;
401        %JM_ODSCLOSE;
MLOGIC:  Beginning compilation of REM_BLKPG using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_odsclose.sas.
MLOGIC:  Ending compilation of REM_BLKPG.
MLOGIC:  Beginning compilation of JM_ODSCLOSE using the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_odsclose.sas.
MLOGIC:  Ending compilation of JM_ODSCLOSE.
MLOGIC(JM_ODSCLOSE):  Beginning execution.
MLOGIC(JM_ODSCLOSE):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_odsclose.sas
MLOGIC(JM_ODSCLOSE):  Parameter JM_ODSTYPE has value rtf
MPRINT(JM_ODSCLOSE):   *** Document in log what parameter value specified ***;
MPRINT(JM_ODSCLOSE):   data _null_;
MPRINT(JM_ODSCLOSE):   put ' ';
MPRINT(JM_ODSCLOSE):   put "******************* Parameter Values *******************";
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSCLOSE):   PUT "ALERT:I: JM_ODSTYPE PROCESSED - rtf";
MPRINT(JM_ODSCLOSE):   put "********************************************************";
MPRINT(JM_ODSCLOSE):   put " ";
MPRINT(JM_ODSCLOSE):   put 'NOTE: [JM_ODSCLOSE] is currently running macro %jm_odsclose version 1.0.';
MPRINT(JM_ODSCLOSE):   put " ";
MPRINT(JM_ODSCLOSE):   run;


******************* Parameter Values *******************
ALERT:I: JM_ODSTYPE PROCESSED - rtf
********************************************************

NOTE: [JM_ODSCLOSE] is currently running macro %jm_odsclose version 1.0.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(JM_ODSCLOSE):   *** Initialize er ror checking condition ***;
MLOGIC(JM_ODSCLOSE):  %LET (variable name is _ERR)
MPRINT(JM_ODSCLOSE):   data _null_;
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSCLOSE):   if "rtf" = "" then do;
MPRINT(JM_ODSCLOSE):   call symputx('JM_ODSTYPE',"rtf");
MPRINT(JM_ODSCLOSE):   put "NOTE: [JM_ODSCLOSE] is missing parameter JM_ODSTYPE. " "However, the default was set to: RTF.";
MPRINT(JM_ODSCLOSE):   put " ";
                                                           The SAS System

MPRINT(JM_ODSCLOSE):   end;
MPRINT(JM_ODSCLOSE):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_ODSCLOSE):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_ODSCLOSE):   *** Verify invalid values ***;
MPRINT(JM_ODSCLOSE):   data _null_;
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSCLOSE):   odstype=upcase(strip("rtf"));
MPRINT(JM_ODSCLOSE):   if odstype ne '' and odstype not in("RTF","PDF") then do;
MPRINT(JM_ODSCLOSE):   put " ";
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSCLOSE):   put "ER" "ROR: [JM_ODSCLOSE] contain invalid value 'rtf' for JM_ODSTYPE parameter. " "This specifies the ODS 
Report output file type (i.e. RTF).";
MPRINT(JM_ODSCLOSE):   put " ";
MPRINT(JM_ODSCLOSE):   call symput('_err','yes');
MPRINT(JM_ODSCLOSE):   end;
MPRINT(JM_ODSCLOSE):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

SYMBOLGEN:  Macro variable _ERR resolves to no
MLOGIC(JM_ODSCLOSE):  %IF condition "&_err" = "yes" is FALSE
MPRINT(JM_ODSCLOSE):   *** Close the ODS Destination ***;
SYMBOLGEN:  Macro variable JM_ODSTYPE resolves to rtf
MPRINT(JM_ODSCLOSE):   ods rtf close;
MPRINT(JM_ODSCLOSE):   *** Remove extra page breaks creating blank page at the bottom ***;
MLOGIC(REM_BLKPG):  Beginning execution.
MLOGIC(REM_BLKPG):  This macro was compiled from the autocall file C:\SASData\stat\Global Tools\Production\TOOLS\jm_odsclose.sas
MLOGIC(REM_BLKPG):  Parameter SOURCE has value _fixrtf
MPRINT(REM_BLKPG):   *** Read the RTF file into a temporary dataset ***;
MPRINT(REM_BLKPG):   data temp ;
MPRINT(REM_BLKPG):   length line $1800;
                                                           The SAS System

SYMBOLGEN:  Macro variable SOURCE resolves to _fixrtf
MPRINT(REM_BLKPG):   infile _fixrtf length=lg lrecl=1800 end=eof;
MPRINT(REM_BLKPG):   input @1 line $varying1800. lg;
MPRINT(REM_BLKPG):   run;

NOTE: The infile _FIXRTF is:
      Filename=C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf,
      RECFM=V,LRECL=1800,File Size (bytes)=380591,
      Last Modified=20Feb2023:15:44:05,
      Create Time=14Feb2023:10:58:00

NOTE: 6041 records were read from the infile _FIXRTF.
      The minimum record length was 5.
      The maximum record length was 288.
NOTE: The data set WORK.TEMP has 6041 observations and 1 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(REM_BLKPG):   *** Identify and remove the page break RTF code ***;
MPRINT(REM_BLKPG):   data _null_;
MPRINT(REM_BLKPG):   set temp ;
MPRINT(REM_BLKPG):   if (index(line,"\page\par") > 0) then line = tranwrd(line,"{\page\par}",' ');
MPRINT(REM_BLKPG):   if (index(line,"{\par}\trowd\trkeep\trqc") > 0) then line = tranwrd(line,"{\par}",' ');
SYMBOLGEN:  Macro variable SOURCE resolves to _fixrtf
MPRINT(REM_BLKPG):   file _fixrtf;
MPRINT(REM_BLKPG):   put line ;
MPRINT(REM_BLKPG):   run;

NOTE: The file _FIXRTF is:
      Filename=C:\SASData\JZP-150\150-201\stat\csr_dryrun1\results\t-9-03-03-01-01.rtf,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=20Feb2023:15:44:05,
      Create Time=14Feb2023:10:58:00

NOTE: 6041 records were written to the file _FIXRTF.
      The minimum record length was 5.
      The maximum record length was 288.
NOTE: There were 6041 observations read from the data set WORK.TEMP.
NOTE: DATA statement used (Total process time):
                                                           The SAS System

      real time           0.02 seconds
      cpu time            0.03 seconds
      

MLOGIC(REM_BLKPG):  Ending execution.
MPRINT(JM_ODSCLOSE):  ;
MPRINT(JM_ODSCLOSE):   *** Mark the end of parameter checking ***;
MLOGIC(JM_ODSCLOSE):  Ending execution.
402        
403        
404        *------------------------------------------------------------------------------------------------------------------------
404      ! ----------;
405        * GENERATE IN-TEXT TABLES
406        *------------------------------------------------------------------------------------------------------------------------
406      ! ----------;
407        %*JM_INTEXT_TABLE (JM_OUTREPORT=&rsltpath.\&outputnm._intext.rtf,
408           JM_INDSN=Jm_aval_allreport1, JM_BIGNDSN=Jm_bign1, jm_spanheadopt=Y , JM_INDENTOPT=N, jm_breakopt=Y,
408      ! jm_breakvar=jm_aval_label,
409           JM_CELLWIDTH=1.25in, JM_TRTWIDTH=.55in, JM_BODYTITLEOPT=0, JM_NOHEADFOOT=Y);
410        
411        
412        
413        
414        %let dsname=T_9_03_03_01_01;
SYMBOLGEN:  Macro variable DSNAME resolves to T_9_03_03_01_01
415        data tlfdata.&dsname;
416        set jm_aval_allreport1;
417        
418        keep JM_: TRTN: PARAM:;
419        run;

NOTE: There were 351 observations read from the data set WORK.JM_AVAL_ALLREPORT1.
NOTE: The data set TLFDATA.T_9_03_03_01_01 has 351 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.01 seconds
      

NOTE: SAS Institute Inc., SAS Campus Drive, Cary, NC USA 27513-2414
NOTE: The SAS System used:
      real time           34.26 seconds
                                                           The SAS System

      cpu time            9.63 seconds
      
